{
    "contracts": [
      {
        "name": "flipper",
        "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod flipper {\n    #[ink(storage)]\n    pub struct Flipper {\n        value: bool,\n    }\n\n    impl Flipper {\n        /// Creates a new flipper smart contract initialized with the given value.\n        #[ink(constructor)]\n        pub fn new(init_value: bool) -> Self {\n            Self { value: init_value }\n        }\n\n        /// Creates a new flipper smart contract initialized to `false`.\n        #[ink(constructor)]\n        pub fn new_default() -> Self {\n            Self::new(Default::default())\n        }\n\n        /// Flips the current value of the Flipper's boolean.\n        #[ink(message)]\n        pub fn flip(&mut self) {\n            self.value = !self.value;\n        }\n\n        /// Returns the current value of the Flipper's boolean.\n        #[ink(message)]\n        pub fn get(&self) -> bool {\n            self.value\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        #[ink::test]\n        fn default_works() {\n            let flipper = Flipper::new_default();\n            assert!(!flipper.get());\n        }\n\n        #[ink::test]\n        fn it_works() {\n            let mut flipper = Flipper::new(false);\n            assert!(!flipper.get());\n            flipper.flip();\n            assert!(flipper.get());\n        }\n    }\n\n    #[cfg(all(test, feature = \"e2e-tests\"))]\n    mod e2e_tests {\n        use super::*;\n        use ink_e2e::ContractsBackend;\n\n        type E2EResult<T> = std::result::Result<T, Box<dyn std::error::Error>>;\n\n        #[ink_e2e::test]\n        async fn it_works<Client: E2EBackend>(mut client: Client) -> E2EResult<()> {\n            // given\n            let mut constructor = FlipperRef::new(false);\n            let contract = client\n                .instantiate(\"flipper\", &ink_e2e::alice(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Flipper>();\n\n            let get = call_builder.get();\n            let get_res = client.call(&ink_e2e::bob(), &get).dry_run().await?;\n            assert!(matches!(get_res.return_value(), false));\n\n            // when\n            let flip = call_builder.flip();\n            let _flip_res = client\n                .call(&ink_e2e::bob(), &flip)\n                .submit()\n                .await\n                .expect(\"flip failed\");\n\n            // then\n            let get = call_builder.get();\n            let get_res = client.call(&ink_e2e::bob(), &get).dry_run().await?;\n            assert!(matches!(get_res.return_value(), true));\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn default_works<Client: E2EBackend>(mut client: Client) -> E2EResult<()> {\n            // given\n            let mut constructor = FlipperRef::new_default();\n\n            // when\n            let contract = client\n                .instantiate(\"flipper\", &ink_e2e::bob(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let call_builder = contract.call_builder::<Flipper>();\n\n            // then\n            let get = call_builder.get();\n            let get_res = client.call(&ink_e2e::bob(), &get).dry_run().await?;\n            assert!(matches!(get_res.return_value(), false));\n\n            Ok(())\n        }\n\n        /// This test illustrates how to test an existing on-chain contract.\n        ///\n        /// You can utilize this to e.g. create a snapshot of a production chain\n        /// and run the E2E tests against a deployed contract there.\n        /// This process is explained [here](https://use.ink/5.x/basics/contract-testing/chain-snapshot).\n        ///\n        /// Before executing the test:\n        ///   * Make sure you have a node running in the background,\n        ///   * Supply the environment variable `CONTRACT_HEX` that points to a deployed\n        ///     flipper contract. You can take the SS58 address which `cargo contract\n        ///     instantiate` gives you and convert it to hex using `subkey inspect\n        ///     <SS58>`.\n        ///\n        /// The test is then run like this:\n        ///\n        /// ```\n        /// # The env variable needs to be set, otherwise `ink_e2e` will spawn a new\n        /// # node process for each test.\n        /// $ export CONTRACTS_NODE_URL=ws://127.0.0.1:9944\n        ///\n        /// $ export CONTRACT_ADDR_HEX=0x2c75f0aa09dbfbfd49e6286a0f2edd3b4913f04a58b13391c79e96782f5713e3\n        /// $ cargo test --features e2e-tests e2e_test_deployed_contract -- --ignored\n        /// ```\n        ///\n        /// # Developer Note\n        ///\n        /// The test is marked as ignored, as it has the above pre-conditions to succeed.\n        #[ink_e2e::test]\n        #[ignore]\n        async fn e2e_test_deployed_contract<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let addr = std::env::var(\"CONTRACT_ADDR_HEX\")\n                .unwrap()\n                .replace(\"0x\", \"\");\n            let acc_id = hex::decode(addr).unwrap();\n            let acc_id = AccountId::try_from(&acc_id[..]).unwrap();\n\n            use std::str::FromStr;\n            let suri = ink_e2e::subxt_signer::SecretUri::from_str(\"//Alice\").unwrap();\n            let caller = ink_e2e::Keypair::from_uri(&suri).unwrap();\n\n            // when\n            // Invoke `Flipper::get()` from `caller`'s account\n            let call_builder = ink_e2e::create_call_builder::<Flipper>(acc_id);\n            let get = call_builder.get();\n            let get_res = client.call(&caller, &get).dry_run().await?;\n\n            // then\n            assert_eq!(get_res.return_value(), true);\n\n            Ok(())\n        }\n    }\n}\n"
      },
      {
        "name": "erc20",
        "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod erc20 {\n    use ink::storage::Mapping;\n\n    /// A simple ERC-20 contract.\n    #[ink(storage)]\n    #[derive(Default)]\n    pub struct Erc20 {\n        /// Total token supply.\n        total_supply: Balance,\n        /// Mapping from owner to number of owned token.\n        balances: Mapping<AccountId, Balance>,\n        /// Mapping of the token amount which an account is allowed to withdraw\n        /// from another account.\n        allowances: Mapping<(AccountId, AccountId), Balance>,\n    }\n\n    /// Event emitted when a token transfer occurs.\n    #[ink(event)]\n    pub struct Transfer {\n        #[ink(topic)]\n        from: Option<AccountId>,\n        #[ink(topic)]\n        to: Option<AccountId>,\n        value: Balance,\n    }\n\n    /// Event emitted when an approval occurs that `spender` is allowed to withdraw\n    /// up to the amount of `value` tokens from `owner`.\n    #[ink(event)]\n    pub struct Approval {\n        #[ink(topic)]\n        owner: AccountId,\n        #[ink(topic)]\n        spender: AccountId,\n        value: Balance,\n    }\n\n    /// The ERC-20 error types.\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        /// Returned if not enough balance to fulfill a request is available.\n        InsufficientBalance,\n        /// Returned if not enough allowance to fulfill a request is available.\n        InsufficientAllowance,\n    }\n\n    /// The ERC-20 result type.\n    pub type Result<T> = core::result::Result<T, Error>;\n\n    impl Erc20 {\n        /// Creates a new ERC-20 contract with the specified initial supply.\n        #[ink(constructor)]\n        pub fn new(total_supply: Balance) -> Self {\n            let mut balances = Mapping::default();\n            let caller = Self::env().caller();\n            balances.insert(caller, &total_supply);\n            Self::env().emit_event(Transfer {\n                from: None,\n                to: Some(caller),\n                value: total_supply,\n            });\n            Self {\n                total_supply,\n                balances,\n                allowances: Default::default(),\n            }\n        }\n\n        /// Returns the total token supply.\n        #[ink(message)]\n        pub fn total_supply(&self) -> Balance {\n            self.total_supply\n        }\n\n        /// Returns the account balance for the specified `owner`.\n        ///\n        /// Returns `0` if the account is non-existent.\n        #[ink(message)]\n        pub fn balance_of(&self, owner: AccountId) -> Balance {\n            self.balance_of_impl(&owner)\n        }\n\n        /// Returns the account balance for the specified `owner`.\n        ///\n        /// Returns `0` if the account is non-existent.\n        ///\n        /// # Note\n        ///\n        /// Prefer to call this method over `balance_of` since this\n        /// works using references which are more efficient in Wasm.\n        #[inline]\n        fn balance_of_impl(&self, owner: &AccountId) -> Balance {\n            self.balances.get(owner).unwrap_or_default()\n        }\n\n        /// Returns the amount which `spender` is still allowed to withdraw from `owner`.\n        ///\n        /// Returns `0` if no allowance has been set.\n        #[ink(message)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> Balance {\n            self.allowance_impl(&owner, &spender)\n        }\n\n        /// Returns the amount which `spender` is still allowed to withdraw from `owner`.\n        ///\n        /// Returns `0` if no allowance has been set.\n        ///\n        /// # Note\n        ///\n        /// Prefer to call this method over `allowance` since this\n        /// works using references which are more efficient in Wasm.\n        #[inline]\n        fn allowance_impl(&self, owner: &AccountId, spender: &AccountId) -> Balance {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        /// Transfers `value` amount of tokens from the caller's account to account `to`.\n        ///\n        /// On success a `Transfer` event is emitted.\n        ///\n        /// # Errors\n        ///\n        /// Returns `InsufficientBalance` error if there are not enough tokens on\n        /// the caller's account balance.\n        #[ink(message)]\n        pub fn transfer(&mut self, to: AccountId, value: Balance) -> Result<()> {\n            let from = self.env().caller();\n            self.transfer_from_to(&from, &to, value)\n        }\n\n        /// Allows `spender` to withdraw from the caller's account multiple times, up to\n        /// the `value` amount.\n        ///\n        /// If this function is called again it overwrites the current allowance with\n        /// `value`.\n        ///\n        /// An `Approval` event is emitted.\n        #[ink(message)]\n        pub fn approve(&mut self, spender: AccountId, value: Balance) -> Result<()> {\n            let owner = self.env().caller();\n            self.allowances.insert((&owner, &spender), &value);\n            self.env().emit_event(Approval {\n                owner,\n                spender,\n                value,\n            });\n            Ok(())\n        }\n\n        /// Transfers `value` tokens on the behalf of `from` to the account `to`.\n        ///\n        /// This can be used to allow a contract to transfer tokens on ones behalf and/or\n        /// to charge fees in sub-currencies, for example.\n        ///\n        /// On success a `Transfer` event is emitted.\n        ///\n        /// # Errors\n        ///\n        /// Returns `InsufficientAllowance` error if there are not enough tokens allowed\n        /// for the caller to withdraw from `from`.\n        ///\n        /// Returns `InsufficientBalance` error if there are not enough tokens on\n        /// the account balance of `from`.\n        #[ink(message)]\n        pub fn transfer_from(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            value: Balance,\n        ) -> Result<()> {\n            let caller = self.env().caller();\n            let allowance = self.allowance_impl(&from, &caller);\n            if allowance < value {\n                return Err(Error::InsufficientAllowance)\n            }\n            self.transfer_from_to(&from, &to, value)?;\n            // We checked that allowance >= value\n            #[allow(clippy::arithmetic_side_effects)]\n            self.allowances\n                .insert((&from, &caller), &(allowance - value));\n            Ok(())\n        }\n\n        /// Transfers `value` amount of tokens from the caller's account to account `to`.\n        ///\n        /// On success a `Transfer` event is emitted.\n        ///\n        /// # Errors\n        ///\n        /// Returns `InsufficientBalance` error if there are not enough tokens on\n        /// the caller's account balance.\n        fn transfer_from_to(\n            &mut self,\n            from: &AccountId,\n            to: &AccountId,\n            value: Balance,\n        ) -> Result<()> {\n            let from_balance = self.balance_of_impl(from);\n            if from_balance < value {\n                return Err(Error::InsufficientBalance)\n            }\n            // We checked that from_balance >= value\n            #[allow(clippy::arithmetic_side_effects)]\n            self.balances.insert(from, &(from_balance - value));\n            let to_balance = self.balance_of_impl(to);\n            self.balances\n                .insert(to, &(to_balance.checked_add(value).unwrap()));\n            self.env().emit_event(Transfer {\n                from: Some(*from),\n                to: Some(*to),\n                value,\n            });\n            Ok(())\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        use ink::primitives::{\n            Clear,\n            Hash,\n        };\n\n        fn assert_transfer_event(\n            event: &ink::env::test::EmittedEvent,\n            expected_from: Option<AccountId>,\n            expected_to: Option<AccountId>,\n            expected_value: Balance,\n        ) {\n            let decoded_event =\n                <Transfer as ink::scale::Decode>::decode(&mut &event.data[..])\n                    .expect(\"encountered invalid contract event data buffer\");\n            let Transfer { from, to, value } = decoded_event;\n            assert_eq!(from, expected_from, \"encountered invalid Transfer.from\");\n            assert_eq!(to, expected_to, \"encountered invalid Transfer.to\");\n            assert_eq!(value, expected_value, \"encountered invalid Trasfer.value\");\n\n            let mut expected_topics = Vec::new();\n            expected_topics.push(\n                ink::blake2x256!(\"Transfer(Option<AccountId>,Option<AccountId>,Balance)\")\n                    .into(),\n            );\n            if let Some(from) = expected_from {\n                expected_topics.push(encoded_into_hash(from));\n            } else {\n                expected_topics.push(Hash::CLEAR_HASH);\n            }\n            if let Some(to) = expected_to {\n                expected_topics.push(encoded_into_hash(to));\n            } else {\n                expected_topics.push(Hash::CLEAR_HASH);\n            }\n            expected_topics.push(encoded_into_hash(value));\n\n            let topics = event.topics.clone();\n            for (n, (actual_topic, expected_topic)) in\n                topics.iter().zip(expected_topics).enumerate()\n            {\n                let mut topic_hash = Hash::CLEAR_HASH;\n                let len = actual_topic.len();\n                topic_hash.as_mut()[0..len].copy_from_slice(&actual_topic[0..len]);\n\n                assert_eq!(\n                    topic_hash, expected_topic,\n                    \"encountered invalid topic at {n}\"\n                );\n            }\n        }\n\n        /// The default constructor does its job.\n        #[ink::test]\n        fn new_works() {\n            // Constructor works.\n            let _erc20 = Erc20::new(100);\n\n            // Transfer event triggered during initial construction.\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(1, emitted_events.len());\n\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n        }\n\n        /// The total supply was applied.\n        #[ink::test]\n        fn total_supply_works() {\n            // Constructor works.\n            let erc20 = Erc20::new(100);\n            // Transfer event triggered during initial construction.\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n            // Get the token total supply.\n            assert_eq!(erc20.total_supply(), 100);\n        }\n\n        /// Get the actual balance of an account.\n        #[ink::test]\n        fn balance_of_works() {\n            // Constructor works\n            let erc20 = Erc20::new(100);\n            // Transfer event triggered during initial construction\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n            // Alice owns all the tokens on contract instantiation\n            assert_eq!(erc20.balance_of(accounts.alice), 100);\n            // Bob does not owns tokens\n            assert_eq!(erc20.balance_of(accounts.bob), 0);\n        }\n\n        #[ink::test]\n        fn transfer_works() {\n            // Constructor works.\n            let mut erc20 = Erc20::new(100);\n            // Transfer event triggered during initial construction.\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n\n            assert_eq!(erc20.balance_of(accounts.bob), 0);\n            // Alice transfers 10 tokens to Bob.\n            assert_eq!(erc20.transfer(accounts.bob, 10), Ok(()));\n            // Bob owns 10 tokens.\n            assert_eq!(erc20.balance_of(accounts.bob), 10);\n\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(emitted_events.len(), 2);\n            // Check first transfer event related to ERC-20 instantiation.\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n            // Check the second transfer event relating to the actual trasfer.\n            assert_transfer_event(\n                &emitted_events[1],\n                Some(AccountId::from([0x01; 32])),\n                Some(AccountId::from([0x02; 32])),\n                10,\n            );\n        }\n\n        #[ink::test]\n        fn invalid_transfer_should_fail() {\n            // Constructor works.\n            let mut erc20 = Erc20::new(100);\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n\n            assert_eq!(erc20.balance_of(accounts.bob), 0);\n\n            // Set the contract as callee and Bob as caller.\n            let contract = ink::env::account_id::<ink::env::DefaultEnvironment>();\n            ink::env::test::set_callee::<ink::env::DefaultEnvironment>(contract);\n            ink::env::test::set_caller::<ink::env::DefaultEnvironment>(accounts.bob);\n\n            // Bob fails to transfers 10 tokens to Eve.\n            assert_eq!(\n                erc20.transfer(accounts.eve, 10),\n                Err(Error::InsufficientBalance)\n            );\n            // Alice owns all the tokens.\n            assert_eq!(erc20.balance_of(accounts.alice), 100);\n            assert_eq!(erc20.balance_of(accounts.bob), 0);\n            assert_eq!(erc20.balance_of(accounts.eve), 0);\n\n            // Transfer event triggered during initial construction.\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(emitted_events.len(), 1);\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n        }\n\n        #[ink::test]\n        fn transfer_from_works() {\n            // Constructor works.\n            let mut erc20 = Erc20::new(100);\n            // Transfer event triggered during initial construction.\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n\n            // Bob fails to transfer tokens owned by Alice.\n            assert_eq!(\n                erc20.transfer_from(accounts.alice, accounts.eve, 10),\n                Err(Error::InsufficientAllowance)\n            );\n            // Alice approves Bob for token transfers on her behalf.\n            assert_eq!(erc20.approve(accounts.bob, 10), Ok(()));\n\n            // The approve event takes place.\n            assert_eq!(ink::env::test::recorded_events().count(), 2);\n\n            // Set the contract as callee and Bob as caller.\n            let contract = ink::env::account_id::<ink::env::DefaultEnvironment>();\n            ink::env::test::set_callee::<ink::env::DefaultEnvironment>(contract);\n            ink::env::test::set_caller::<ink::env::DefaultEnvironment>(accounts.bob);\n\n            // Bob transfers tokens from Alice to Eve.\n            assert_eq!(\n                erc20.transfer_from(accounts.alice, accounts.eve, 10),\n                Ok(())\n            );\n            // Eve owns tokens.\n            assert_eq!(erc20.balance_of(accounts.eve), 10);\n\n            // Check all transfer events that happened during the previous calls:\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(emitted_events.len(), 3);\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n            // The second event `emitted_events[1]` is an Approve event that we skip\n            // checking.\n            assert_transfer_event(\n                &emitted_events[2],\n                Some(AccountId::from([0x01; 32])),\n                Some(AccountId::from([0x05; 32])),\n                10,\n            );\n        }\n\n        #[ink::test]\n        fn allowance_must_not_change_on_failed_transfer() {\n            let mut erc20 = Erc20::new(100);\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n\n            // Alice approves Bob for token transfers on her behalf.\n            let alice_balance = erc20.balance_of(accounts.alice);\n            let initial_allowance = alice_balance + 2;\n            assert_eq!(erc20.approve(accounts.bob, initial_allowance), Ok(()));\n\n            // Get contract address.\n            let callee = ink::env::account_id::<ink::env::DefaultEnvironment>();\n            ink::env::test::set_callee::<ink::env::DefaultEnvironment>(callee);\n            ink::env::test::set_caller::<ink::env::DefaultEnvironment>(accounts.bob);\n\n            // Bob tries to transfer tokens from Alice to Eve.\n            let emitted_events_before = ink::env::test::recorded_events().count();\n            assert_eq!(\n                erc20.transfer_from(accounts.alice, accounts.eve, alice_balance + 1),\n                Err(Error::InsufficientBalance)\n            );\n            // Allowance must have stayed the same\n            assert_eq!(\n                erc20.allowance(accounts.alice, accounts.bob),\n                initial_allowance\n            );\n            // No more events must have been emitted\n            assert_eq!(\n                emitted_events_before,\n                ink::env::test::recorded_events().count()\n            )\n        }\n\n        fn encoded_into_hash<T>(entity: T) -> Hash\n        where\n            T: ink::scale::Encode,\n        {\n            use ink::{\n                env::hash::{\n                    Blake2x256,\n                    CryptoHash,\n                    HashOutput,\n                },\n                primitives::Clear,\n            };\n\n            let mut result = Hash::CLEAR_HASH;\n            let len_result = result.as_ref().len();\n            let encoded = entity.encode();\n            let len_encoded = encoded.len();\n            if len_encoded <= len_result {\n                result.as_mut()[..len_encoded].copy_from_slice(&encoded);\n                return result\n            }\n            let mut hash_output =\n                <<Blake2x256 as HashOutput>::Type as Default>::default();\n            <Blake2x256 as CryptoHash>::hash(&encoded, &mut hash_output);\n            let copy_len = core::cmp::min(hash_output.len(), len_result);\n            result.as_mut()[0..copy_len].copy_from_slice(&hash_output[0..copy_len]);\n            result\n        }\n    }\n\n    #[cfg(all(test, feature = \"e2e-tests\"))]\n    mod e2e_tests {\n        use super::*;\n        use ink_e2e::ContractsBackend;\n\n        type E2EResult<T> = std::result::Result<T, Box<dyn std::error::Error>>;\n\n        #[ink_e2e::test]\n        async fn e2e_transfer<Client: E2EBackend>(mut client: Client) -> E2EResult<()> {\n            // given\n            let total_supply = 1_000_000_000;\n            let mut constructor = Erc20Ref::new(total_supply);\n            let erc20 = client\n                .instantiate(\"erc20\", &ink_e2e::alice(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = erc20.call_builder::<Erc20>();\n\n            // when\n            let total_supply_msg = call_builder.total_supply();\n            let total_supply_res = client\n                .call(&ink_e2e::bob(), &total_supply_msg)\n                .dry_run()\n                .await?;\n\n            let bob_account = ink_e2e::account_id(ink_e2e::AccountKeyring::Bob);\n            let transfer_to_bob = 500_000_000u128;\n            let transfer = call_builder.transfer(bob_account, transfer_to_bob);\n            let _transfer_res = client\n                .call(&ink_e2e::alice(), &transfer)\n                .submit()\n                .await\n                .expect(\"transfer failed\");\n\n            let balance_of = call_builder.balance_of(bob_account);\n            let balance_of_res = client\n                .call(&ink_e2e::alice(), &balance_of)\n                .dry_run()\n                .await?;\n\n            // then\n            assert_eq!(\n                total_supply,\n                total_supply_res.return_value(),\n                \"total_supply\"\n            );\n            assert_eq!(transfer_to_bob, balance_of_res.return_value(), \"balance_of\");\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn e2e_allowances<Client: E2EBackend>(mut client: Client) -> E2EResult<()> {\n            // given\n            let total_supply = 1_000_000_000;\n            let mut constructor = Erc20Ref::new(total_supply);\n            let erc20 = client\n                .instantiate(\"erc20\", &ink_e2e::bob(), &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = erc20.call_builder::<Erc20>();\n\n            // when\n\n            let bob_account = ink_e2e::account_id(ink_e2e::AccountKeyring::Bob);\n            let charlie_account = ink_e2e::account_id(ink_e2e::AccountKeyring::Charlie);\n\n            let amount = 500_000_000u128;\n            // tx\n            let transfer_from =\n                call_builder.transfer_from(bob_account, charlie_account, amount);\n            let transfer_from_result = client\n                .call(&ink_e2e::charlie(), &transfer_from)\n                .submit()\n                .await;\n\n            assert!(\n                transfer_from_result.is_err(),\n                \"unapproved transfer_from should fail\"\n            );\n\n            // Bob approves Charlie to transfer up to amount on his behalf\n            let approved_value = 1_000u128;\n            let approve_call = call_builder.approve(charlie_account, approved_value);\n            client\n                .call(&ink_e2e::bob(), &approve_call)\n                .submit()\n                .await\n                .expect(\"approve failed\");\n\n            // `transfer_from` the approved amount\n            let transfer_from =\n                call_builder.transfer_from(bob_account, charlie_account, approved_value);\n            let transfer_from_result = client\n                .call(&ink_e2e::charlie(), &transfer_from)\n                .submit()\n                .await;\n            assert!(\n                transfer_from_result.is_ok(),\n                \"approved transfer_from should succeed\"\n            );\n\n            let balance_of = call_builder.balance_of(bob_account);\n            let balance_of_res = client\n                .call(&ink_e2e::alice(), &balance_of)\n                .dry_run()\n                .await?;\n\n            // `transfer_from` again, this time exceeding the approved amount\n            let transfer_from =\n                call_builder.transfer_from(bob_account, charlie_account, 1);\n            let transfer_from_result = client\n                .call(&ink_e2e::charlie(), &transfer_from)\n                .submit()\n                .await;\n            assert!(\n                transfer_from_result.is_err(),\n                \"transfer_from exceeding the approved amount should fail\"\n            );\n\n            assert_eq!(\n                total_supply - approved_value,\n                balance_of_res.return_value(),\n                \"balance_of\"\n            );\n\n            Ok(())\n        }\n    }\n}\n"
      },
      {
        "name": "erc721",
        "code": "//! # ERC-721\n//!\n//! This is an ERC-721 Token implementation.\n//!\n//! ## Warning\n//!\n//! This contract is an *example*. It is neither audited nor endorsed for production use.\n//! Do **not** rely on it to keep anything of value secure.\n//!\n//! ## Overview\n//!\n//! This contract demonstrates how to build non-fungible or unique tokens using ink!.\n//!\n//! ## Error Handling\n//!\n//! Any function that modifies the state returns a `Result` type and does not changes the\n//! state if the `Error` occurs.\n//! The errors are defined as an `enum` type. Any other error or invariant violation\n//! triggers a panic and therefore rolls back the transaction.\n//!\n//! ## Token Management\n//!\n//! After creating a new token, the function caller becomes the owner.\n//! A token can be created, transferred, or destroyed.\n//!\n//! Token owners can assign other accounts for transferring specific tokens on their\n//! behalf. It is also possible to authorize an operator (higher rights) for another\n//! account to handle tokens.\n//!\n//! ### Token Creation\n//!\n//! Token creation start by calling the `mint(&mut self, id: u32)` function.\n//! The token owner becomes the function caller. The Token ID needs to be specified\n//! as the argument on this function call.\n//!\n//! ### Token Transfer\n//!\n//! Transfers may be initiated by:\n//! - The owner of a token\n//! - The approved address of a token\n//! - An authorized operator of the current owner of a token\n//!\n//! The token owner can transfer a token by calling the `transfer` or `transfer_from`\n//! functions. An approved address can make a token transfer by calling the\n//! `transfer_from` function. Operators can transfer tokens on another account's behalf or\n//! can approve a token transfer for a different account.\n//!\n//! ### Token Removal\n//!\n//! Tokens can be destroyed by burning them. Only the token owner is allowed to burn a\n//! token.\n\n#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod erc721 {\n    use ink::storage::Mapping;\n\n    /// A token ID.\n    pub type TokenId = u32;\n\n    #[ink(storage)]\n    #[derive(Default)]\n    pub struct Erc721 {\n        /// Mapping from token to owner.\n        token_owner: Mapping<TokenId, AccountId>,\n        /// Mapping from token to approvals users.\n        token_approvals: Mapping<TokenId, AccountId>,\n        /// Mapping from owner to number of owned token.\n        owned_tokens_count: Mapping<AccountId, u32>,\n        /// Mapping from owner to operator approvals.\n        operator_approvals: Mapping<(AccountId, AccountId), ()>,\n    }\n\n    #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        NotOwner,\n        NotApproved,\n        TokenExists,\n        TokenNotFound,\n        CannotInsert,\n        CannotFetchValue,\n        NotAllowed,\n    }\n\n    /// Event emitted when a token transfer occurs.\n    #[ink(event)]\n    pub struct Transfer {\n        #[ink(topic)]\n        from: Option<AccountId>,\n        #[ink(topic)]\n        to: Option<AccountId>,\n        #[ink(topic)]\n        id: TokenId,\n    }\n\n    /// Event emitted when a token approve occurs.\n    #[ink(event)]\n    pub struct Approval {\n        #[ink(topic)]\n        from: AccountId,\n        #[ink(topic)]\n        to: AccountId,\n        #[ink(topic)]\n        id: TokenId,\n    }\n\n    /// Event emitted when an operator is enabled or disabled for an owner.\n    /// The operator can manage all NFTs of the owner.\n    #[ink(event)]\n    pub struct ApprovalForAll {\n        #[ink(topic)]\n        owner: AccountId,\n        #[ink(topic)]\n        operator: AccountId,\n        approved: bool,\n    }\n\n    impl Erc721 {\n        /// Creates a new ERC-721 token contract.\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Default::default()\n        }\n\n        /// Returns the balance of the owner.\n        ///\n        /// This represents the amount of unique tokens the owner has.\n        #[ink(message)]\n        pub fn balance_of(&self, owner: AccountId) -> u32 {\n            self.balance_of_or_zero(&owner)\n        }\n\n        /// Returns the owner of the token.\n        #[ink(message)]\n        pub fn owner_of(&self, id: TokenId) -> Option<AccountId> {\n            self.token_owner.get(id)\n        }\n\n        /// Returns the approved account ID for this token if any.\n        #[ink(message)]\n        pub fn get_approved(&self, id: TokenId) -> Option<AccountId> {\n            self.token_approvals.get(id)\n        }\n\n        /// Returns `true` if the operator is approved by the owner.\n        #[ink(message)]\n        pub fn is_approved_for_all(&self, owner: AccountId, operator: AccountId) -> bool {\n            self.approved_for_all(owner, operator)\n        }\n\n        /// Approves or disapproves the operator for all tokens of the caller.\n        #[ink(message)]\n        pub fn set_approval_for_all(\n            &mut self,\n            to: AccountId,\n            approved: bool,\n        ) -> Result<(), Error> {\n            self.approve_for_all(to, approved)?;\n            Ok(())\n        }\n\n        /// Approves the account to transfer the specified token on behalf of the caller.\n        #[ink(message)]\n        pub fn approve(&mut self, to: AccountId, id: TokenId) -> Result<(), Error> {\n            self.approve_for(&to, id)?;\n            Ok(())\n        }\n\n        /// Transfers the token from the caller to the given destination.\n        #[ink(message)]\n        pub fn transfer(\n            &mut self,\n            destination: AccountId,\n            id: TokenId,\n        ) -> Result<(), Error> {\n            let caller = self.env().caller();\n            self.transfer_token_from(&caller, &destination, id)?;\n            Ok(())\n        }\n\n        /// Transfer approved or owned token.\n        #[ink(message)]\n        pub fn transfer_from(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            id: TokenId,\n        ) -> Result<(), Error> {\n            self.transfer_token_from(&from, &to, id)?;\n            Ok(())\n        }\n\n        /// Creates a new token.\n        #[ink(message)]\n        pub fn mint(&mut self, id: TokenId) -> Result<(), Error> {\n            let caller = self.env().caller();\n            self.add_token_to(&caller, id)?;\n            self.env().emit_event(Transfer {\n                from: Some(AccountId::from([0x0; 32])),\n                to: Some(caller),\n                id,\n            });\n            Ok(())\n        }\n\n        /// Deletes an existing token. Only the owner can burn the token.\n        #[ink(message)]\n        pub fn burn(&mut self, id: TokenId) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let Self {\n                token_owner,\n                owned_tokens_count,\n                ..\n            } = self;\n\n            let owner = token_owner.get(id).ok_or(Error::TokenNotFound)?;\n            if owner != caller {\n                return Err(Error::NotOwner);\n            };\n\n            let count = owned_tokens_count\n                .get(caller)\n                .map(|c| c.checked_sub(1).unwrap())\n                .ok_or(Error::CannotFetchValue)?;\n            owned_tokens_count.insert(caller, &count);\n            token_owner.remove(id);\n            self.clear_approval(id);\n\n            self.env().emit_event(Transfer {\n                from: Some(caller),\n                to: Some(AccountId::from([0x0; 32])),\n                id,\n            });\n\n            Ok(())\n        }\n\n        /// Transfers token `id` `from` the sender to the `to` `AccountId`.\n        fn transfer_token_from(\n            &mut self,\n            from: &AccountId,\n            to: &AccountId,\n            id: TokenId,\n        ) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let owner = self.owner_of(id).ok_or(Error::TokenNotFound)?;\n            if !self.approved_or_owner(caller, id, owner) {\n                return Err(Error::NotApproved);\n            };\n            if owner != *from {\n                return Err(Error::NotOwner);\n            };\n            self.clear_approval(id);\n            self.remove_token_from(from, id)?;\n            self.add_token_to(to, id)?;\n            self.env().emit_event(Transfer {\n                from: Some(*from),\n                to: Some(*to),\n                id,\n            });\n            Ok(())\n        }\n\n        /// Removes token `id` from the owner.\n        fn remove_token_from(\n            &mut self,\n            from: &AccountId,\n            id: TokenId,\n        ) -> Result<(), Error> {\n            let Self {\n                token_owner,\n                owned_tokens_count,\n                ..\n            } = self;\n\n            if !token_owner.contains(id) {\n                return Err(Error::TokenNotFound);\n            }\n\n            let count = owned_tokens_count\n                .get(from)\n                .map(|c| c.checked_sub(1).unwrap())\n                .ok_or(Error::CannotFetchValue)?;\n            owned_tokens_count.insert(from, &count);\n            token_owner.remove(id);\n\n            Ok(())\n        }\n\n        /// Adds the token `id` to the `to` AccountID.\n        fn add_token_to(&mut self, to: &AccountId, id: TokenId) -> Result<(), Error> {\n            let Self {\n                token_owner,\n                owned_tokens_count,\n                ..\n            } = self;\n\n            if token_owner.contains(id) {\n                return Err(Error::TokenExists);\n            }\n\n            if *to == AccountId::from([0x0; 32]) {\n                return Err(Error::NotAllowed);\n            };\n\n            let count = owned_tokens_count\n                .get(to)\n                .map(|c| c.checked_add(1).unwrap())\n                .unwrap_or(1);\n\n            owned_tokens_count.insert(to, &count);\n            token_owner.insert(id, to);\n\n            Ok(())\n        }\n\n        /// Approves or disapproves the operator to transfer all tokens of the caller.\n        fn approve_for_all(\n            &mut self,\n            to: AccountId,\n            approved: bool,\n        ) -> Result<(), Error> {\n            let caller = self.env().caller();\n            if to == caller {\n                return Err(Error::NotAllowed);\n            }\n            self.env().emit_event(ApprovalForAll {\n                owner: caller,\n                operator: to,\n                approved,\n            });\n\n            if approved {\n                self.operator_approvals.insert((&caller, &to), &());\n            } else {\n                self.operator_approvals.remove((&caller, &to));\n            }\n\n            Ok(())\n        }\n\n        /// Approve the passed `AccountId` to transfer the specified token on behalf of\n        /// the message's sender.\n        fn approve_for(&mut self, to: &AccountId, id: TokenId) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let owner = self.owner_of(id).ok_or(Error::TokenNotFound)?;\n            if !(owner == caller || self.approved_for_all(owner, caller)) {\n                return Err(Error::NotAllowed);\n            };\n\n            if *to == AccountId::from([0x0; 32]) {\n                return Err(Error::NotAllowed);\n            };\n\n            if self.token_approvals.contains(id) {\n                return Err(Error::CannotInsert);\n            } else {\n                self.token_approvals.insert(id, to);\n            }\n\n            self.env().emit_event(Approval {\n                from: caller,\n                to: *to,\n                id,\n            });\n\n            Ok(())\n        }\n\n        /// Removes existing approval from token `id`.\n        fn clear_approval(&mut self, id: TokenId) {\n            self.token_approvals.remove(id);\n        }\n\n        // Returns the total number of tokens from an account.\n        fn balance_of_or_zero(&self, of: &AccountId) -> u32 {\n            self.owned_tokens_count.get(of).unwrap_or(0)\n        }\n\n        /// Gets an operator on other Account's behalf.\n        fn approved_for_all(&self, owner: AccountId, operator: AccountId) -> bool {\n            self.operator_approvals.contains((&owner, &operator))\n        }\n\n        /// Returns true if the `AccountId` `from` is the owner of token `id`\n        /// or it has been approved on behalf of the token `id` owner.\n        fn approved_or_owner(\n            &self,\n            from: AccountId,\n            id: TokenId,\n            owner: AccountId,\n        ) -> bool {\n            from != AccountId::from([0x0; 32])\n                && (from == owner\n                    || self.token_approvals.get(id) == Some(from)\n                    || self.approved_for_all(owner, from))\n        }\n    }\n\n    /// Unit tests\n    #[cfg(test)]\n    mod tests {\n        /// Imports all the definitions from the outer scope so we can use them here.\n        use super::*;\n\n        #[ink::test]\n        fn mint_works() {\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n            // Create a new contract instance.\n            let mut erc721 = Erc721::new();\n            // Token 1 does not exists.\n            assert_eq!(erc721.owner_of(1), None);\n            // Alice does not owns tokens.\n            assert_eq!(erc721.balance_of(accounts.alice), 0);\n            // Create token Id 1.\n            assert_eq!(erc721.mint(1), Ok(()));\n            // Alice owns 1 token.\n            assert_eq!(erc721.balance_of(accounts.alice), 1);\n        }\n\n        #[ink::test]\n        fn mint_existing_should_fail() {\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n            // Create a new contract instance.\n            let mut erc721 = Erc721::new();\n            // Create token Id 1.\n            assert_eq!(erc721.mint(1), Ok(()));\n            // The first Transfer event takes place\n            assert_eq!(1, ink::env::test::recorded_events().count());\n            // Alice owns 1 token.\n            assert_eq!(erc721.balance_of(accounts.alice), 1);\n            // Alice owns token Id 1.\n            assert_eq!(erc721.owner_of(1), Some(accounts.alice));\n            // Cannot create  token Id if it exists.\n            // Bob cannot own token Id 1.\n            assert_eq!(erc721.mint(1), Err(Error::TokenExists));\n        }\n\n        #[ink::test]\n        fn transfer_works() {\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n            // Create a new contract instance.\n            let mut erc721 = Erc721::new();\n            // Create token Id 1 for Alice\n            assert_eq!(erc721.mint(1), Ok(()));\n            // Alice owns token 1\n            assert_eq!(erc721.balance_of(accounts.alice), 1);\n            // Bob does not owns any token\n            assert_eq!(erc721.balance_of(accounts.bob), 0);\n            // The first Transfer event takes place\n            assert_eq!(1, ink::env::test::recorded_events().count());\n            // Alice transfers token 1 to Bob\n            assert_eq!(erc721.transfer(accounts.bob, 1), Ok(()));\n            // The second Transfer event takes place\n            assert_eq!(2, ink::env::test::recorded_events().count());\n            // Bob owns token 1\n            assert_eq!(erc721.balance_of(accounts.bob), 1);\n        }\n\n        #[ink::test]\n        fn invalid_transfer_should_fail() {\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n            // Create a new contract instance.\n            let mut erc721 = Erc721::new();\n            // Transfer token fails if it does not exists.\n            assert_eq!(erc721.transfer(accounts.bob, 2), Err(Error::TokenNotFound));\n            // Token Id 2 does not exists.\n            assert_eq!(erc721.owner_of(2), None);\n            // Create token Id 2.\n            assert_eq!(erc721.mint(2), Ok(()));\n            // Alice owns 1 token.\n            assert_eq!(erc721.balance_of(accounts.alice), 1);\n            // Token Id 2 is owned by Alice.\n            assert_eq!(erc721.owner_of(2), Some(accounts.alice));\n            // Set Bob as caller\n            set_caller(accounts.bob);\n            // Bob cannot transfer not owned tokens.\n            assert_eq!(erc721.transfer(accounts.eve, 2), Err(Error::NotApproved));\n        }\n\n        #[ink::test]\n        fn approved_transfer_works() {\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n            // Create a new contract instance.\n            let mut erc721 = Erc721::new();\n            // Create token Id 1.\n            assert_eq!(erc721.mint(1), Ok(()));\n            // Token Id 1 is owned by Alice.\n            assert_eq!(erc721.owner_of(1), Some(accounts.alice));\n            // Approve token Id 1 transfer for Bob on behalf of Alice.\n            assert_eq!(erc721.approve(accounts.bob, 1), Ok(()));\n            // Set Bob as caller\n            set_caller(accounts.bob);\n            // Bob transfers token Id 1 from Alice to Eve.\n            assert_eq!(\n                erc721.transfer_from(accounts.alice, accounts.eve, 1),\n                Ok(())\n            );\n            // TokenId 3 is owned by Eve.\n            assert_eq!(erc721.owner_of(1), Some(accounts.eve));\n            // Alice does not owns tokens.\n            assert_eq!(erc721.balance_of(accounts.alice), 0);\n            // Bob does not owns tokens.\n            assert_eq!(erc721.balance_of(accounts.bob), 0);\n            // Eve owns 1 token.\n            assert_eq!(erc721.balance_of(accounts.eve), 1);\n        }\n\n        #[ink::test]\n        fn approved_for_all_works() {\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n            // Create a new contract instance.\n            let mut erc721 = Erc721::new();\n            // Create token Id 1.\n            assert_eq!(erc721.mint(1), Ok(()));\n            // Create token Id 2.\n            assert_eq!(erc721.mint(2), Ok(()));\n            // Alice owns 2 tokens.\n            assert_eq!(erc721.balance_of(accounts.alice), 2);\n            // Approve token Id 1 transfer for Bob on behalf of Alice.\n            assert_eq!(erc721.set_approval_for_all(accounts.bob, true), Ok(()));\n            // Bob is an approved operator for Alice\n            assert!(erc721.is_approved_for_all(accounts.alice, accounts.bob));\n            // Set Bob as caller\n            set_caller(accounts.bob);\n            // Bob transfers token Id 1 from Alice to Eve.\n            assert_eq!(\n                erc721.transfer_from(accounts.alice, accounts.eve, 1),\n                Ok(())\n            );\n            // TokenId 1 is owned by Eve.\n            assert_eq!(erc721.owner_of(1), Some(accounts.eve));\n            // Alice owns 1 token.\n            assert_eq!(erc721.balance_of(accounts.alice), 1);\n            // Bob transfers token Id 2 from Alice to Eve.\n            assert_eq!(\n                erc721.transfer_from(accounts.alice, accounts.eve, 2),\n                Ok(())\n            );\n            // Bob does not own tokens.\n            assert_eq!(erc721.balance_of(accounts.bob), 0);\n            // Eve owns 2 tokens.\n            assert_eq!(erc721.balance_of(accounts.eve), 2);\n            // Remove operator approval for Bob on behalf of Alice.\n            set_caller(accounts.alice);\n            assert_eq!(erc721.set_approval_for_all(accounts.bob, false), Ok(()));\n            // Bob is not an approved operator for Alice.\n            assert!(!erc721.is_approved_for_all(accounts.alice, accounts.bob));\n        }\n\n        #[ink::test]\n        fn approve_nonexistent_token_should_fail() {\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n            // Create a new contract instance.\n            let mut erc721 = Erc721::new();\n            // Approve transfer of nonexistent token id 1\n            assert_eq!(erc721.approve(accounts.bob, 1), Err(Error::TokenNotFound));\n        }\n\n        #[ink::test]\n        fn not_approved_transfer_should_fail() {\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n            // Create a new contract instance.\n            let mut erc721 = Erc721::new();\n            // Create token Id 1.\n            assert_eq!(erc721.mint(1), Ok(()));\n            // Alice owns 1 token.\n            assert_eq!(erc721.balance_of(accounts.alice), 1);\n            // Bob does not owns tokens.\n            assert_eq!(erc721.balance_of(accounts.bob), 0);\n            // Eve does not owns tokens.\n            assert_eq!(erc721.balance_of(accounts.eve), 0);\n            // Set Eve as caller\n            set_caller(accounts.eve);\n            // Eve is not an approved operator by Alice.\n            assert_eq!(\n                erc721.transfer_from(accounts.alice, accounts.frank, 1),\n                Err(Error::NotApproved)\n            );\n            // Alice owns 1 token.\n            assert_eq!(erc721.balance_of(accounts.alice), 1);\n            // Bob does not owns tokens.\n            assert_eq!(erc721.balance_of(accounts.bob), 0);\n            // Eve does not owns tokens.\n            assert_eq!(erc721.balance_of(accounts.eve), 0);\n        }\n\n        #[ink::test]\n        fn burn_works() {\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n            // Create a new contract instance.\n            let mut erc721 = Erc721::new();\n            // Create token Id 1 for Alice\n            assert_eq!(erc721.mint(1), Ok(()));\n            // Alice owns 1 token.\n            assert_eq!(erc721.balance_of(accounts.alice), 1);\n            // Alice owns token Id 1.\n            assert_eq!(erc721.owner_of(1), Some(accounts.alice));\n            // Destroy token Id 1.\n            assert_eq!(erc721.burn(1), Ok(()));\n            // Alice does not owns tokens.\n            assert_eq!(erc721.balance_of(accounts.alice), 0);\n            // Token Id 1 does not exists\n            assert_eq!(erc721.owner_of(1), None);\n        }\n\n        #[ink::test]\n        fn burn_fails_token_not_found() {\n            // Create a new contract instance.\n            let mut erc721 = Erc721::new();\n            // Try burning a non existent token\n            assert_eq!(erc721.burn(1), Err(Error::TokenNotFound));\n        }\n\n        #[ink::test]\n        fn burn_fails_not_owner() {\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n            // Create a new contract instance.\n            let mut erc721 = Erc721::new();\n            // Create token Id 1 for Alice\n            assert_eq!(erc721.mint(1), Ok(()));\n            // Try burning this token with a different account\n            set_caller(accounts.eve);\n            assert_eq!(erc721.burn(1), Err(Error::NotOwner));\n        }\n\n        #[ink::test]\n        fn burn_clears_approval() {\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n            // Create a new contract instance.\n            let mut erc721 = Erc721::new();\n            // Create token Id 1 for Alice\n            assert_eq!(erc721.mint(1), Ok(()));\n            // Alice gives approval to Bob to transfer token Id 1\n            assert_eq!(erc721.approve(accounts.bob, 1), Ok(()));\n            // Alice burns token\n            assert_eq!(erc721.burn(1), Ok(()));\n            // Set caller to Frank\n            set_caller(accounts.frank);\n            // Frank mints token Id 1\n            assert_eq!(erc721.mint(1), Ok(()));\n            // Set caller to Bob\n            set_caller(accounts.bob);\n            // Bob tries to transfer token Id 1 from Frank to himself\n            assert_eq!(\n                erc721.transfer_from(accounts.frank, accounts.bob, 1),\n                Err(Error::NotApproved)\n            );\n        }\n\n        #[ink::test]\n        fn transfer_from_fails_not_owner() {\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n            // Create a new contract instance.\n            let mut erc721 = Erc721::new();\n            // Create token Id 1 for Alice\n            assert_eq!(erc721.mint(1), Ok(()));\n            // Bob can transfer alice's tokens\n            assert_eq!(erc721.set_approval_for_all(accounts.bob, true), Ok(()));\n            // Set caller to Frank\n            set_caller(accounts.frank);\n            // Create token Id 2 for Frank\n            assert_eq!(erc721.mint(2), Ok(()));\n            // Set caller to Bob\n            set_caller(accounts.bob);\n            // Bob makes invalid call to transfer_from (Alice is token owner, not Frank)\n            assert_eq!(\n                erc721.transfer_from(accounts.frank, accounts.bob, 1),\n                Err(Error::NotOwner)\n            );\n        }\n\n        #[ink::test]\n        fn transfer_fails_not_owner() {\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n            // Create a new contract instance.\n            let mut erc721 = Erc721::new();\n            // Create token Id 1 for Alice\n            assert_eq!(erc721.mint(1), Ok(()));\n            // Bob can transfer alice's tokens\n            assert_eq!(erc721.set_approval_for_all(accounts.bob, true), Ok(()));\n            // Set caller to bob\n            set_caller(accounts.bob);\n            // Bob makes invalid call to transfer (he is not token owner, Alice is)\n            assert_eq!(erc721.transfer(accounts.bob, 1), Err(Error::NotOwner));\n        }\n\n        fn set_caller(sender: AccountId) {\n            ink::env::test::set_caller::<ink::env::DefaultEnvironment>(sender);\n        }\n    }\n}\n"
      },
      {
        "name": "erc1155",
        "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\nuse ink::{\n    prelude::vec::Vec,\n    primitives::AccountId,\n};\n\n// This is the return value that we expect if a smart contract supports receiving ERC-1155\n// tokens.\n//\n// It is calculated with\n// `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`, and\n// corresponds to 0xf23a6e61.\n#[cfg_attr(test, allow(dead_code))]\nconst ON_ERC_1155_RECEIVED_SELECTOR: [u8; 4] = [0xF2, 0x3A, 0x6E, 0x61];\n\n// This is the return value that we expect if a smart contract supports batch receiving\n// ERC-1155 tokens.\n//\n// It is calculated with\n// `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"\n// ))`, and corresponds to 0xbc197c81.\nconst _ON_ERC_1155_BATCH_RECEIVED_SELECTOR: [u8; 4] = [0xBC, 0x19, 0x7C, 0x81];\n\n/// A type representing the unique IDs of tokens managed by this contract.\npub type TokenId = u128;\n\ntype Balance = <ink::env::DefaultEnvironment as ink::env::Environment>::Balance;\n\n// The ERC-1155 error types.\n#[derive(Debug, PartialEq, Eq)]\n#[ink::scale_derive(Encode, Decode, TypeInfo)]\npub enum Error {\n    /// This token ID has not yet been created by the contract.\n    UnexistentToken,\n    /// The caller tried to sending tokens to the zero-address (`0x00`).\n    ZeroAddressTransfer,\n    /// The caller is not approved to transfer tokens on behalf of the account.\n    NotApproved,\n    /// The account does not have enough funds to complete the transfer.\n    InsufficientBalance,\n    /// An account does not need to approve themselves to transfer tokens.\n    SelfApproval,\n    /// The number of tokens being transferred does not match the specified number of\n    /// transfers.\n    BatchTransferMismatch,\n}\n\n// The ERC-1155 result types.\npub type Result<T> = core::result::Result<T, Error>;\n\n/// Evaluate `$x:expr` and if not true return `Err($y:expr)`.\n///\n/// Used as `ensure!(expression_to_ensure, expression_to_return_on_false)`.\nmacro_rules! ensure {\n    ( $condition:expr, $error:expr $(,)? ) => {{\n        if !$condition {\n            return ::core::result::Result::Err(::core::convert::Into::into($error))\n        }\n    }};\n}\n\n/// The interface for an ERC-1155 compliant contract.\n///\n/// The interface is defined here: <https://eips.ethereum.org/EIPS/eip-1155>.\n///\n/// The goal of ERC-1155 is to allow a single contract to manage a variety of assets.\n/// These assets can be fungible, non-fungible, or a combination.\n///\n/// By tracking multiple assets the ERC-1155 standard is able to support batch transfers,\n/// which make it easy to transfer a mix of multiple tokens at once.\n#[ink::trait_definition]\npub trait Erc1155 {\n    /// Transfer a `value` amount of `token_id` tokens to the `to` account from the `from`\n    /// account.\n    ///\n    /// Note that the call does not have to originate from the `from` account, and may\n    /// originate from any account which is approved to transfer `from`'s tokens.\n    #[ink(message)]\n    fn safe_transfer_from(\n        &mut self,\n        from: AccountId,\n        to: AccountId,\n        token_id: TokenId,\n        value: Balance,\n        data: Vec<u8>,\n    ) -> Result<()>;\n\n    /// Perform a batch transfer of `token_ids` to the `to` account from the `from`\n    /// account.\n    ///\n    /// The number of `values` specified to be transferred must match the number of\n    /// `token_ids`, otherwise this call will revert.\n    ///\n    /// Note that the call does not have to originate from the `from` account, and may\n    /// originate from any account which is approved to transfer `from`'s tokens.\n    #[ink(message)]\n    fn safe_batch_transfer_from(\n        &mut self,\n        from: AccountId,\n        to: AccountId,\n        token_ids: Vec<TokenId>,\n        values: Vec<Balance>,\n        data: Vec<u8>,\n    ) -> Result<()>;\n\n    /// Query the balance of a specific token for the provided account.\n    #[ink(message)]\n    fn balance_of(&self, owner: AccountId, token_id: TokenId) -> Balance;\n\n    /// Query the balances for a set of tokens for a set of accounts.\n    ///\n    /// E.g use this call if you want to query what Alice and Bob's balances are for\n    /// Tokens ID 1 and ID 2.\n    ///\n    /// This will return all the balances for a given owner before moving on to the next\n    /// owner. In the example above this means that the return value should look like:\n    ///\n    /// [Alice Balance of Token ID 1, Alice Balance of Token ID 2, Bob Balance of Token ID\n    /// 1, Bob Balance of Token ID 2]\n    #[ink(message)]\n    fn balance_of_batch(\n        &self,\n        owners: Vec<AccountId>,\n        token_ids: Vec<TokenId>,\n    ) -> Vec<Balance>;\n\n    /// Enable or disable a third party, known as an `operator`, to control all tokens on\n    /// behalf of the caller.\n    #[ink(message)]\n    fn set_approval_for_all(&mut self, operator: AccountId, approved: bool)\n        -> Result<()>;\n\n    /// Query if the given `operator` is allowed to control all of `owner`'s tokens.\n    #[ink(message)]\n    fn is_approved_for_all(&self, owner: AccountId, operator: AccountId) -> bool;\n}\n\n/// The interface for an ERC-1155 Token Receiver contract.\n///\n/// The interface is defined here: <https://eips.ethereum.org/EIPS/eip-1155>.\n///\n/// Smart contracts which want to accept token transfers must implement this interface. By\n/// default if a contract does not support this interface any transactions originating\n/// from an ERC-1155 compliant contract which attempt to transfer tokens directly to the\n/// contract's address must be reverted.\n#[ink::trait_definition]\npub trait Erc1155TokenReceiver {\n    /// Handle the receipt of a single ERC-1155 token.\n    ///\n    /// This should be called by a compliant ERC-1155 contract if the intended recipient\n    /// is a smart contract.\n    ///\n    /// If the smart contract implementing this interface accepts token transfers then it\n    /// must return `ON_ERC_1155_RECEIVED_SELECTOR` from this function. To reject a\n    /// transfer it must revert.\n    ///\n    /// Any callers must revert if they receive anything other than\n    /// `ON_ERC_1155_RECEIVED_SELECTOR` as a return value.\n    #[ink(message, selector = 0xF23A6E61)]\n    fn on_received(\n        &mut self,\n        operator: AccountId,\n        from: AccountId,\n        token_id: TokenId,\n        value: Balance,\n        data: Vec<u8>,\n    ) -> Vec<u8>;\n\n    /// Handle the receipt of multiple ERC-1155 tokens.\n    ///\n    /// This should be called by a compliant ERC-1155 contract if the intended recipient\n    /// is a smart contract.\n    ///\n    /// If the smart contract implementing this interface accepts token transfers then it\n    /// must return `BATCH_ON_ERC_1155_RECEIVED_SELECTOR` from this function. To\n    /// reject a transfer it must revert.\n    ///\n    /// Any callers must revert if they receive anything other than\n    /// `BATCH_ON_ERC_1155_RECEIVED_SELECTOR` as a return value.\n    #[ink(message, selector = 0xBC197C81)]\n    fn on_batch_received(\n        &mut self,\n        operator: AccountId,\n        from: AccountId,\n        token_ids: Vec<TokenId>,\n        values: Vec<Balance>,\n        data: Vec<u8>,\n    ) -> Vec<u8>;\n}\n\n#[ink::contract]\nmod erc1155 {\n    use super::*;\n\n    use ink::storage::Mapping;\n\n    type Owner = AccountId;\n    type Operator = AccountId;\n\n    /// Indicate that a token transfer has occured.\n    ///\n    /// This must be emitted even if a zero value transfer occurs.\n    #[ink(event)]\n    pub struct TransferSingle {\n        #[ink(topic)]\n        operator: Option<AccountId>,\n        #[ink(topic)]\n        from: Option<AccountId>,\n        #[ink(topic)]\n        to: Option<AccountId>,\n        token_id: TokenId,\n        value: Balance,\n    }\n\n    /// Indicate that an approval event has happened.\n    #[ink(event)]\n    pub struct ApprovalForAll {\n        #[ink(topic)]\n        owner: AccountId,\n        #[ink(topic)]\n        operator: AccountId,\n        approved: bool,\n    }\n\n    /// Indicate that a token's URI has been updated.\n    #[ink(event)]\n    pub struct Uri {\n        value: ink::prelude::string::String,\n        #[ink(topic)]\n        token_id: TokenId,\n    }\n\n    /// An ERC-1155 contract.\n    #[ink(storage)]\n    #[derive(Default)]\n    pub struct Contract {\n        /// Tracks the balances of accounts across the different tokens that they might\n        /// be holding.\n        balances: Mapping<(AccountId, TokenId), Balance>,\n        /// Which accounts (called operators) have been approved to spend funds on behalf\n        /// of an owner.\n        approvals: Mapping<(Owner, Operator), ()>,\n        /// A unique identifier for the tokens which have been minted (and are therefore\n        /// supported) by this contract.\n        token_id_nonce: TokenId,\n    }\n\n    impl Contract {\n        /// Initialize a default instance of this ERC-1155 implementation.\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Default::default()\n        }\n\n        /// Create the initial supply for a token.\n        ///\n        /// The initial supply will be provided to the caller (a.k.a the minter), and the\n        /// `token_id` will be assigned by the smart contract.\n        ///\n        /// Note that as implemented anyone can create tokens. If you were to instantiate\n        /// this contract in a production environment you'd probably want to lock down\n        /// the addresses that are allowed to create tokens.\n        #[ink(message)]\n        pub fn create(&mut self, value: Balance) -> TokenId {\n            let caller = self.env().caller();\n\n            // Given that TokenId is a `u128` the likelihood of this overflowing is pretty\n            // slim.\n            #[allow(clippy::arithmetic_side_effects)]\n            {\n                self.token_id_nonce += 1;\n            }\n            self.balances.insert((caller, self.token_id_nonce), &value);\n\n            // Emit transfer event but with mint semantics\n            self.env().emit_event(TransferSingle {\n                operator: Some(caller),\n                from: None,\n                to: if value == 0 { None } else { Some(caller) },\n                token_id: self.token_id_nonce,\n                value,\n            });\n\n            self.token_id_nonce\n        }\n\n        /// Mint a `value` amount of `token_id` tokens.\n        ///\n        /// It is assumed that the token has already been `create`-ed. The newly minted\n        /// supply will be assigned to the caller (a.k.a the minter).\n        ///\n        /// Note that as implemented anyone can mint tokens. If you were to instantiate\n        /// this contract in a production environment you'd probably want to lock down\n        /// the addresses that are allowed to mint tokens.\n        #[ink(message)]\n        pub fn mint(&mut self, token_id: TokenId, value: Balance) -> Result<()> {\n            ensure!(token_id <= self.token_id_nonce, Error::UnexistentToken);\n\n            let caller = self.env().caller();\n            self.balances.insert((caller, token_id), &value);\n\n            // Emit transfer event but with mint semantics\n            self.env().emit_event(TransferSingle {\n                operator: Some(caller),\n                from: None,\n                to: Some(caller),\n                token_id,\n                value,\n            });\n\n            Ok(())\n        }\n\n        // Helper function for performing single token transfers.\n        //\n        // Should not be used directly since it's missing certain checks which are\n        // important to the ERC-1155 standard (it is expected that the caller has\n        // already performed these).\n        //\n        // # Panics\n        //\n        // If `from` does not hold any `token_id` tokens.\n        fn perform_transfer(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            token_id: TokenId,\n            value: Balance,\n        ) {\n            let mut sender_balance = self\n                .balances\n                .get((from, token_id))\n                .expect(\"Caller should have ensured that `from` holds `token_id`.\");\n            // checks that sender_balance >= value were performed by caller\n            #[allow(clippy::arithmetic_side_effects)]\n            {\n                sender_balance -= value;\n            }\n            self.balances.insert((from, token_id), &sender_balance);\n\n            let mut recipient_balance = self.balances.get((to, token_id)).unwrap_or(0);\n            recipient_balance = recipient_balance.checked_add(value).unwrap();\n            self.balances.insert((to, token_id), &recipient_balance);\n\n            let caller = self.env().caller();\n            self.env().emit_event(TransferSingle {\n                operator: Some(caller),\n                from: Some(from),\n                to: Some(to),\n                token_id,\n                value,\n            });\n        }\n\n        // Check if the address at `to` is a smart contract which accepts ERC-1155 token\n        // transfers.\n        //\n        // If they're a smart contract which **doesn't** accept tokens transfers this call\n        // will revert. Otherwise we risk locking user funds at in that contract\n        // with no chance of recovery.\n        #[cfg_attr(test, allow(unused_variables))]\n        fn transfer_acceptance_check(\n            &mut self,\n            caller: AccountId,\n            from: AccountId,\n            to: AccountId,\n            token_id: TokenId,\n            value: Balance,\n            data: Vec<u8>,\n        ) {\n            // This is disabled during tests due to the use of `invoke_contract()` not\n            // being supported (tests end up panicking).\n            #[cfg(not(test))]\n            {\n                use ink::env::call::{\n                    build_call,\n                    ExecutionInput,\n                    Selector,\n                };\n\n                // If our recipient is a smart contract we need to see if they accept or\n                // reject this transfer. If they reject it we need to revert the call.\n                let result = build_call::<Environment>()\n                    .call(to)\n                    .ref_time_limit(5000)\n                    .exec_input(\n                        ExecutionInput::new(Selector::new(ON_ERC_1155_RECEIVED_SELECTOR))\n                            .push_arg(caller)\n                            .push_arg(from)\n                            .push_arg(token_id)\n                            .push_arg(value)\n                            .push_arg(data),\n                    )\n                    .returns::<Vec<u8>>()\n                    .params()\n                    .try_invoke();\n\n                match result {\n                    Ok(v) => {\n                        ink::env::debug_println!(\n                            \"Received return value \\\"{:?}\\\" from contract {:?}\",\n                            v.clone().expect(\n                                \"Call should be valid, don't expect a `LangError`.\"\n                            ),\n                            from\n                        );\n                        assert_eq!(\n                            v.clone().expect(\"Call should be valid, don't expect a `LangError`.\"),\n                            &ON_ERC_1155_RECEIVED_SELECTOR[..],\n                            \"The recipient contract at {to:?} does not accept token transfers.\\n\n                            Expected: {ON_ERC_1155_RECEIVED_SELECTOR:?}, Got {v:?}\"\n                        )\n                    }\n                    Err(e) => {\n                        use ink::env::ReturnErrorCode;\n\n                        match e {\n                            ink::env::Error::ReturnError(\n                                ReturnErrorCode::CodeNotFound\n                                | ReturnErrorCode::NotCallable,\n                            ) => {\n                                // Our recipient wasn't a smart contract, so there's\n                                // nothing more for\n                                // us to do\n                                ink::env::debug_println!(\"Recipient at {:?} from is not a smart contract ({:?})\", from, e);\n                            }\n                            _ => {\n                                // We got some sort of error from the call to our\n                                // recipient smart\n                                // contract, and as such we must revert this call\n                                panic!(\n                                    \"Got error \\\"{e:?}\\\" while trying to call {from:?}\"\n                                )\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    impl super::Erc1155 for Contract {\n        #[ink(message)]\n        fn safe_transfer_from(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            token_id: TokenId,\n            value: Balance,\n            data: Vec<u8>,\n        ) -> Result<()> {\n            let caller = self.env().caller();\n            if caller != from {\n                ensure!(self.is_approved_for_all(from, caller), Error::NotApproved);\n            }\n\n            ensure!(to != zero_address(), Error::ZeroAddressTransfer);\n\n            let balance = self.balance_of(from, token_id);\n            ensure!(balance >= value, Error::InsufficientBalance);\n\n            self.perform_transfer(from, to, token_id, value);\n            self.transfer_acceptance_check(caller, from, to, token_id, value, data);\n\n            Ok(())\n        }\n\n        #[ink(message)]\n        fn safe_batch_transfer_from(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            token_ids: Vec<TokenId>,\n            values: Vec<Balance>,\n            data: Vec<u8>,\n        ) -> Result<()> {\n            let caller = self.env().caller();\n            if caller != from {\n                ensure!(self.is_approved_for_all(from, caller), Error::NotApproved);\n            }\n\n            ensure!(to != zero_address(), Error::ZeroAddressTransfer);\n            ensure!(!token_ids.is_empty(), Error::BatchTransferMismatch);\n            ensure!(\n                token_ids.len() == values.len(),\n                Error::BatchTransferMismatch,\n            );\n\n            let transfers = token_ids.iter().zip(values.iter());\n            for (&id, &v) in transfers.clone() {\n                let balance = self.balance_of(from, id);\n                ensure!(balance >= v, Error::InsufficientBalance);\n            }\n\n            for (&id, &v) in transfers {\n                self.perform_transfer(from, to, id, v);\n            }\n\n            // Can use the any token ID/value here, we really just care about knowing if\n            // `to` is a smart contract which accepts transfers\n            self.transfer_acceptance_check(\n                caller,\n                from,\n                to,\n                token_ids[0],\n                values[0],\n                data,\n            );\n\n            Ok(())\n        }\n\n        #[ink(message)]\n        fn balance_of(&self, owner: AccountId, token_id: TokenId) -> Balance {\n            self.balances.get((owner, token_id)).unwrap_or(0)\n        }\n\n        #[ink(message)]\n        fn balance_of_batch(\n            &self,\n            owners: Vec<AccountId>,\n            token_ids: Vec<TokenId>,\n        ) -> Vec<Balance> {\n            let mut output = Vec::new();\n            for o in &owners {\n                for t in &token_ids {\n                    let amount = self.balance_of(*o, *t);\n                    output.push(amount);\n                }\n            }\n            output\n        }\n\n        #[ink(message)]\n        fn set_approval_for_all(\n            &mut self,\n            operator: AccountId,\n            approved: bool,\n        ) -> Result<()> {\n            let caller = self.env().caller();\n            ensure!(operator != caller, Error::SelfApproval);\n\n            if approved {\n                self.approvals.insert((&caller, &operator), &());\n            } else {\n                self.approvals.remove((&caller, &operator));\n            }\n\n            self.env().emit_event(ApprovalForAll {\n                owner: caller,\n                operator,\n                approved,\n            });\n\n            Ok(())\n        }\n\n        #[ink(message)]\n        fn is_approved_for_all(&self, owner: AccountId, operator: AccountId) -> bool {\n            self.approvals.contains((&owner, &operator))\n        }\n    }\n\n    impl super::Erc1155TokenReceiver for Contract {\n        #[ink(message, selector = 0xF23A6E61)]\n        fn on_received(\n            &mut self,\n            _operator: AccountId,\n            _from: AccountId,\n            _token_id: TokenId,\n            _value: Balance,\n            _data: Vec<u8>,\n        ) -> Vec<u8> {\n            // The ERC-1155 standard dictates that if a contract does not accept token\n            // transfers directly to the contract, then the contract must\n            // revert.\n            //\n            // This prevents a user from unintentionally transferring tokens to a smart\n            // contract and getting their funds stuck without any sort of\n            // recovery mechanism.\n            //\n            // Note that the choice of whether or not to accept tokens is implementation\n            // specific, and we've decided to not accept them in this\n            // implementation.\n            unimplemented!(\"This smart contract does not accept token transfer.\")\n        }\n\n        #[ink(message, selector = 0xBC197C81)]\n        fn on_batch_received(\n            &mut self,\n            _operator: AccountId,\n            _from: AccountId,\n            _token_ids: Vec<TokenId>,\n            _values: Vec<Balance>,\n            _data: Vec<u8>,\n        ) -> Vec<u8> {\n            // The ERC-1155 standard dictates that if a contract does not accept token\n            // transfers directly to the contract, then the contract must\n            // revert.\n            //\n            // This prevents a user from unintentionally transferring tokens to a smart\n            // contract and getting their funds stuck without any sort of\n            // recovery mechanism.\n            //\n            // Note that the choice of whether or not to accept tokens is implementation\n            // specific, and we've decided to not accept them in this\n            // implementation.\n            unimplemented!(\"This smart contract does not accept batch token transfers.\")\n        }\n    }\n\n    /// Helper for referencing the zero address (`0x00`). Note that in practice this\n    /// address should not be treated in any special way (such as a default\n    /// placeholder) since it has a known private key.\n    fn zero_address() -> AccountId {\n        [0u8; 32].into()\n    }\n\n    #[cfg(test)]\n    mod tests {\n        /// Imports all the definitions from the outer scope so we can use them here.\n        use super::*;\n        use crate::Erc1155;\n\n        fn set_sender(sender: AccountId) {\n            ink::env::test::set_caller::<Environment>(sender);\n        }\n\n        fn default_accounts() -> ink::env::test::DefaultAccounts<Environment> {\n            ink::env::test::default_accounts::<Environment>()\n        }\n\n        fn alice() -> AccountId {\n            default_accounts().alice\n        }\n\n        fn bob() -> AccountId {\n            default_accounts().bob\n        }\n\n        fn charlie() -> AccountId {\n            default_accounts().charlie\n        }\n\n        fn init_contract() -> Contract {\n            let mut erc = Contract::new();\n            erc.balances.insert((alice(), 1), &10);\n            erc.balances.insert((alice(), 2), &20);\n            erc.balances.insert((bob(), 1), &10);\n\n            erc\n        }\n\n        #[ink::test]\n        fn can_get_correct_balance_of() {\n            let erc = init_contract();\n\n            assert_eq!(erc.balance_of(alice(), 1), 10);\n            assert_eq!(erc.balance_of(alice(), 2), 20);\n            assert_eq!(erc.balance_of(alice(), 3), 0);\n            assert_eq!(erc.balance_of(bob(), 2), 0);\n        }\n\n        #[ink::test]\n        fn can_get_correct_batch_balance_of() {\n            let erc = init_contract();\n\n            assert_eq!(\n                erc.balance_of_batch(vec![alice()], vec![1, 2, 3]),\n                vec![10, 20, 0]\n            );\n            assert_eq!(\n                erc.balance_of_batch(vec![alice(), bob()], vec![1]),\n                vec![10, 10]\n            );\n\n            assert_eq!(\n                erc.balance_of_batch(vec![alice(), bob(), charlie()], vec![1, 2]),\n                vec![10, 20, 10, 0, 0, 0]\n            );\n        }\n\n        #[ink::test]\n        fn can_send_tokens_between_accounts() {\n            let mut erc = init_contract();\n\n            assert!(erc.safe_transfer_from(alice(), bob(), 1, 5, vec![]).is_ok());\n            assert_eq!(erc.balance_of(alice(), 1), 5);\n            assert_eq!(erc.balance_of(bob(), 1), 15);\n\n            assert!(erc.safe_transfer_from(alice(), bob(), 2, 5, vec![]).is_ok());\n            assert_eq!(erc.balance_of(alice(), 2), 15);\n            assert_eq!(erc.balance_of(bob(), 2), 5);\n        }\n\n        #[ink::test]\n        fn sending_too_many_tokens_fails() {\n            let mut erc = init_contract();\n            let res = erc.safe_transfer_from(alice(), bob(), 1, 99, vec![]);\n            assert_eq!(res.unwrap_err(), Error::InsufficientBalance);\n        }\n\n        #[ink::test]\n        fn sending_tokens_to_zero_address_fails() {\n            let burn: AccountId = [0; 32].into();\n\n            let mut erc = init_contract();\n            let res = erc.safe_transfer_from(alice(), burn, 1, 10, vec![]);\n            assert_eq!(res.unwrap_err(), Error::ZeroAddressTransfer);\n        }\n\n        #[ink::test]\n        fn can_send_batch_tokens() {\n            let mut erc = init_contract();\n            assert!(erc\n                .safe_batch_transfer_from(alice(), bob(), vec![1, 2], vec![5, 10], vec![])\n                .is_ok());\n\n            let balances = erc.balance_of_batch(vec![alice(), bob()], vec![1, 2]);\n            assert_eq!(balances, vec![5, 10, 15, 10])\n        }\n\n        #[ink::test]\n        fn rejects_batch_if_lengths_dont_match() {\n            let mut erc = init_contract();\n            let res = erc.safe_batch_transfer_from(\n                alice(),\n                bob(),\n                vec![1, 2, 3],\n                vec![5],\n                vec![],\n            );\n            assert_eq!(res.unwrap_err(), Error::BatchTransferMismatch);\n        }\n\n        #[ink::test]\n        fn batch_transfers_fail_if_len_is_zero() {\n            let mut erc = init_contract();\n            let res =\n                erc.safe_batch_transfer_from(alice(), bob(), vec![], vec![], vec![]);\n            assert_eq!(res.unwrap_err(), Error::BatchTransferMismatch);\n        }\n\n        #[ink::test]\n        fn operator_can_send_tokens() {\n            let mut erc = init_contract();\n\n            let owner = alice();\n            let operator = bob();\n\n            set_sender(owner);\n            assert!(erc.set_approval_for_all(operator, true).is_ok());\n\n            set_sender(operator);\n            assert!(erc\n                .safe_transfer_from(owner, charlie(), 1, 5, vec![])\n                .is_ok());\n            assert_eq!(erc.balance_of(alice(), 1), 5);\n            assert_eq!(erc.balance_of(charlie(), 1), 5);\n        }\n\n        #[ink::test]\n        fn approvals_work() {\n            let mut erc = init_contract();\n            let owner = alice();\n            let operator = bob();\n            let another_operator = charlie();\n\n            // Note: All of these tests are from the context of the owner who is either\n            // allowing or disallowing an operator to control their funds.\n            set_sender(owner);\n            assert!(!erc.is_approved_for_all(owner, operator));\n\n            assert!(erc.set_approval_for_all(operator, true).is_ok());\n            assert!(erc.is_approved_for_all(owner, operator));\n\n            assert!(erc.set_approval_for_all(another_operator, true).is_ok());\n            assert!(erc.is_approved_for_all(owner, another_operator));\n\n            assert!(erc.set_approval_for_all(operator, false).is_ok());\n            assert!(!erc.is_approved_for_all(owner, operator));\n        }\n\n        #[ink::test]\n        fn minting_tokens_works() {\n            let mut erc = Contract::new();\n\n            set_sender(alice());\n            assert_eq!(erc.create(0), 1);\n            assert_eq!(erc.balance_of(alice(), 1), 0);\n\n            assert!(erc.mint(1, 123).is_ok());\n            assert_eq!(erc.balance_of(alice(), 1), 123);\n        }\n\n        #[ink::test]\n        fn minting_not_allowed_for_nonexistent_tokens() {\n            let mut erc = Contract::new();\n\n            let res = erc.mint(1, 123);\n            assert_eq!(res.unwrap_err(), Error::UnexistentToken);\n        }\n    }\n}\n"
      },
      {
        "name": "rand-extension",
        "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\nuse ink::env::Environment;\n\n/// This is an example of how an ink! contract may call the Substrate\n/// runtime function `RandomnessCollectiveFlip::random_seed`. See the\n/// file `runtime/chain-extension-example.rs` for that implementation.\n///\n/// Here we define the operations to interact with the Substrate runtime.\n#[ink::chain_extension(extension = 666)]\npub trait FetchRandom {\n    type ErrorCode = RandomReadErr;\n\n    /// Note: this gives the operation a corresponding `func_id` (1101 in this case),\n    /// and the chain-side chain extension will get the `func_id` to do further\n    /// operations.\n    #[ink(function = 1101)]\n    fn fetch_random(subject: [u8; 32]) -> [u8; 32];\n}\n\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n#[ink::scale_derive(Encode, Decode, TypeInfo)]\npub enum RandomReadErr {\n    FailGetRandomSource,\n}\n\nimpl ink::env::chain_extension::FromStatusCode for RandomReadErr {\n    fn from_status_code(status_code: u32) -> Result<(), Self> {\n        match status_code {\n            0 => Ok(()),\n            1 => Err(Self::FailGetRandomSource),\n            _ => panic!(\"encountered unknown status code\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[ink::scale_derive(TypeInfo)]\npub enum CustomEnvironment {}\n\nimpl Environment for CustomEnvironment {\n    const MAX_EVENT_TOPICS: usize =\n        <ink::env::DefaultEnvironment as Environment>::MAX_EVENT_TOPICS;\n\n    type AccountId = <ink::env::DefaultEnvironment as Environment>::AccountId;\n    type Balance = <ink::env::DefaultEnvironment as Environment>::Balance;\n    type Hash = <ink::env::DefaultEnvironment as Environment>::Hash;\n    type BlockNumber = <ink::env::DefaultEnvironment as Environment>::BlockNumber;\n    type Timestamp = <ink::env::DefaultEnvironment as Environment>::Timestamp;\n\n    type ChainExtension = FetchRandom;\n}\n\n#[ink::contract(env = crate::CustomEnvironment)]\nmod rand_extension {\n    use super::RandomReadErr;\n\n    /// Defines the storage of our contract.\n    ///\n    /// Here we store the random seed fetched from the chain.\n    #[ink(storage)]\n    pub struct RandExtension {\n        /// Stores a single `bool` value on the storage.\n        value: [u8; 32],\n    }\n\n    #[ink(event)]\n    pub struct RandomUpdated {\n        #[ink(topic)]\n        new: [u8; 32],\n    }\n\n    impl RandExtension {\n        /// Constructor that initializes the `bool` value to the given `init_value`.\n        #[ink(constructor)]\n        pub fn new(init_value: [u8; 32]) -> Self {\n            Self { value: init_value }\n        }\n\n        /// Constructor that initializes the `bool` value to `false`.\n        ///\n        /// Constructors may delegate to other constructors.\n        #[ink(constructor)]\n        pub fn new_default() -> Self {\n            Self::new(Default::default())\n        }\n\n        /// Seed a random value by passing some known argument `subject` to the runtime's\n        /// random source. Then, update the current `value` stored in this contract with\n        /// the new random value.\n        #[ink(message)]\n        pub fn update(&mut self, subject: [u8; 32]) -> Result<(), RandomReadErr> {\n            // Get the on-chain random seed\n            let new_random = self.env().extension().fetch_random(subject)?;\n            self.value = new_random;\n            // Emit the `RandomUpdated` event when the random seed\n            // is successfully fetched.\n            self.env().emit_event(RandomUpdated { new: new_random });\n            Ok(())\n        }\n\n        /// Simply returns the current value.\n        #[ink(message)]\n        pub fn get(&self) -> [u8; 32] {\n            self.value\n        }\n    }\n\n    /// Unit tests in Rust are normally defined within such a `#[cfg(test)]`\n    #[cfg(test)]\n    mod tests {\n        /// Imports all the definitions from the outer scope so we can use them here.\n        use super::*;\n\n        /// We test if the default constructor does its job.\n        #[ink::test]\n        fn default_works() {\n            let rand_extension = RandExtension::new_default();\n            assert_eq!(rand_extension.get(), [0; 32]);\n        }\n\n        #[ink::test]\n        fn chain_extension_works() {\n            // given\n            struct MockedRandExtension;\n            impl ink::env::test::ChainExtension for MockedRandExtension {\n                /// The static function id of the chain extension.\n                fn ext_id(&self) -> u16 {\n                    666\n                }\n\n                /// The chain extension is called with the given input.\n                ///\n                /// Returns an error code and may fill the `output` buffer with a\n                /// SCALE encoded result. The error code is taken from the\n                /// `ink::env::chain_extension::FromStatusCode` implementation for\n                /// `RandomReadErr`.\n                fn call(\n                    &mut self,\n                    _func_id: u16,\n                    _input: &[u8],\n                    output: &mut Vec<u8>,\n                ) -> u32 {\n                    let ret: [u8; 32] = [1; 32];\n                    ink::scale::Encode::encode_to(&ret, output);\n                    0\n                }\n            }\n            ink::env::test::register_chain_extension(MockedRandExtension);\n            let mut rand_extension = RandExtension::new_default();\n            assert_eq!(rand_extension.get(), [0; 32]);\n\n            // when\n            rand_extension.update([0_u8; 32]).expect(\"update must work\");\n\n            // then\n            assert_eq!(rand_extension.get(), [1; 32]);\n        }\n    }\n}\n"
      },
      {
        "name": "multisig",
        "code": "//! # Multisig Wallet\n//!\n//! This implements a plain multi owner wallet.\n//!\n//! ## Warning\n//!\n//! This contract is an *example*. It is neither audited nor endorsed for production use.\n//! Do **not** rely on it to keep anything of value secure.\n//!\n//! ## Overview\n//!\n//! Each instantiation of this contract has a set of `owners` and a `requirement` of\n//! how many of them need to agree on a `Transaction` for it to be able to be executed.\n//! Every owner can submit a transaction and when enough of the other owners confirm\n//! it will be able to be executed. The following invariant is enforced by the contract:\n//!\n//! ```ignore\n//! 0 < requirement && requirement <= owners && owners <= MAX_OWNERS\n//! ```\n//!\n//! ## Error Handling\n//!\n//! With the exception of `execute_transaction` no error conditions are signalled\n//! through return types. Any error or invariant violation triggers a panic and therefore\n//! rolls back the transaction.\n//!\n//! ## Interface\n//!\n//! The interface is modelled after the popular Gnosis multisig wallet. However, there\n//! are subtle variations from the interface. For example the `confirm_transaction`\n//! will never trigger the execution of a `Transaction` even if the threshold is reached.\n//! A call of `execute_transaction` is always required. This can be called by anyone.\n//!\n//! All the messages that are declared as only callable by the wallet must go through\n//! the usual submit, confirm, execute cycle as any other transaction that should be\n//! called by the wallet. For example, to add an owner you would submit a transaction\n//! that calls the wallets own `add_owner` message through `submit_transaction`.\n//!\n//! ### Owner Management\n//!\n//! The messages `add_owner`, `remove_owner`, and `replace_owner` can be used to manage\n//! the owner set after instantiation.\n//!\n//! ### Changing the Requirement\n//!\n//! `change_requirement` can be used to tighten or relax the `requirement` of how many\n//! owner signatures are needed to execute a `Transaction`.\n//!\n//! ### Transaction Management\n//!\n//! `submit_transaction`, `cancel_transaction`, `confirm_transaction`,\n//! `revoke_confirmation` and `execute_transaction` are the bread and butter messages\n//! of this contract. Use them to dispatch arbitrary messages to other contracts\n//! with the wallet as a sender.\n\n#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\npub use self::multisig::{\n    ConfirmationStatus,\n    Multisig,\n    Transaction,\n};\n\n#[ink::contract]\nmod multisig {\n    use ink::{\n        env::{\n            call::{\n                build_call,\n                ExecutionInput,\n            },\n            CallFlags,\n        },\n        prelude::vec::Vec,\n        scale::Output,\n        storage::Mapping,\n    };\n\n    /// Tune this to your liking but be wary that allowing too many owners will not\n    /// perform well.\n    const MAX_OWNERS: u32 = 50;\n\n    type TransactionId = u32;\n    const WRONG_TRANSACTION_ID: &str =\n        \"The user specified an invalid transaction id. Abort.\";\n\n    /// A wrapper that allows us to encode a blob of bytes.\n    ///\n    /// We use this to pass the set of untyped (bytes) parameters to the `CallBuilder`.\n    #[derive(Clone)]\n    struct CallInput<'a>(&'a [u8]);\n\n    impl<'a> ink::scale::Encode for CallInput<'a> {\n        fn encode_to<T: Output + ?Sized>(&self, dest: &mut T) {\n            dest.write(self.0);\n        }\n    }\n\n    /// Indicates whether a transaction is already confirmed or needs further\n    /// confirmations.\n    #[derive(Clone, Copy)]\n    #[cfg_attr(feature = \"std\", derive(ink::storage::traits::StorageLayout))]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum ConfirmationStatus {\n        /// The transaction is already confirmed.\n        Confirmed,\n        /// Indicates how many confirmations are remaining.\n        ConfirmationsNeeded(u32),\n    }\n\n    /// A Transaction is what every `owner` can submit for confirmation by other owners.\n    /// If enough owners agree it will be executed by the contract.\n    #[derive(Clone)]\n    #[cfg_attr(\n        feature = \"std\",\n        derive(Debug, PartialEq, Eq, ink::storage::traits::StorageLayout)\n    )]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub struct Transaction {\n        /// The `AccountId` of the contract that is called in this transaction.\n        pub callee: AccountId,\n        /// The selector bytes that identifies the function of the callee that should be\n        /// called.\n        pub selector: [u8; 4],\n        /// The SCALE encoded parameters that are passed to the called function.\n        pub input: Vec<u8>,\n        /// The amount of chain balance that is transferred to the callee.\n        pub transferred_value: Balance,\n        /// Gas limit for the execution of the call.\n        pub ref_time_limit: u64,\n        /// If set to true the transaction will be allowed to re-enter the multisig\n        /// contract. Re-entrancy can lead to vulnerabilities. Use at your own\n        /// risk.\n        pub allow_reentry: bool,\n    }\n\n    /// Errors that can occur upon calling this contract.\n    #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        /// Returned if the call failed.\n        TransactionFailed,\n    }\n\n    /// This is a book keeping struct that stores a list of all transaction ids and\n    /// also the next id to use. We need it for cleaning up the storage.\n    #[derive(Clone, Default)]\n    #[cfg_attr(\n        feature = \"std\",\n        derive(Debug, PartialEq, Eq, ink::storage::traits::StorageLayout)\n    )]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub struct Transactions {\n        /// Just store all transaction ids packed.\n        transactions: Vec<TransactionId>,\n        /// We just increment this whenever a new transaction is created.\n        /// We never decrement or defragment. For now, the contract becomes defunct\n        /// when the ids are exhausted.\n        next_id: TransactionId,\n    }\n\n    /// Emitted when an owner confirms a transaction.\n    #[ink(event)]\n    pub struct Confirmation {\n        /// The transaction that was confirmed.\n        #[ink(topic)]\n        transaction: TransactionId,\n        /// The owner that sent the confirmation.\n        #[ink(topic)]\n        from: AccountId,\n        /// The confirmation status after this confirmation was applied.\n        #[ink(topic)]\n        status: ConfirmationStatus,\n    }\n\n    /// Emitted when an owner revoked a confirmation.\n    #[ink(event)]\n    pub struct Revocation {\n        /// The transaction that was revoked.\n        #[ink(topic)]\n        transaction: TransactionId,\n        /// The owner that sent the revocation.\n        #[ink(topic)]\n        from: AccountId,\n    }\n\n    /// Emitted when an owner submits a transaction.\n    #[ink(event)]\n    pub struct Submission {\n        /// The transaction that was submitted.\n        #[ink(topic)]\n        transaction: TransactionId,\n    }\n\n    /// Emitted when a transaction was canceled.\n    #[ink(event)]\n    pub struct Cancellation {\n        /// The transaction that was canceled.\n        #[ink(topic)]\n        transaction: TransactionId,\n    }\n\n    /// Emitted when a transaction was executed.\n    #[ink(event)]\n    pub struct Execution {\n        /// The transaction that was executed.\n        #[ink(topic)]\n        transaction: TransactionId,\n        /// Indicates whether the transaction executed successfully. If so the `Ok` value\n        /// holds the output in bytes. The Option is `None` when the transaction\n        /// was executed through `invoke_transaction` rather than\n        /// `evaluate_transaction`.\n        #[ink(topic)]\n        result: Result<Option<Vec<u8>>, Error>,\n    }\n\n    /// Emitted when an owner is added to the wallet.\n    #[ink(event)]\n    pub struct OwnerAddition {\n        /// The owner that was added.\n        #[ink(topic)]\n        owner: AccountId,\n    }\n\n    /// Emitted when an owner is removed from the wallet.\n    #[ink(event)]\n    pub struct OwnerRemoval {\n        /// The owner that was removed.\n        #[ink(topic)]\n        owner: AccountId,\n    }\n\n    /// Emitted when the requirement changed.\n    #[ink(event)]\n    pub struct RequirementChange {\n        /// The new requirement value.\n        new_requirement: u32,\n    }\n\n    #[ink(storage)]\n    #[derive(Default)]\n    pub struct Multisig {\n        /// Every entry in this map represents the confirmation of an owner for a\n        /// transaction. This is effectively a set rather than a map.\n        confirmations: Mapping<(TransactionId, AccountId), ()>,\n        /// The amount of confirmations for every transaction. This is a redundant\n        /// information and is kept in order to prevent iterating through the\n        /// confirmation set to check if a transaction is confirmed.\n        confirmation_count: Mapping<TransactionId, u32>,\n        /// Map the transaction id to its not-executed transaction.\n        transactions: Mapping<TransactionId, Transaction>,\n        /// We need to hold a list of all transactions so that we can clean up storage\n        /// when an owner is removed.\n        transaction_list: Transactions,\n        /// The list is a vector because iterating over it is necessary when cleaning\n        /// up the confirmation set.\n        owners: Vec<AccountId>,\n        /// Redundant information to speed up the check whether a caller is an owner.\n        is_owner: Mapping<AccountId, ()>,\n        /// Minimum number of owners that have to confirm a transaction to be executed.\n        requirement: u32,\n    }\n\n    impl Multisig {\n        /// The only constructor of the contract.\n        ///\n        /// A list of owners must be supplied and a number of how many of them must\n        /// confirm a transaction. Duplicate owners are silently dropped.\n        ///\n        /// # Panics\n        ///\n        /// If `requirement` violates our invariant.\n        #[ink(constructor)]\n        pub fn new(requirement: u32, mut owners: Vec<AccountId>) -> Self {\n            let mut contract = Multisig::default();\n            owners.sort_unstable();\n            owners.dedup();\n            ensure_requirement_is_valid(owners.len() as u32, requirement);\n\n            for owner in &owners {\n                contract.is_owner.insert(owner, &());\n            }\n\n            contract.owners = owners;\n            contract.transaction_list = Default::default();\n            contract.requirement = requirement;\n            contract\n        }\n\n        /// Add a new owner to the contract.\n        ///\n        /// Only callable by the wallet itself.\n        ///\n        /// # Panics\n        ///\n        /// If the owner already exists.\n        ///\n        /// # Examples\n        ///\n        /// Since this message must be send by the wallet itself it has to be build as a\n        /// `Transaction` and dispatched through `submit_transaction` and\n        /// `invoke_transaction`:\n        /// ```should_panic\n        /// use ink::{\n        ///     env::{\n        ///         call::{\n        ///             utils::ArgumentList,\n        ///             Call,\n        ///             CallParams,\n        ///             ExecutionInput,\n        ///             Selector,\n        ///         },\n        ///         DefaultEnvironment as Env,\n        ///         Environment,\n        ///     },\n        ///     scale::Encode,\n        ///     selector_bytes,\n        /// };\n        /// use multisig::{\n        ///     ConfirmationStatus,\n        ///     Transaction,\n        /// };\n        ///\n        /// type AccountId = <Env as Environment>::AccountId;\n        ///\n        /// // address of an existing `Multisig` contract\n        /// let wallet_id: AccountId = [7u8; 32].into();\n        ///\n        /// // first create the transaction that adds `alice` through `add_owner`\n        /// let alice: AccountId = [1u8; 32].into();\n        /// let add_owner_args = ArgumentList::empty().push_arg(&alice);\n        ///\n        /// let transaction_candidate = Transaction {\n        ///     callee: wallet_id,\n        ///     selector: selector_bytes!(\"add_owner\"),\n        ///     input: add_owner_args.encode(),\n        ///     transferred_value: 0,\n        ///     ref_time_limit: 0,\n        ///     allow_reentry: true,\n        /// };\n        ///\n        /// // Submit the transaction for confirmation\n        /// //\n        /// // Note that the selector bytes of the `submit_transaction` method\n        /// // are `[86, 244, 13, 223]`.\n        /// let (id, _status) = ink::env::call::build_call::<Env>()\n        ///     .call_type(Call::new(wallet_id))\n        ///     .ref_time_limit(0)\n        ///     .exec_input(\n        ///         ExecutionInput::new(Selector::new([86, 244, 13, 223]))\n        ///             .push_arg(&transaction_candidate),\n        ///     )\n        ///     .returns::<(u32, ConfirmationStatus)>()\n        ///     .invoke();\n        ///\n        /// // Wait until all owners have confirmed and then execute the tx.\n        /// //\n        /// // Note that the selector bytes of the `invoke_transaction` method\n        /// // are `[185, 50, 225, 236]`.\n        /// ink::env::call::build_call::<Env>()\n        ///     .call_type(Call::new(wallet_id))\n        ///     .ref_time_limit(0)\n        ///     .exec_input(ExecutionInput::new(Selector::new([185, 50, 225, 236])).push_arg(&id))\n        ///     .returns::<()>()\n        ///     .invoke();\n        /// ```\n        #[ink(message)]\n        pub fn add_owner(&mut self, new_owner: AccountId) {\n            self.ensure_from_wallet();\n            self.ensure_no_owner(&new_owner);\n            ensure_requirement_is_valid(\n                (self.owners.len() as u32).checked_add(1).unwrap(),\n                self.requirement,\n            );\n            self.is_owner.insert(new_owner, &());\n            self.owners.push(new_owner);\n            self.env().emit_event(OwnerAddition { owner: new_owner });\n        }\n\n        /// Remove an owner from the contract.\n        ///\n        /// Only callable by the wallet itself. If by doing this the amount of owners\n        /// would be smaller than the requirement it is adjusted to be exactly the\n        /// number of owners.\n        ///\n        /// # Panics\n        ///\n        /// If `owner` is no owner of the wallet.\n        #[ink(message)]\n        pub fn remove_owner(&mut self, owner: AccountId) {\n            self.ensure_from_wallet();\n            self.ensure_owner(&owner);\n            // If caller is an owner the len has to be > 0\n            #[allow(clippy::arithmetic_side_effects)]\n            let len = self.owners.len() as u32 - 1;\n            let requirement = u32::min(len, self.requirement);\n            ensure_requirement_is_valid(len, requirement);\n            let owner_index = self.owner_index(&owner) as usize;\n            self.owners.swap_remove(owner_index);\n            self.is_owner.remove(owner);\n            self.requirement = requirement;\n            self.clean_owner_confirmations(&owner);\n            self.env().emit_event(OwnerRemoval { owner });\n        }\n\n        /// Replace an owner from the contract with a new one.\n        ///\n        /// Only callable by the wallet itself.\n        ///\n        /// # Panics\n        ///\n        /// If `old_owner` is no owner or if `new_owner` already is one.\n        #[ink(message)]\n        pub fn replace_owner(&mut self, old_owner: AccountId, new_owner: AccountId) {\n            self.ensure_from_wallet();\n            self.ensure_owner(&old_owner);\n            self.ensure_no_owner(&new_owner);\n            let owner_index = self.owner_index(&old_owner);\n            self.owners[owner_index as usize] = new_owner;\n            self.is_owner.remove(old_owner);\n            self.is_owner.insert(new_owner, &());\n            self.clean_owner_confirmations(&old_owner);\n            self.env().emit_event(OwnerRemoval { owner: old_owner });\n            self.env().emit_event(OwnerAddition { owner: new_owner });\n        }\n\n        /// Change the requirement to a new value.\n        ///\n        /// Only callable by the wallet itself.\n        ///\n        /// # Panics\n        ///\n        /// If the `new_requirement` violates our invariant.\n        #[ink(message)]\n        pub fn change_requirement(&mut self, new_requirement: u32) {\n            self.ensure_from_wallet();\n            ensure_requirement_is_valid(self.owners.len() as u32, new_requirement);\n            self.requirement = new_requirement;\n            self.env().emit_event(RequirementChange { new_requirement });\n        }\n\n        /// Add a new transaction candidate to the contract.\n        ///\n        /// This also confirms the transaction for the caller. This can be called by any\n        /// owner.\n        #[ink(message)]\n        pub fn submit_transaction(\n            &mut self,\n            transaction: Transaction,\n        ) -> (TransactionId, ConfirmationStatus) {\n            self.ensure_caller_is_owner();\n            let trans_id = self.transaction_list.next_id;\n            self.transaction_list.next_id =\n                trans_id.checked_add(1).expect(\"Transaction ids exhausted.\");\n            self.transactions.insert(trans_id, &transaction);\n            self.transaction_list.transactions.push(trans_id);\n            self.env().emit_event(Submission {\n                transaction: trans_id,\n            });\n            (\n                trans_id,\n                self.confirm_by_caller(self.env().caller(), trans_id),\n            )\n        }\n\n        /// Remove a transaction from the contract.\n        /// Only callable by the wallet itself.\n        ///\n        /// # Panics\n        ///\n        /// If `trans_id` is no valid transaction id.\n        #[ink(message)]\n        pub fn cancel_transaction(&mut self, trans_id: TransactionId) {\n            self.ensure_from_wallet();\n            if self.take_transaction(trans_id).is_some() {\n                self.env().emit_event(Cancellation {\n                    transaction: trans_id,\n                });\n            }\n        }\n\n        /// Confirm a transaction for the sender that was submitted by any owner.\n        ///\n        /// This can be called by any owner.\n        ///\n        /// # Panics\n        ///\n        /// If `trans_id` is no valid transaction id.\n        #[ink(message)]\n        pub fn confirm_transaction(\n            &mut self,\n            trans_id: TransactionId,\n        ) -> ConfirmationStatus {\n            self.ensure_caller_is_owner();\n            self.ensure_transaction_exists(trans_id);\n            self.confirm_by_caller(self.env().caller(), trans_id)\n        }\n\n        /// Revoke the senders confirmation.\n        ///\n        /// This can be called by any owner.\n        ///\n        /// # Panics\n        ///\n        /// If `trans_id` is no valid transaction id.\n        #[ink(message)]\n        pub fn revoke_confirmation(&mut self, trans_id: TransactionId) {\n            self.ensure_caller_is_owner();\n            let caller = self.env().caller();\n            if self.confirmations.contains((trans_id, caller)) {\n                self.confirmations.remove((trans_id, caller));\n                let mut confirmation_count = self\n                    .confirmation_count\n                    .get(trans_id)\n                    .expect(\n                    \"There is a entry in `self.confirmations`. Hence a count must exit.\",\n                );\n                // Will not underflow as there is at least one confirmation\n                #[allow(clippy::arithmetic_side_effects)]\n                {\n                    confirmation_count -= 1;\n                }\n                self.confirmation_count\n                    .insert(trans_id, &confirmation_count);\n                self.env().emit_event(Revocation {\n                    transaction: trans_id,\n                    from: caller,\n                });\n            }\n        }\n\n        /// Invoke a confirmed execution without getting its output.\n        ///\n        /// If the transaction which is invoked transfers value, this value has\n        /// to be sent as payment with this call. The method will fail otherwise,\n        /// and the transaction would then be reverted.\n        ///\n        /// Its return value indicates whether the called transaction was successful.\n        /// This can be called by anyone.\n        #[ink(message, payable)]\n        pub fn invoke_transaction(\n            &mut self,\n            trans_id: TransactionId,\n        ) -> Result<(), Error> {\n            self.ensure_confirmed(trans_id);\n            let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);\n            assert!(self.env().transferred_value() == t.transferred_value);\n            let call_flags = if t.allow_reentry {\n                CallFlags::ALLOW_REENTRY\n            } else {\n                CallFlags::empty()\n            };\n\n            let result = build_call::<<Self as ::ink::env::ContractEnv>::Env>()\n                .call(t.callee)\n                .ref_time_limit(t.ref_time_limit)\n                .transferred_value(t.transferred_value)\n                .call_flags(call_flags)\n                .exec_input(\n                    ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)),\n                )\n                .returns::<()>()\n                .try_invoke();\n\n            let result = match result {\n                Ok(Ok(_)) => Ok(()),\n                _ => Err(Error::TransactionFailed),\n            };\n\n            self.env().emit_event(Execution {\n                transaction: trans_id,\n                result: result.map(|_| None),\n            });\n            result\n        }\n\n        /// Evaluate a confirmed execution and return its output as bytes.\n        ///\n        /// Its return value indicates whether the called transaction was successful and\n        /// contains its output when successful.\n        /// This can be called by anyone.\n        #[ink(message, payable)]\n        pub fn eval_transaction(\n            &mut self,\n            trans_id: TransactionId,\n        ) -> Result<Vec<u8>, Error> {\n            self.ensure_confirmed(trans_id);\n            let t = self.take_transaction(trans_id).expect(WRONG_TRANSACTION_ID);\n            let call_flags = if t.allow_reentry {\n                CallFlags::ALLOW_REENTRY\n            } else {\n                CallFlags::empty()\n            };\n\n            let result = build_call::<<Self as ::ink::env::ContractEnv>::Env>()\n                .call(t.callee)\n                .ref_time_limit(t.ref_time_limit)\n                .transferred_value(t.transferred_value)\n                .call_flags(call_flags)\n                .exec_input(\n                    ExecutionInput::new(t.selector.into()).push_arg(CallInput(&t.input)),\n                )\n                .returns::<Vec<u8>>()\n                .try_invoke();\n\n            let result = match result {\n                Ok(Ok(v)) => Ok(v),\n                _ => Err(Error::TransactionFailed),\n            };\n\n            self.env().emit_event(Execution {\n                transaction: trans_id,\n                result: result.clone().map(Some),\n            });\n            result\n        }\n\n        /// Set the `transaction` as confirmed by `confirmer`.\n        /// Idempotent operation regarding an already confirmed `transaction`\n        /// by `confirmer`.\n        fn confirm_by_caller(\n            &mut self,\n            confirmer: AccountId,\n            transaction: TransactionId,\n        ) -> ConfirmationStatus {\n            let mut count = self.confirmation_count.get(transaction).unwrap_or(0);\n            let key = (transaction, confirmer);\n            let new_confirmation = !self.confirmations.contains(key);\n            if new_confirmation {\n                count = count.checked_add(1).unwrap();\n                self.confirmations.insert(key, &());\n                self.confirmation_count.insert(transaction, &count);\n            }\n            let status = {\n                if count >= self.requirement {\n                    ConfirmationStatus::Confirmed\n                } else {\n                    // We checked that count < self.requirement\n                    #[allow(clippy::arithmetic_side_effects)]\n                    ConfirmationStatus::ConfirmationsNeeded(self.requirement - count)\n                }\n            };\n            if new_confirmation {\n                self.env().emit_event(Confirmation {\n                    transaction,\n                    from: confirmer,\n                    status,\n                });\n            }\n            status\n        }\n\n        /// Get the index of `owner` in `self.owners`.\n        /// Panics if `owner` is not found in `self.owners`.\n        fn owner_index(&self, owner: &AccountId) -> u32 {\n            self.owners.iter().position(|x| *x == *owner).expect(\n                \"This is only called after it was already verified that the id is\n                 actually an owner.\",\n            ) as u32\n        }\n\n        /// Remove the transaction identified by `trans_id` from `self.transactions`.\n        /// Also removes all confirmation state associated with it.\n        fn take_transaction(&mut self, trans_id: TransactionId) -> Option<Transaction> {\n            let transaction = self.transactions.get(trans_id);\n            if transaction.is_some() {\n                self.transactions.remove(trans_id);\n                let pos = self\n                    .transaction_list\n                    .transactions\n                    .iter()\n                    .position(|t| t == &trans_id)\n                    .expect(\"The transaction exists hence it must also be in the list.\");\n                self.transaction_list.transactions.swap_remove(pos);\n                for owner in self.owners.iter() {\n                    self.confirmations.remove((trans_id, *owner));\n                }\n                self.confirmation_count.remove(trans_id);\n            }\n            transaction\n        }\n\n        /// Remove all confirmation state associated with `owner`.\n        /// Also adjusts the `self.confirmation_count` variable.\n        fn clean_owner_confirmations(&mut self, owner: &AccountId) {\n            for trans_id in &self.transaction_list.transactions {\n                let key = (*trans_id, *owner);\n                if self.confirmations.contains(key) {\n                    self.confirmations.remove(key);\n                    let mut count = self.confirmation_count.get(trans_id).unwrap_or(0);\n                    count = count.saturating_sub(1);\n                    self.confirmation_count.insert(trans_id, &count);\n                }\n            }\n        }\n\n        /// Panic if transaction `trans_id` is not confirmed by at least\n        /// `self.requirement` owners.\n        fn ensure_confirmed(&self, trans_id: TransactionId) {\n            assert!(\n                self.confirmation_count\n                    .get(trans_id)\n                    .expect(WRONG_TRANSACTION_ID)\n                    >= self.requirement\n            );\n        }\n\n        /// Panic if the transaction `trans_id` does not exit.\n        fn ensure_transaction_exists(&self, trans_id: TransactionId) {\n            self.transactions.get(trans_id).expect(WRONG_TRANSACTION_ID);\n        }\n\n        /// Panic if the sender is no owner of the wallet.\n        fn ensure_caller_is_owner(&self) {\n            self.ensure_owner(&self.env().caller());\n        }\n\n        /// Panic if the sender is not this wallet.\n        fn ensure_from_wallet(&self) {\n            assert_eq!(self.env().caller(), self.env().account_id());\n        }\n\n        /// Panic if `owner` is not an owner,\n        fn ensure_owner(&self, owner: &AccountId) {\n            assert!(self.is_owner.contains(owner));\n        }\n\n        /// Panic if `owner` is an owner.\n        fn ensure_no_owner(&self, owner: &AccountId) {\n            assert!(!self.is_owner.contains(owner));\n        }\n    }\n\n    /// Panic if the number of `owners` under a `requirement` violates our\n    /// requirement invariant.\n    fn ensure_requirement_is_valid(owners: u32, requirement: u32) {\n        assert!(0 < requirement && requirement <= owners && owners <= MAX_OWNERS);\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n        use ink::env::{\n            call::utils::ArgumentList,\n            test,\n        };\n\n        const WALLET: [u8; 32] = [7; 32];\n\n        impl Transaction {\n            fn change_requirement(requirement: u32) -> Self {\n                use ink::scale::Encode;\n                let call_args = ArgumentList::empty().push_arg(&requirement);\n\n                // Multisig::change_requirement()\n                Self {\n                    callee: AccountId::from(WALLET),\n                    selector: ink::selector_bytes!(\"change_requirement\"),\n                    input: call_args.encode(),\n                    transferred_value: 0,\n                    ref_time_limit: 1000000,\n                    allow_reentry: false,\n                }\n            }\n        }\n\n        fn set_caller(sender: AccountId) {\n            ink::env::test::set_caller::<Environment>(sender);\n        }\n\n        fn set_from_wallet() {\n            let callee = AccountId::from(WALLET);\n            set_caller(callee);\n        }\n\n        fn set_from_owner() {\n            let accounts = default_accounts();\n            set_caller(accounts.alice);\n        }\n\n        fn set_from_no_owner() {\n            let accounts = default_accounts();\n            set_caller(accounts.django);\n        }\n\n        fn default_accounts() -> test::DefaultAccounts<Environment> {\n            ink::env::test::default_accounts::<Environment>()\n        }\n\n        fn build_contract() -> Multisig {\n            // Set the contract's address as `WALLET`.\n            let callee: AccountId = AccountId::from(WALLET);\n            ink::env::test::set_callee::<ink::env::DefaultEnvironment>(callee);\n\n            let accounts = default_accounts();\n            let owners = vec![accounts.alice, accounts.bob, accounts.eve];\n            Multisig::new(2, owners)\n        }\n\n        fn submit_transaction() -> Multisig {\n            let mut contract = build_contract();\n            let accounts = default_accounts();\n            set_from_owner();\n            contract.submit_transaction(Transaction::change_requirement(1));\n            assert_eq!(contract.transaction_list.transactions.len(), 1);\n            assert_eq!(test::recorded_events().count(), 2);\n            let transaction = contract.transactions.get(0).unwrap();\n            assert_eq!(transaction, Transaction::change_requirement(1));\n            contract.confirmations.get((0, accounts.alice)).unwrap();\n            assert_eq!(contract.confirmation_count.get(0).unwrap(), 1);\n            contract\n        }\n\n        #[ink::test]\n        fn construction_works() {\n            let accounts = default_accounts();\n            let owners = [accounts.alice, accounts.bob, accounts.eve];\n            let contract = build_contract();\n\n            assert_eq!(contract.owners.len(), 3);\n            assert_eq!(contract.requirement, 2);\n            assert!(contract.owners.iter().eq(owners.iter()));\n            assert!(contract.is_owner.contains(accounts.alice));\n            assert!(contract.is_owner.contains(accounts.bob));\n            assert!(contract.is_owner.contains(accounts.eve));\n            assert!(!contract.is_owner.contains(accounts.charlie));\n            assert!(!contract.is_owner.contains(accounts.django));\n            assert!(!contract.is_owner.contains(accounts.frank));\n            assert_eq!(contract.transaction_list.transactions.len(), 0);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn empty_owner_construction_fails() {\n            Multisig::new(0, vec![]);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn zero_requirement_construction_fails() {\n            let accounts = default_accounts();\n            Multisig::new(0, vec![accounts.alice, accounts.bob]);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn too_large_requirement_construction_fails() {\n            let accounts = default_accounts();\n            Multisig::new(3, vec![accounts.alice, accounts.bob]);\n        }\n\n        #[ink::test]\n        fn add_owner_works() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_wallet();\n            let owners = contract.owners.len();\n            contract.add_owner(accounts.frank);\n            assert_eq!(contract.owners.len(), owners + 1);\n            assert!(contract.is_owner.contains(accounts.frank));\n            assert_eq!(test::recorded_events().count(), 1);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn add_existing_owner_fails() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_wallet();\n            contract.add_owner(accounts.bob);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn add_owner_permission_denied() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_owner();\n            contract.add_owner(accounts.frank);\n        }\n\n        #[ink::test]\n        fn remove_owner_works() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_wallet();\n            let owners = contract.owners.len();\n            contract.remove_owner(accounts.alice);\n            assert_eq!(contract.owners.len(), owners - 1);\n            assert!(!contract.is_owner.contains(accounts.alice));\n            assert_eq!(test::recorded_events().count(), 1);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn remove_owner_nonexisting_fails() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_wallet();\n            contract.remove_owner(accounts.django);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn remove_owner_permission_denied() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_owner();\n            contract.remove_owner(accounts.alice);\n        }\n\n        #[ink::test]\n        fn replace_owner_works() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_wallet();\n            let owners = contract.owners.len();\n            contract.replace_owner(accounts.alice, accounts.django);\n            assert_eq!(contract.owners.len(), owners);\n            assert!(!contract.is_owner.contains(accounts.alice));\n            assert!(contract.is_owner.contains(accounts.django));\n            assert_eq!(test::recorded_events().count(), 2);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn replace_owner_existing_fails() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_wallet();\n            contract.replace_owner(accounts.alice, accounts.bob);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn replace_owner_nonexisting_fails() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_wallet();\n            contract.replace_owner(accounts.django, accounts.frank);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn replace_owner_permission_denied() {\n            let accounts = default_accounts();\n            let mut contract = build_contract();\n            set_from_owner();\n            contract.replace_owner(accounts.alice, accounts.django);\n        }\n\n        #[ink::test]\n        fn change_requirement_works() {\n            let mut contract = build_contract();\n            assert_eq!(contract.requirement, 2);\n            set_from_wallet();\n            contract.change_requirement(3);\n            assert_eq!(contract.requirement, 3);\n            assert_eq!(test::recorded_events().count(), 1);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn change_requirement_too_high() {\n            let mut contract = build_contract();\n            set_from_wallet();\n            contract.change_requirement(4);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn change_requirement_zero_fails() {\n            let mut contract = build_contract();\n            set_from_wallet();\n            contract.change_requirement(0);\n        }\n\n        #[ink::test]\n        fn submit_transaction_works() {\n            submit_transaction();\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn submit_transaction_no_owner_fails() {\n            let mut contract = build_contract();\n            set_from_no_owner();\n            contract.submit_transaction(Transaction::change_requirement(1));\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn submit_transaction_wallet_fails() {\n            let mut contract = build_contract();\n            set_from_wallet();\n            contract.submit_transaction(Transaction::change_requirement(1));\n        }\n\n        #[ink::test]\n        fn cancel_transaction_works() {\n            let mut contract = submit_transaction();\n            set_from_wallet();\n            contract.cancel_transaction(0);\n            assert_eq!(contract.transaction_list.transactions.len(), 0);\n            assert_eq!(test::recorded_events().count(), 3);\n        }\n\n        #[ink::test]\n        fn cancel_transaction_nonexisting() {\n            let mut contract = submit_transaction();\n            set_from_wallet();\n            contract.cancel_transaction(1);\n            assert_eq!(contract.transaction_list.transactions.len(), 1);\n            assert_eq!(test::recorded_events().count(), 2);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn cancel_transaction_no_permission() {\n            let mut contract = submit_transaction();\n            contract.cancel_transaction(0);\n        }\n\n        #[ink::test]\n        fn confirm_transaction_works() {\n            let mut contract = submit_transaction();\n            let accounts = default_accounts();\n            set_caller(accounts.bob);\n            contract.confirm_transaction(0);\n            assert_eq!(test::recorded_events().count(), 3);\n            contract.confirmations.get((0, accounts.bob)).unwrap();\n            assert_eq!(contract.confirmation_count.get(0).unwrap(), 2);\n        }\n\n        #[ink::test]\n        fn revoke_confirmations() {\n            // given\n            let mut contract = submit_transaction();\n            let accounts = default_accounts();\n            // Confirm by Bob\n            set_caller(accounts.bob);\n            contract.confirm_transaction(0);\n            // Confirm by Eve\n            set_caller(accounts.eve);\n            contract.confirm_transaction(0);\n            assert_eq!(contract.confirmation_count.get(0).unwrap(), 3);\n            // Revoke from Eve\n            contract.revoke_confirmation(0);\n            assert_eq!(contract.confirmation_count.get(0).unwrap(), 2);\n            // Revoke from Bob\n            set_caller(accounts.bob);\n            contract.revoke_confirmation(0);\n            assert_eq!(contract.confirmation_count.get(0).unwrap(), 1);\n        }\n\n        #[ink::test]\n        fn confirm_transaction_already_confirmed() {\n            let mut contract = submit_transaction();\n            let accounts = default_accounts();\n            set_caller(accounts.alice);\n            contract.confirm_transaction(0);\n            assert_eq!(test::recorded_events().count(), 2);\n            contract.confirmations.get((0, accounts.alice)).unwrap();\n            assert_eq!(contract.confirmation_count.get(0).unwrap(), 1);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn confirm_transaction_no_owner_fail() {\n            let mut contract = submit_transaction();\n            set_from_no_owner();\n            contract.confirm_transaction(0);\n        }\n\n        #[ink::test]\n        fn revoke_transaction_works() {\n            let mut contract = submit_transaction();\n            let accounts = default_accounts();\n            set_caller(accounts.alice);\n            contract.revoke_confirmation(0);\n            assert_eq!(test::recorded_events().count(), 3);\n            assert!(!contract.confirmations.contains((0, accounts.alice)));\n            assert_eq!(contract.confirmation_count.get(0).unwrap(), 0);\n        }\n\n        #[ink::test]\n        fn revoke_transaction_no_confirmer() {\n            let mut contract = submit_transaction();\n            let accounts = default_accounts();\n            set_caller(accounts.bob);\n            contract.revoke_confirmation(0);\n            assert_eq!(test::recorded_events().count(), 2);\n            assert!(contract.confirmations.contains((0, accounts.alice)));\n            assert_eq!(contract.confirmation_count.get(0).unwrap(), 1);\n        }\n\n        #[ink::test]\n        #[should_panic]\n        fn revoke_transaction_no_owner_fail() {\n            let mut contract = submit_transaction();\n            let accounts = default_accounts();\n            set_caller(accounts.django);\n            contract.revoke_confirmation(0);\n        }\n\n        #[ink::test]\n        fn execute_transaction_works() {\n            // Execution of calls is currently unsupported in off-chain test.\n            // Calling `execute_transaction` panics in any case.\n        }\n    }\n}\n"
      },
      {
        "name": "delegator",
        "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\npub mod delegator {\n    use ink::{\n        env::{\n            call::{\n                build_call,\n                ExecutionInput,\n                Selector,\n            },\n            CallFlags,\n            DefaultEnvironment,\n        },\n        storage::{\n            traits::ManualKey,\n            Lazy,\n            Mapping,\n        },\n    };\n\n    #[ink(storage)]\n    pub struct Delegator {\n        addresses: Mapping<AccountId, i32, ManualKey<0x23>>,\n        counter: i32,\n        delegate_to: Lazy<Hash>,\n    }\n\n    impl Delegator {\n        /// Creates a new delegator smart contract with an initial value, and the hash of\n        /// the contract code to delegate to.\n        ///\n        /// Additionally, this code hash will be locked to prevent its deletion, since\n        /// this contract depends on it.\n        #[ink(constructor)]\n        pub fn new(init_value: i32, hash: Hash) -> Self {\n            let v = Mapping::new();\n\n            // Initialize the hash of the contract to delegate to.\n            // Adds a delegate dependency lock, ensuring that the delegated to code cannot\n            // be removed.\n            let mut delegate_to = Lazy::new();\n            delegate_to.set(&hash);\n            Self::env().lock_delegate_dependency(&hash);\n\n            Self {\n                addresses: v,\n                counter: init_value,\n                delegate_to,\n            }\n        }\n\n        /// Update the hash of the contract to delegate to.\n        /// - Unlocks the old delegate dependency, releasing the deposit and allowing old\n        ///   delegated to code to be removed.\n        /// - Adds a new delegate dependency lock, ensuring that the new delegated to code\n        ///   cannot be removed.\n        #[ink(message)]\n        pub fn update_delegate_to(&mut self, hash: Hash) {\n            if let Some(old_hash) = self.delegate_to.get() {\n                self.env().unlock_delegate_dependency(&old_hash)\n            }\n            self.env().lock_delegate_dependency(&hash);\n            self.delegate_to.set(&hash);\n        }\n\n        /// Increment the current value using delegate call.\n        #[ink(message)]\n        pub fn inc_delegate(&mut self) {\n            let selector = ink::selector_bytes!(\"inc\");\n            let _ = build_call::<DefaultEnvironment>()\n                .delegate(self.delegate_to())\n                // We specify `CallFlags::TAIL_CALL` to use the delegatee last memory frame\n                // as the end of the execution cycle.\n                // So any mutations to `Packed` types, made by delegatee,\n                // will be flushed to storage.\n                //\n                // If we don't specify this flag.\n                // The storage state before the delegate call will be flushed to storage instead.\n                // See https://substrate.stackexchange.com/questions/3336/i-found-set-allow-reentry-may-have-some-problems/3352#3352\n                .call_flags(CallFlags::TAIL_CALL)\n                .exec_input(ExecutionInput::new(Selector::new(selector)))\n                .returns::<()>()\n                .try_invoke();\n        }\n\n        /// Adds entry to `addresses` using delegate call.\n        /// Note that we don't need `CallFlags::TAIL_CALL` flag\n        /// because `Mapping` updates the storage instantly on-demand.\n        #[ink(message)]\n        pub fn add_entry_delegate(&mut self) {\n            let selector = ink::selector_bytes!(\"append_address_value\");\n            let _ = build_call::<DefaultEnvironment>()\n                .delegate(self.delegate_to())\n                .exec_input(ExecutionInput::new(Selector::new(selector)))\n                .returns::<()>()\n                .try_invoke();\n        }\n\n        /// Returns the current value of the counter.\n        #[ink(message)]\n        pub fn get_counter(&self) -> i32 {\n            self.counter\n        }\n\n        /// Returns the current value of the address.\n        #[ink(message)]\n        pub fn get_value(&self, address: AccountId) -> (AccountId, Option<i32>) {\n            (self.env().caller(), self.addresses.get(address))\n        }\n\n        fn delegate_to(&self) -> Hash {\n            self.delegate_to\n                .get()\n                .expect(\"delegate_to always has a value\")\n        }\n    }\n\n    #[cfg(all(test, feature = \"e2e-tests\"))]\n    mod e2e_tests {\n        use super::*;\n        use ink_e2e::{\n            ChainBackend,\n            ContractsBackend,\n        };\n\n        type E2EResult<T> = std::result::Result<T, Box<dyn std::error::Error>>;\n\n        #[ink_e2e::test]\n        async fn e2e_counter_mutated<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let origin = client\n                .create_and_fund_account(&ink_e2e::alice(), 10_000_000_000_000)\n                .await;\n\n            let code_hash = client\n                .upload(\"delegatee\", &origin)\n                .submit()\n                .await\n                .expect(\"upload `delegatee` failed\")\n                .code_hash;\n\n            let mut constructor = DelegatorRef::new(0, code_hash);\n            let contract = client\n                .instantiate(\"delegator\", &origin, &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Delegator>();\n\n            // when\n            let call_delegate = call_builder.inc_delegate();\n\n            let result = client.call(&origin, &call_delegate).submit().await;\n            assert!(result.is_ok(), \"delegate call failed.\");\n\n            let result = client.call(&origin, &call_delegate).submit().await;\n            assert!(result.is_ok(), \"second delegate call failed.\");\n\n            // then\n            let expected_value = 4;\n            let call_builder = contract.call_builder::<Delegator>();\n\n            let call_get = call_builder.get_counter();\n            let call_get_result = client\n                .call(&origin, &call_get)\n                .dry_run()\n                .await?\n                .return_value();\n\n            // This fails\n            assert_eq!(\n                call_get_result, expected_value,\n                \"Decoded an unexpected value from the call.\"\n            );\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn e2e_mapping_mutated<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            let origin = client\n                .create_and_fund_account(&ink_e2e::alice(), 10_000_000_000_000)\n                .await;\n\n            let code_hash = client\n                .upload(\"delegatee\", &origin)\n                .submit()\n                .await\n                .expect(\"upload `delegatee` failed\")\n                .code_hash;\n\n            // given\n            let mut constructor = DelegatorRef::new(10, code_hash);\n            let contract = client\n                .instantiate(\"delegator\", &origin, &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Delegator>();\n\n            // when\n            let call_delegate = call_builder.add_entry_delegate();\n            let result = client.call(&origin, &call_delegate).submit().await;\n            assert!(result.is_ok(), \"delegate call failed.\");\n\n            // then\n\n            // because we initialize the counter with `10` we expect this value be\n            // assigned to Alice.\n            let expected_value = 10;\n            // Alice's address\n            let address = AccountId::from(origin.public_key().to_account_id().0);\n\n            let call_get_value = call_builder.get_value(address);\n            let call_get_result = client\n                .call(&origin, &call_get_value)\n                .submit()\n                .await\n                .unwrap()\n                .return_value();\n\n            assert_eq!(\n                call_get_result,\n                (address, Some(expected_value)),\n                \"Decoded an unexpected value from the call.\"\n            );\n\n            Ok(())\n        }\n\n        #[ink_e2e::test]\n        async fn update_delegate<Client: E2EBackend>(\n            mut client: Client,\n        ) -> E2EResult<()> {\n            // given\n            let origin = client\n                .create_and_fund_account(&ink_e2e::alice(), 10_000_000_000_000)\n                .await;\n\n            let code_hash = client\n                .upload(\"delegatee\", &origin)\n                .submit()\n                .await\n                .expect(\"upload `delegatee` failed\")\n                .code_hash;\n\n            let code_hash2 = client\n                .upload(\"delegatee2\", &origin)\n                .submit()\n                .await\n                .expect(\"upload `delegatee2` failed\")\n                .code_hash;\n\n            let mut constructor = DelegatorRef::new(10, code_hash);\n            let contract = client\n                .instantiate(\"delegator\", &origin, &mut constructor)\n                .submit()\n                .await\n                .expect(\"instantiate failed\");\n            let mut call_builder = contract.call_builder::<Delegator>();\n\n            // when\n            let call_delegate = call_builder.update_delegate_to(code_hash2);\n            let result = client.call(&origin, &call_delegate).submit().await;\n            assert!(result.is_ok(), \"update_delegate_to failed.\");\n\n            // then\n\n            // remove the original delegatee code.\n            // should succeed because the delegate dependency has been removed.\n            let original_code_removed =\n                client.remove_code(&origin, code_hash).submit().await;\n            assert!(original_code_removed.is_ok());\n\n            // attempt to remove the new delegatee code.\n            // should fail because of the delegate dependency.\n            let new_code_removed = client.remove_code(&origin, code_hash2).submit().await;\n            assert!(new_code_removed.is_err());\n\n            Ok(())\n        }\n    }\n}\n"
      },
      {
        "name": "trait-erc20",
        "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod erc20 {\n    use ink::storage::Mapping;\n\n    /// The ERC-20 error types.\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        /// Returned if not enough balance to fulfill a request is available.\n        InsufficientBalance,\n        /// Returned if not enough allowance to fulfill a request is available.\n        InsufficientAllowance,\n    }\n\n    /// The ERC-20 result type.\n    pub type Result<T> = core::result::Result<T, Error>;\n\n    /// Trait implemented by all ERC-20 respecting smart contracts.\n    #[ink::trait_definition]\n    pub trait BaseErc20 {\n        /// Returns the total token supply.\n        #[ink(message)]\n        fn total_supply(&self) -> Balance;\n\n        /// Returns the account balance for the specified `owner`.\n        #[ink(message)]\n        fn balance_of(&self, owner: AccountId) -> Balance;\n\n        /// Returns the amount which `spender` is still allowed to withdraw from `owner`.\n        #[ink(message)]\n        fn allowance(&self, owner: AccountId, spender: AccountId) -> Balance;\n\n        /// Transfers `value` amount of tokens from the caller's account to account `to`.\n        #[ink(message)]\n        fn transfer(&mut self, to: AccountId, value: Balance) -> Result<()>;\n\n        /// Allows `spender` to withdraw from the caller's account multiple times, up to\n        /// the `value` amount.\n        #[ink(message)]\n        fn approve(&mut self, spender: AccountId, value: Balance) -> Result<()>;\n\n        /// Transfers `value` tokens on the behalf of `from` to the account `to`.\n        #[ink(message)]\n        fn transfer_from(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            value: Balance,\n        ) -> Result<()>;\n    }\n\n    /// A simple ERC-20 contract.\n    #[ink(storage)]\n    #[derive(Default)]\n    pub struct Erc20 {\n        /// Total token supply.\n        total_supply: Balance,\n        /// Mapping from owner to number of owned token.\n        balances: Mapping<AccountId, Balance>,\n        /// Mapping of the token amount which an account is allowed to withdraw\n        /// from another account.\n        allowances: Mapping<(AccountId, AccountId), Balance>,\n    }\n\n    /// Event emitted when a token transfer occurs.\n    #[ink(event)]\n    pub struct Transfer {\n        #[ink(topic)]\n        from: Option<AccountId>,\n        #[ink(topic)]\n        to: Option<AccountId>,\n        #[ink(topic)]\n        value: Balance,\n    }\n\n    /// Event emitted when an approval occurs that `spender` is allowed to withdraw\n    /// up to the amount of `value` tokens from `owner`.\n    #[ink(event)]\n    pub struct Approval {\n        #[ink(topic)]\n        owner: AccountId,\n        #[ink(topic)]\n        spender: AccountId,\n        #[ink(topic)]\n        value: Balance,\n    }\n\n    impl Erc20 {\n        /// Creates a new ERC-20 contract with the specified initial supply.\n        #[ink(constructor)]\n        pub fn new(total_supply: Balance) -> Self {\n            let mut balances = Mapping::default();\n            let caller = Self::env().caller();\n            balances.insert(caller, &total_supply);\n            Self::env().emit_event(Transfer {\n                from: None,\n                to: Some(caller),\n                value: total_supply,\n            });\n            Self {\n                total_supply,\n                balances,\n                allowances: Default::default(),\n            }\n        }\n    }\n\n    impl BaseErc20 for Erc20 {\n        /// Returns the total token supply.\n        #[ink(message)]\n        fn total_supply(&self) -> Balance {\n            self.total_supply\n        }\n\n        /// Returns the account balance for the specified `owner`.\n        ///\n        /// Returns `0` if the account is non-existent.\n        #[ink(message)]\n        fn balance_of(&self, owner: AccountId) -> Balance {\n            self.balance_of_impl(&owner)\n        }\n\n        /// Returns the amount which `spender` is still allowed to withdraw from `owner`.\n        ///\n        /// Returns `0` if no allowance has been set.\n        #[ink(message)]\n        fn allowance(&self, owner: AccountId, spender: AccountId) -> Balance {\n            self.allowance_impl(&owner, &spender)\n        }\n\n        /// Transfers `value` amount of tokens from the caller's account to account `to`.\n        ///\n        /// On success a `Transfer` event is emitted.\n        ///\n        /// # Errors\n        ///\n        /// Returns `InsufficientBalance` error if there are not enough tokens on\n        /// the caller's account balance.\n        #[ink(message)]\n        fn transfer(&mut self, to: AccountId, value: Balance) -> Result<()> {\n            let from = self.env().caller();\n            self.transfer_from_to(&from, &to, value)\n        }\n\n        /// Allows `spender` to withdraw from the caller's account multiple times, up to\n        /// the `value` amount.\n        ///\n        /// If this function is called again it overwrites the current allowance with\n        /// `value`.\n        ///\n        /// An `Approval` event is emitted.\n        #[ink(message)]\n        fn approve(&mut self, spender: AccountId, value: Balance) -> Result<()> {\n            let owner = self.env().caller();\n            self.allowances.insert((&owner, &spender), &value);\n            self.env().emit_event(Approval {\n                owner,\n                spender,\n                value,\n            });\n            Ok(())\n        }\n\n        /// Transfers `value` tokens on the behalf of `from` to the account `to`.\n        ///\n        /// This can be used to allow a contract to transfer tokens on ones behalf and/or\n        /// to charge fees in sub-currencies, for example.\n        ///\n        /// On success a `Transfer` event is emitted.\n        ///\n        /// # Errors\n        ///\n        /// Returns `InsufficientAllowance` error if there are not enough tokens allowed\n        /// for the caller to withdraw from `from`.\n        ///\n        /// Returns `InsufficientBalance` error if there are not enough tokens on\n        /// the account balance of `from`.\n        #[ink(message)]\n        fn transfer_from(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            value: Balance,\n        ) -> Result<()> {\n            let caller = self.env().caller();\n            let allowance = self.allowance_impl(&from, &caller);\n            if allowance < value {\n                return Err(Error::InsufficientAllowance)\n            }\n            self.transfer_from_to(&from, &to, value)?;\n            // We checked that allowance >= value\n            #[allow(clippy::arithmetic_side_effects)]\n            self.allowances\n                .insert((&from, &caller), &(allowance - value));\n            Ok(())\n        }\n    }\n\n    #[ink(impl)]\n    impl Erc20 {\n        /// Returns the account balance for the specified `owner`.\n        ///\n        /// Returns `0` if the account is non-existent.\n        ///\n        /// # Note\n        ///\n        /// Prefer to call this method over `balance_of` since this\n        /// works using references which are more efficient in Wasm.\n        #[inline]\n        fn balance_of_impl(&self, owner: &AccountId) -> Balance {\n            self.balances.get(owner).unwrap_or_default()\n        }\n\n        /// Returns the amount which `spender` is still allowed to withdraw from `owner`.\n        ///\n        /// Returns `0` if no allowance has been set.\n        ///\n        /// # Note\n        ///\n        /// Prefer to call this method over `allowance` since this\n        /// works using references which are more efficient in Wasm.\n        #[inline]\n        fn allowance_impl(&self, owner: &AccountId, spender: &AccountId) -> Balance {\n            self.allowances.get((owner, spender)).unwrap_or_default()\n        }\n\n        /// Transfers `value` amount of tokens from the caller's account to account `to`.\n        ///\n        /// On success a `Transfer` event is emitted.\n        ///\n        /// # Errors\n        ///\n        /// Returns `InsufficientBalance` error if there are not enough tokens on\n        /// the caller's account balance.\n        fn transfer_from_to(\n            &mut self,\n            from: &AccountId,\n            to: &AccountId,\n            value: Balance,\n        ) -> Result<()> {\n            let from_balance = self.balance_of_impl(from);\n            if from_balance < value {\n                return Err(Error::InsufficientBalance)\n            }\n            // We checked that from_balance >= value\n            #[allow(clippy::arithmetic_side_effects)]\n            self.balances.insert(from, &(from_balance - value));\n            let to_balance = self.balance_of_impl(to);\n            self.balances\n                .insert(to, &(to_balance.checked_add(value).unwrap()));\n            self.env().emit_event(Transfer {\n                from: Some(*from),\n                to: Some(*to),\n                value,\n            });\n            Ok(())\n        }\n    }\n\n    /// Unit tests.\n    #[cfg(test)]\n    mod tests {\n        /// Imports all the definitions from the outer scope so we can use them here.\n        use super::*;\n        use ink::{\n            env::hash::{\n                Blake2x256,\n                CryptoHash,\n                HashOutput,\n            },\n            primitives::Clear,\n        };\n\n        fn assert_transfer_event(\n            event: &ink::env::test::EmittedEvent,\n            expected_from: Option<AccountId>,\n            expected_to: Option<AccountId>,\n            expected_value: Balance,\n        ) {\n            let decoded_event =\n                <Transfer as ink::scale::Decode>::decode(&mut &event.data[..])\n                    .expect(\"encountered invalid contract event data buffer\");\n            let Transfer { from, to, value } = decoded_event;\n            assert_eq!(from, expected_from, \"encountered invalid Transfer.from\");\n            assert_eq!(to, expected_to, \"encountered invalid Transfer.to\");\n            assert_eq!(value, expected_value, \"encountered invalid Trasfer.value\");\n\n            fn encoded_into_hash<T>(entity: T) -> Hash\n            where\n                T: ink::scale::Encode,\n            {\n                let mut result = Hash::CLEAR_HASH;\n                let len_result = result.as_ref().len();\n                let encoded = entity.encode();\n                let len_encoded = encoded.len();\n                if len_encoded <= len_result {\n                    result.as_mut()[..len_encoded].copy_from_slice(&encoded);\n                    return result\n                }\n                let mut hash_output =\n                    <<Blake2x256 as HashOutput>::Type as Default>::default();\n                <Blake2x256 as CryptoHash>::hash(&encoded, &mut hash_output);\n                let copy_len = core::cmp::min(hash_output.len(), len_result);\n                result.as_mut()[0..copy_len].copy_from_slice(&hash_output[0..copy_len]);\n                result\n            }\n\n            let mut expected_topics = Vec::new();\n            expected_topics.push(\n                ink::blake2x256!(\"Transfer(Option<AccountId>,Option<AccountId>,Balance)\")\n                    .into(),\n            );\n            if let Some(from) = expected_from {\n                expected_topics.push(encoded_into_hash(from));\n            } else {\n                expected_topics.push(Hash::CLEAR_HASH);\n            }\n            if let Some(to) = expected_to {\n                expected_topics.push(encoded_into_hash(to));\n            } else {\n                expected_topics.push(Hash::CLEAR_HASH);\n            }\n            expected_topics.push(encoded_into_hash(value));\n\n            for (n, (actual_topic, expected_topic)) in\n                event.topics.iter().zip(expected_topics).enumerate()\n            {\n                let topic = <Hash as ink::scale::Decode>::decode(&mut &actual_topic[..])\n                    .expect(\"encountered invalid topic encoding\");\n                assert_eq!(topic, expected_topic, \"encountered invalid topic at {n}\");\n            }\n        }\n\n        /// The default constructor does its job.\n        #[ink::test]\n        fn new_works() {\n            // Constructor works.\n            let initial_supply = 100;\n            let erc20 = Erc20::new(initial_supply);\n\n            // The `BaseErc20` trait has indeed been implemented.\n            assert_eq!(<Erc20 as BaseErc20>::total_supply(&erc20), initial_supply);\n\n            // Transfer event triggered during initial construction.\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(1, emitted_events.len());\n\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n        }\n\n        /// The total supply was applied.\n        #[ink::test]\n        fn total_supply_works() {\n            // Constructor works.\n            let initial_supply = 100;\n            let erc20 = Erc20::new(initial_supply);\n            // Transfer event triggered during initial construction.\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n            // Get the token total supply.\n            assert_eq!(erc20.total_supply(), 100);\n        }\n\n        /// Get the actual balance of an account.\n        #[ink::test]\n        fn balance_of_works() {\n            // Constructor works\n            let initial_supply = 100;\n            let erc20 = Erc20::new(initial_supply);\n            // Transfer event triggered during initial construction\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n            // Alice owns all the tokens on contract instantiation\n            assert_eq!(erc20.balance_of(accounts.alice), 100);\n            // Bob does not owns tokens\n            assert_eq!(erc20.balance_of(accounts.bob), 0);\n        }\n\n        #[ink::test]\n        fn transfer_works() {\n            // Constructor works.\n            let initial_supply = 100;\n            let mut erc20 = Erc20::new(initial_supply);\n            // Transfer event triggered during initial construction.\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n\n            assert_eq!(erc20.balance_of(accounts.bob), 0);\n            // Alice transfers 10 tokens to Bob.\n            assert_eq!(erc20.transfer(accounts.bob, 10), Ok(()));\n            // Bob owns 10 tokens.\n            assert_eq!(erc20.balance_of(accounts.bob), 10);\n\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(emitted_events.len(), 2);\n            // Check first transfer event related to ERC-20 instantiation.\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n            // Check the second transfer event relating to the actual trasfer.\n            assert_transfer_event(\n                &emitted_events[1],\n                Some(AccountId::from([0x01; 32])),\n                Some(AccountId::from([0x02; 32])),\n                10,\n            );\n        }\n\n        #[ink::test]\n        fn invalid_transfer_should_fail() {\n            // Constructor works.\n            let initial_supply = 100;\n            let mut erc20 = Erc20::new(initial_supply);\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n\n            assert_eq!(erc20.balance_of(accounts.bob), 0);\n            // Set Bob as caller\n            set_caller(accounts.bob);\n\n            // Bob fails to transfers 10 tokens to Eve.\n            assert_eq!(\n                erc20.transfer(accounts.eve, 10),\n                Err(Error::InsufficientBalance)\n            );\n            // Alice owns all the tokens.\n            assert_eq!(erc20.balance_of(accounts.alice), 100);\n            assert_eq!(erc20.balance_of(accounts.bob), 0);\n            assert_eq!(erc20.balance_of(accounts.eve), 0);\n\n            // Transfer event triggered during initial construction.\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(emitted_events.len(), 1);\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n        }\n\n        #[ink::test]\n        fn transfer_from_works() {\n            // Constructor works.\n            let initial_supply = 100;\n            let mut erc20 = Erc20::new(initial_supply);\n            // Transfer event triggered during initial construction.\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n\n            // Bob fails to transfer tokens owned by Alice.\n            assert_eq!(\n                erc20.transfer_from(accounts.alice, accounts.eve, 10),\n                Err(Error::InsufficientAllowance)\n            );\n            // Alice approves Bob for token transfers on her behalf.\n            assert_eq!(erc20.approve(accounts.bob, 10), Ok(()));\n\n            // The approve event takes place.\n            assert_eq!(ink::env::test::recorded_events().count(), 2);\n\n            // Set Bob as caller.\n            set_caller(accounts.bob);\n\n            // Bob transfers tokens from Alice to Eve.\n            assert_eq!(\n                erc20.transfer_from(accounts.alice, accounts.eve, 10),\n                Ok(())\n            );\n            // Eve owns tokens.\n            assert_eq!(erc20.balance_of(accounts.eve), 10);\n\n            // Check all transfer events that happened during the previous calls:\n            let emitted_events = ink::env::test::recorded_events().collect::<Vec<_>>();\n            assert_eq!(emitted_events.len(), 3);\n            assert_transfer_event(\n                &emitted_events[0],\n                None,\n                Some(AccountId::from([0x01; 32])),\n                100,\n            );\n            // The second event `emitted_events[1]` is an Approve event that we skip\n            // checking.\n            assert_transfer_event(\n                &emitted_events[2],\n                Some(AccountId::from([0x01; 32])),\n                Some(AccountId::from([0x05; 32])),\n                10,\n            );\n        }\n\n        #[ink::test]\n        fn allowance_must_not_change_on_failed_transfer() {\n            let initial_supply = 100;\n            let mut erc20 = Erc20::new(initial_supply);\n            let accounts =\n                ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();\n\n            // Alice approves Bob for token transfers on her behalf.\n            let alice_balance = erc20.balance_of(accounts.alice);\n            let initial_allowance = alice_balance + 2;\n            assert_eq!(erc20.approve(accounts.bob, initial_allowance), Ok(()));\n\n            // Set Bob as caller.\n            set_caller(accounts.bob);\n\n            // Bob tries to transfer tokens from Alice to Eve.\n            let emitted_events_before = ink::env::test::recorded_events();\n            assert_eq!(\n                erc20.transfer_from(accounts.alice, accounts.eve, alice_balance + 1),\n                Err(Error::InsufficientBalance)\n            );\n            // Allowance must have stayed the same\n            assert_eq!(\n                erc20.allowance(accounts.alice, accounts.bob),\n                initial_allowance\n            );\n            // No more events must have been emitted\n            let emitted_events_after = ink::env::test::recorded_events();\n            assert_eq!(emitted_events_before.count(), emitted_events_after.count());\n        }\n\n        fn set_caller(sender: AccountId) {\n            ink::env::test::set_caller::<Environment>(sender);\n        }\n    }\n}\n"
      },
      {
        "name": "dns",
        "code": "#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\n#[ink::contract]\nmod dns {\n    use ink::storage::Mapping;\n\n    /// Emitted whenever a new name is being registered.\n    #[ink(event)]\n    pub struct Register {\n        #[ink(topic)]\n        name: Hash,\n        #[ink(topic)]\n        from: AccountId,\n    }\n\n    /// Emitted whenever an address changes.\n    #[ink(event)]\n    pub struct SetAddress {\n        #[ink(topic)]\n        name: Hash,\n        from: AccountId,\n        #[ink(topic)]\n        old_address: Option<AccountId>,\n        #[ink(topic)]\n        new_address: AccountId,\n    }\n\n    /// Emitted whenever a name is being transferred.\n    #[ink(event)]\n    pub struct Transfer {\n        #[ink(topic)]\n        name: Hash,\n        from: AccountId,\n        #[ink(topic)]\n        old_owner: Option<AccountId>,\n        #[ink(topic)]\n        new_owner: AccountId,\n    }\n\n    /// Domain name service contract inspired by\n    /// [this blog post](https://medium.com/@chainx_org/secure-and-decentralized-polkadot-domain-name-system-e06c35c2a48d).\n    ///\n    /// # Note\n    ///\n    /// This is a port from the blog post's ink! 1.0 based version of the contract\n    /// to ink! 2.0.\n    ///\n    /// # Description\n    ///\n    /// The main function of this contract is domain name resolution which\n    /// refers to the retrieval of numeric values corresponding to readable\n    /// and easily memorable names such as \"polka.dot\" which can be used\n    /// to facilitate transfers, voting and DApp-related operations instead\n    /// of resorting to long IP addresses that are hard to remember.\n    #[ink(storage)]\n    pub struct DomainNameService {\n        /// A hashmap to store all name to addresses mapping.\n        name_to_address: Mapping<Hash, AccountId>,\n        /// A hashmap to store all name to owners mapping.\n        name_to_owner: Mapping<Hash, AccountId>,\n        /// The default address.\n        default_address: AccountId,\n    }\n\n    impl Default for DomainNameService {\n        fn default() -> Self {\n            let mut name_to_address = Mapping::new();\n            name_to_address.insert(Hash::default(), &zero_address());\n            let mut name_to_owner = Mapping::new();\n            name_to_owner.insert(Hash::default(), &zero_address());\n\n            Self {\n                name_to_address,\n                name_to_owner,\n                default_address: zero_address(),\n            }\n        }\n    }\n\n    /// Errors that can occur upon calling this contract.\n    #[derive(Debug, PartialEq, Eq)]\n    #[ink::scale_derive(Encode, Decode, TypeInfo)]\n    pub enum Error {\n        /// Returned if the name already exists upon registration.\n        NameAlreadyExists,\n        /// Returned if caller is not owner while required to.\n        CallerIsNotOwner,\n    }\n\n    /// Type alias for the contract's result type.\n    pub type Result<T> = core::result::Result<T, Error>;\n\n    impl DomainNameService {\n        /// Creates a new domain name service contract.\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Default::default()\n        }\n\n        /// Register specific name with caller as owner.\n        #[ink(message)]\n        pub fn register(&mut self, name: Hash) -> Result<()> {\n            let caller = self.env().caller();\n            if self.name_to_owner.contains(name) {\n                return Err(Error::NameAlreadyExists)\n            }\n\n            self.name_to_owner.insert(name, &caller);\n            self.env().emit_event(Register { name, from: caller });\n\n            Ok(())\n        }\n\n        /// Set address for specific name.\n        #[ink(message)]\n        pub fn set_address(&mut self, name: Hash, new_address: AccountId) -> Result<()> {\n            let caller = self.env().caller();\n            let owner = self.get_owner_or_default(name);\n            if caller != owner {\n                return Err(Error::CallerIsNotOwner)\n            }\n\n            let old_address = self.name_to_address.get(name);\n            self.name_to_address.insert(name, &new_address);\n\n            self.env().emit_event(SetAddress {\n                name,\n                from: caller,\n                old_address,\n                new_address,\n            });\n            Ok(())\n        }\n\n        /// Transfer owner to another address.\n        #[ink(message)]\n        pub fn transfer(&mut self, name: Hash, to: AccountId) -> Result<()> {\n            let caller = self.env().caller();\n            let owner = self.get_owner_or_default(name);\n            if caller != owner {\n                return Err(Error::CallerIsNotOwner)\n            }\n\n            let old_owner = self.name_to_owner.get(name);\n            self.name_to_owner.insert(name, &to);\n\n            self.env().emit_event(Transfer {\n                name,\n                from: caller,\n                old_owner,\n                new_owner: to,\n            });\n\n            Ok(())\n        }\n\n        /// Get address for specific name.\n        #[ink(message)]\n        pub fn get_address(&self, name: Hash) -> AccountId {\n            self.get_address_or_default(name)\n        }\n\n        /// Get owner of specific name.\n        #[ink(message)]\n        pub fn get_owner(&self, name: Hash) -> AccountId {\n            self.get_owner_or_default(name)\n        }\n\n        /// Returns the owner given the hash or the default address.\n        fn get_owner_or_default(&self, name: Hash) -> AccountId {\n            self.name_to_owner.get(name).unwrap_or(self.default_address)\n        }\n\n        /// Returns the address given the hash or the default address.\n        fn get_address_or_default(&self, name: Hash) -> AccountId {\n            self.name_to_address\n                .get(name)\n                .unwrap_or(self.default_address)\n        }\n    }\n\n    /// Helper for referencing the zero address (`0x00`). Note that in practice this\n    /// address should not be treated in any special way (such as a default\n    /// placeholder) since it has a known private key.\n    fn zero_address() -> AccountId {\n        [0u8; 32].into()\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        fn default_accounts(\n        ) -> ink::env::test::DefaultAccounts<ink::env::DefaultEnvironment> {\n            ink::env::test::default_accounts::<Environment>()\n        }\n\n        fn set_next_caller(caller: AccountId) {\n            ink::env::test::set_caller::<Environment>(caller);\n        }\n\n        #[ink::test]\n        fn register_works() {\n            let default_accounts = default_accounts();\n            let name = Hash::from([0x99; 32]);\n\n            set_next_caller(default_accounts.alice);\n            let mut contract = DomainNameService::new();\n\n            assert_eq!(contract.register(name), Ok(()));\n            assert_eq!(contract.register(name), Err(Error::NameAlreadyExists));\n        }\n\n        #[ink::test]\n        fn set_address_works() {\n            let accounts = default_accounts();\n            let name = Hash::from([0x99; 32]);\n\n            set_next_caller(accounts.alice);\n\n            let mut contract = DomainNameService::new();\n            assert_eq!(contract.register(name), Ok(()));\n\n            // Caller is not owner, `set_address` should fail.\n            set_next_caller(accounts.bob);\n            assert_eq!(\n                contract.set_address(name, accounts.bob),\n                Err(Error::CallerIsNotOwner)\n            );\n\n            // Caller is owner, set_address will be successful\n            set_next_caller(accounts.alice);\n            assert_eq!(contract.set_address(name, accounts.bob), Ok(()));\n            assert_eq!(contract.get_address(name), accounts.bob);\n        }\n\n        #[ink::test]\n        fn transfer_works() {\n            let accounts = default_accounts();\n            let name = Hash::from([0x99; 32]);\n\n            set_next_caller(accounts.alice);\n\n            let mut contract = DomainNameService::new();\n            assert_eq!(contract.register(name), Ok(()));\n\n            // Test transfer of owner.\n            assert_eq!(contract.transfer(name, accounts.bob), Ok(()));\n\n            // Owner is bob, alice `set_address` should fail.\n            assert_eq!(\n                contract.set_address(name, accounts.bob),\n                Err(Error::CallerIsNotOwner)\n            );\n\n            set_next_caller(accounts.bob);\n            // Now owner is bob, `set_address` should be successful.\n            assert_eq!(contract.set_address(name, accounts.bob), Ok(()));\n            assert_eq!(contract.get_address(name), accounts.bob);\n        }\n    }\n}\n"
      }
    ],
    "totalContracts": 9,
    "description": "A collection of specific ink! smart contract examples"
  }