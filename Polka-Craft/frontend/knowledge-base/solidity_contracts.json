[
  {
    "contract name": "pragma",
    "contract data": "// SPDX-License-Identifier: MIT\n//\n// https://cryptomarketpool.com/simple-contract\n\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    string private name;\n    uint256 private age;\n\n    function setName(string memory _name) public {\n        name = _name;\n    }\n\n    function getName() public view returns (string memory) {\n        return name;\n    }\n\n    function setAge(uint256 _age) public {\n        age = _age;\n    }\n\n    function getAge() public view returns (uint256) {\n        return age;\n    }\n}\n"
  },
  {
    "contract name": "AddressBook",
    "contract data": "// SPDX-License-Identifier: MIT\n//\n// https://cryptomarketpool.com/address-book\n\npragma solidity ^0.8.0;\n\ncontract AddressBook {\n    mapping(address => address[]) private contacts;\n    mapping(address => mapping(address => string)) private aliases;\n\n    function getContacts() public view returns (address[] memory) {\n        return contacts[msg.sender];\n    }\n\n    function addContact(address contactAddress, string memory aliasName) public {\n        contacts[msg.sender].push(contactAddress);\n        aliases[msg.sender][contactAddress] = aliasName;\n    }\n\n    function getAlias(address contactAddress) public view returns (string memory) {\n        return aliases[msg.sender][contactAddress];\n    }\n\n    function removeContact(address contactAddress) public {\n        uint256 length = contacts[msg.sender].length;\n        for (uint256 i = 0; i < length; i++) {\n            if (contactAddress == contacts[msg.sender][i]) {\n                if (contacts[msg.sender].length > 1 && i < length - 1) {\n                    contacts[msg.sender][i] = contacts[msg.sender][length - 1];\n                }\n\n                contacts[msg.sender].pop();\n\n                delete aliases[msg.sender][contactAddress];\n                break;\n            }\n        }\n    }\n}\n"
  },
  {
    "contract name": "pragma",
    "contract data": "// SPDX-License-Identifier: MIT\n//\n// https://cryptomarketpool.com/hotel-contract\n\npragma solidity ^0.8.0;\n\n// The sample hotel and vending Solidity smart contract below allows one to rent a hotel room.\n// It allows someone to make a payment for a room if the room is vacant. After payment is made to the contract the funds are sent to the owner.\n// This smart contract can be expanded to unlock the door or dispense a key code after payment is made.\n//\n// Think of this contract like a vending machine. You input funds, validations pass, and you get something in return.\n// It is the same concept as a gumball machine.\n\ncontract HotelRoom {\n    //create an emun with 2 status so we can keep track of our hotel room\n    enum Statuses {\n        Vacant,\n        Occupied\n    }\n    Statuses currentStatus;\n\n    //create an event for others that want to subscribe to events like a smart lock to unlock the door\n    event Occupy(address _occupant, uint256 _value);\n\n    address payable public owner;\n\n    constructor() {\n        owner = payable(msg.sender);\n        currentStatus = Statuses.Vacant;\n    }\n\n    modifier onlyWhileVacant() {\n        require(currentStatus == Statuses.Vacant, \"Currently Occupied\");\n        _;\n    }\n\n    modifier costs(uint256 _amount) {\n        require(msg.value >= _amount, \"Not enough Ether provided\");\n        _;\n    }\n\n    receive() external payable onlyWhileVacant costs(2 ether) {\n        currentStatus = Statuses.Occupied;\n        owner.transfer(msg.value);\n        emit Occupy(msg.sender, msg.value);\n    }\n}\n"
  },
  {
    "contract name": "pragma",
    "contract data": "// SPDX-License-Identifier: MIT\n//\n// https://cryptomarketpool.com/time-lock-contract\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n// The time lock Solidity smart contract below demonstrates how to use the passing of time in a Solidity smart contract.\n// Think of this contract like a weekly allowance or escrow that needs to pay out weekly.\n//\n// overflow and underflow examples and preventions\n// one can deposit ether into this contract but you must wait 1 week before you can withdraw your funds\n\ncontract Timelock {\n    // calling SafeMath will add extra functions to the uint data type\n    using SafeMath for uint256; // you can make a call like myUint.add(123)\n\n    // amount of ether you deposited is saved in balances\n    mapping(address => uint256) public balances;\n\n    // when you can withdraw is saved in lockTime\n    mapping(address => uint256) public lockTime;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        lockTime[msg.sender] = block.timestamp + 1 weeks;\n    }\n\n    // the function that is commented out is vulnerable to overflow by updating the function below with a very large number\n    // to prevent this use safe math to prevent overflow\n    // function increaseLockTime(uint _secondsToIncrease) public {\n    //     lockTime[msg.sender] += _secondsToIncrease;\n    // }\n\n    function increaseLockTime(uint256 _secondsToIncrease) public {\n        // the add function below is from safemath and will take care of uint overflow\n        // if a call to add causes an error an error will be thrown and the call to the function will fail\n        lockTime[msg.sender] = lockTime[msg.sender].add(_secondsToIncrease);\n    }\n\n    function withdraw() public {\n        // check that the sender has ether deposited in this contract in the mapping and the balance is >0\n        require(balances[msg.sender] > 0, \"insufficient funds\");\n\n        // check that the now time is > the time saved in the lock time mapping\n        require(block.timestamp > lockTime[msg.sender], \"lock time has not expired\");\n\n        uint256 amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Failed to send ether\");\n    }\n}\n"
  },
  {
    "contract name": "MyERC20Token",
    "contract data": "// SPDX-License-Identifier: MIT\n//\n// https://cryptomarketpool.com/erc20-token-solidity-smart-contract/\n\npragma solidity ^0.8.0;\n\ninterface ERC20 {\n    function totalSupply() external pure returns (uint256 _totalSupply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _sender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract MyERC20Token is ERC20 {\n    string public constant symbol = \"MET\";\n    string public constant name = \"My ERC20 Token\";\n    uint8 public constant decimals = 18;\n\n    // 1,000,000 + 18 zeros\n    uint256 private constant __totalSupply = 1000000000000000000000000;\n\n    // this mapping is where we store the balances of an address\n    mapping(address => uint256) private __balanceOf;\n\n    // This is for the approval function to determine how much an address can spend\n    mapping(address => mapping(address => uint256)) private __allowances;\n\n    constructor() {\n        __balanceOf[msg.sender] = __totalSupply; //the creator of the contract has the total supply and no one can create tokens\n    }\n\n    // constant value that does not change/  returns the amount of initial tokens to display\n    function totalSupply() public pure override returns (uint256) {\n        return __totalSupply;\n    }\n\n    // returns the balance of a specific address\n    function balanceOf(address _address) public view override returns (uint256) {\n        return __balanceOf[_address];\n    }\n\n    // Transfer an amount of tokens to another address.\n    // Pre-checks:\n    //   - The transfer needs to be > 0\n    //   - does the msg.sender have enough tokens to forfill the transfer\n    // Output:\n    //   - decrease the balance of the sender\n    //   - increase the balance of the to address\n    //   - Emit transfer event\n    function transfer(address _to, uint256 _value) public override returns (bool) {\n        if (_value > 0 && _value <= balanceOf(msg.sender)) {\n            __balanceOf[msg.sender] -= _value;\n            __balanceOf[_to] += _value;\n            emit Transfer(msg.sender, _to, _value);\n            return true;\n        }\n\n        return false;\n    }\n\n    // this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\n    // Pre-checks:\n    //   - The transfer needs to be > 0\n    //   - and the 3rd party has an allowance of > 0\n    //   - and the allowance is >= the value of the transfer\n    //   - and it is not a contract\n    // Output:\n    //   - decrease the balance of the from account\n    //   - increase the balance of the to account\n    //   - Emit transfer event\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public override returns (bool) {\n        if (\n            _value > 0 &&\n            __allowances[_from][msg.sender] > 0 &&\n            __allowances[_from][msg.sender] >= _value &&\n            !isContract(_to)\n        ) {\n            __balanceOf[_from] -= _value;\n            __balanceOf[_to] += _value;\n            emit Transfer(_from, _to, _value);\n            return true;\n        }\n\n        return false;\n    }\n\n    // This check is to determine if we are sending to a contract?\n    // Is there code at this address?  If the code size is greater then 0 then it is a contract.\n    function isContract(address _address) public view returns (bool) {\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(_address)\n        }\n\n        return codeSize > 0;\n    }\n\n    // allows a spender address to spend a specific amount of value\n    function approve(address _spender, uint256 _value) external override returns (bool) {\n        __allowances[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    // shows how much a spender has the approval to spend to a specific address\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\n        return __allowances[_owner][_spender];\n    }\n}\n"
  },
  {
    "contract name": "SharedWallet",
    "contract data": "// SPDX-License-Identifier: MIT\n//\n// https://cryptomarketpool.com/shared-wallet-solidity-smart-contract/\n\npragma solidity ^0.8.0;\n\ncontract SharedWallet {\n    address private _owner;\n\n    // list of shared owners. bool is used to determine is the address enabled of disabled\n    mapping(address => bool) private _owners;\n\n    // required owner of the contract\n    modifier isOwner() {\n        require(msg.sender == _owner, \"Not contract owner\");\n        _;\n    }\n\n    // required to be valid either contract owner or enabled owner of shared wallet\n    modifier validOwner() {\n        require(msg.sender == _owner || _owners[msg.sender], \"Not contract owner or owners of shared wallet\");\n        _;\n    }\n\n    event DepositFunds(address from, uint256 amount);\n    event WithdrawFunds(address from, uint256 amount);\n    event TransferFunds(address from, address to, uint256 amount);\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    // add an owner of shared wallet\n    function addOwner(address owner) public isOwner {\n        _owners[owner] = true;\n    }\n\n    // remove an owner of shared wallet\n    function removeOwner(address owner) public isOwner {\n        _owners[owner] = false;\n    }\n\n    // receive the deposit into shared wallet (contract's balance)\n    receive() external payable {\n        emit DepositFunds(msg.sender, msg.value);\n    }\n\n    // withdraw fund from the shared wallet into the signer of transaction\n    function withdraw(uint256 amount) public validOwner {\n        require(address(this).balance >= amount);\n        payable(msg.sender).transfer(amount);\n        emit WithdrawFunds(msg.sender, amount);\n    }\n\n    // transfer fund from the shared wallet into another address\n    function transferTo(address payable to, uint256 amount) public validOwner {\n        require(address(this).balance >= amount);\n        payable(to).transfer(amount);\n        emit TransferFunds(msg.sender, to, amount);\n    }\n}\n"
  },
  {
    "contract name": "MyTokenBob",
    "contract data": "// SPDX-License-Identifier: MIT\n//\n// https://cryptomarketpool.com/trustless-token-swap-in-a-solidity-smart-contract/\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MyTokenBob is ERC20 {\n    //when deploying pass in the name and symbol\n\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        //mint 100 tokens to msg.sender\n        //similar to how 1 dollar = 100 cents\n        //1 token = 1 * (10 ** decimals)\n\n        // Mint 100 tokens with 18 decimals\n\n        _mint(msg.sender, 100 * 10**uint256(decimals()));\n    }\n}\n"
  },
  {
    "contract name": "TokenSwap",
    "contract data": "// SPDX-License-Identifier: MIT\n//\n// https://cryptomarketpool.com/trustless-token-swap-in-a-solidity-smart-contract/\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract TokenSwap {\n    IERC20 public token1;\n    IERC20 public token2;\n    address public owner1;\n    address public owner2;\n\n    constructor(\n        address _token1,\n        address _owner1,\n        address _token2,\n        address _owner2\n    ) {\n        token1 = IERC20(_token1);\n        owner1 = _owner1;\n        token2 = IERC20(_token2);\n        owner2 = _owner2;\n    }\n\n    //this function will allow 2 people to trade 2 tokens as the same time (atomic) and swap them between accounts\n    //Bob holds token 1 and needs to send to alice\n    //Alice holds token 2 and needs to send to Bob\n    //this allows them to swap an amount of both tokens at the same time\n\n    //*** Important ***\n    //this contract needs an allowance to send tokens at token 1 and token 2 that is owned by owner 1 and owner 2\n\n    function swap(uint256 _amount1, uint256 _amount2) public {\n        require(msg.sender == owner1 || msg.sender == owner2, \"Not authorized\");\n        require(token1.allowance(owner1, address(this)) >= _amount1, \"Token 1 allowance too low\");\n        require(token2.allowance(owner2, address(this)) >= _amount2, \"Token 2 allowance too low\");\n\n        _safeTransferFrom(token1, owner1, owner2, _amount1);\n        _safeTransferFrom(token2, owner2, owner1, _amount2);\n    }\n\n    function _safeTransferFrom(\n        IERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) private {\n        bool sent = token.transferFrom(sender, recipient, amount);\n        require(sent, \"Token transfer failed\");\n    }\n}\n"
  },
  {
    "contract name": "EthGame",
    "contract data": "// SPDX-License-Identifier: MIT\n//\n// https://cryptomarketpool.com/deposit-14-eth-game-in-a-solidity-smart-contract/\n\npragma solidity ^0.8.0;\n\n// A game where the 14th person that deposit ether wins all the ether in the contract\n// the winner can claim the 14 ether\n\ncontract EthGame {\n    uint256 public targetAmount = 14 ether;\n    address public winner;\n\n    //need to create a balance state variable to prevent forcefully sending ether\n    uint256 public balance;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, \"You can only send 1 Ether\");\n\n        //if the current balance is greater then the targetAmount then the game is over\n        //to prevent forcefully sending eth the balance needs to be updated manually instead of just checking the balance amount\n        //to prevent forcefully sending ether update the balance state variable manually\n        balance += msg.value;\n        require(balance <= targetAmount, \"Game is over\");\n\n        //if the balance is == to the targetAmount when the 14th person sends ether then we set the winner to the message sender\n        if (balance == targetAmount) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, \"Not winner\");\n\n        //this will send all the ether in this contract to the winner\n        (bool sent, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n"
  },
  {
    "contract name": "Ballot",
    "contract data": "// SPDX-License-Identifier: MIT\n//\n// https://docs.soliditylang.org/en/v0.8.15/solidity-by-example.html\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Ballot {\n    // This declares a new complex type which will\n    // be used for variables later.\n    // It will represent a single voter.\n    struct Voter {\n        uint256 weight; // weight is accumulated by delegation\n        bool voted; // if true, that person already voted\n        address delegate; // person delegated to\n        uint256 vote; // index of the voted proposal\n    }\n\n    // This is a type for a single proposal.\n    struct Proposal {\n        bytes32 name; // short name (up to 32 bytes)\n        uint256 voteCount; // number of accumulated votes\n    }\n\n    address public chairperson;\n\n    // This declares a state variable that\n    // stores a `Voter` struct for each possible address.\n    mapping(address => Voter) public voters;\n\n    // A dynamically-sized array of `Proposal` structs.\n    Proposal[] public proposals;\n\n    /// Create a new ballot to choose one of `proposalNames`.\n    constructor(bytes32[] memory proposalNames) {\n        chairperson = msg.sender;\n        voters[chairperson].weight = 1;\n\n        // For each of the provided proposal names,\n        // create a new proposal object and add it\n        // to the end of the array.\n        for (uint256 i = 0; i < proposalNames.length; i++) {\n            // `Proposal({...})` creates a temporary\n            // Proposal object and `proposals.push(...)`\n            // appends it to the end of `proposals`.\n            proposals.push(Proposal({name: proposalNames[i], voteCount: 0}));\n        }\n    }\n\n    // Give `voter` the right to vote on this ballot.\n    // May only be called by `chairperson`.\n    function giveRightToVote(address voter) external {\n        // If the first argument of `require` evaluates\n        // to `false`, execution terminates and all\n        // changes to the state and to Ether balances\n        // are reverted.\n        // This used to consume all gas in old EVM versions, but\n        // not anymore.\n        // It is often a good idea to use `require` to check if\n        // functions are called correctly.\n        // As a second argument, you can also provide an\n        // explanation about what went wrong.\n        require(msg.sender == chairperson, \"Only chairperson can give right to vote.\");\n        require(!voters[voter].voted, \"The voter already voted.\");\n        require(voters[voter].weight == 0);\n        voters[voter].weight = 1;\n    }\n\n    /// Delegate your vote to the voter `to`.\n    function delegate(address to) external {\n        // assigns reference\n        Voter storage sender = voters[msg.sender];\n        require(sender.weight != 0, \"You have no right to vote.\");\n        require(!sender.voted, \"You already voted.\");\n\n        require(to != msg.sender, \"Self-delegation is disallowed.\");\n\n        // Forward the delegation as long as\n        // `to` also delegated.\n        // In general, such loops are very dangerous,\n        // because if they run too long, they might\n        // need more gas than is available in a block.\n        // In this case, the delegation will not be executed,\n        // but in other situations, such loops might\n        // cause a contract to get \"stuck\" completely.\n        while (voters[to].delegate != address(0)) {\n            to = voters[to].delegate;\n\n            // We found a loop in the delegation, not allowed.\n            require(to != msg.sender, \"Found loop in delegation.\");\n        }\n\n        Voter storage delegate_ = voters[to];\n\n        // Voters cannot delegate to accounts that cannot vote.\n        require(delegate_.weight >= 1);\n\n        // Since `sender` is a reference, this\n        // modifies `voters[msg.sender]`.\n        sender.voted = true;\n        sender.delegate = to;\n\n        if (delegate_.voted) {\n            // If the delegate already voted,\n            // directly add to the number of votes\n            proposals[delegate_.vote].voteCount += sender.weight;\n        } else {\n            // If the delegate did not vote yet,\n            // add to her weight.\n            delegate_.weight += sender.weight;\n        }\n    }\n\n    /// Give your vote (including votes delegated to you)\n    /// to proposal `proposals[proposal].name`.\n    function vote(uint256 proposal) external {\n        Voter storage sender = voters[msg.sender];\n        require(sender.weight != 0, \"Has no right to vote.\");\n        require(!sender.voted, \"Already voted.\");\n        sender.voted = true;\n        sender.vote = proposal;\n\n        // If `proposal` is out of the range of the array,\n        // this will throw automatically and revert all\n        // changes.\n        proposals[proposal].voteCount += sender.weight;\n    }\n\n    /// @dev Computes the winning proposal taking all\n    /// previous votes into account.\n    function winningProposal() public view returns (uint256 winningProposal_) {\n        uint256 winningVoteCount = 0;\n        for (uint256 p = 0; p < proposals.length; p++) {\n            if (proposals[p].voteCount > winningVoteCount) {\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }\n        }\n    }\n\n    // Calls winningProposal() function to get the index\n    // of the winner contained in the proposals array and then\n    // returns the name of the winner\n    function winnerName() external view returns (bytes32 winnerName_) {\n        winnerName_ = proposals[winningProposal()].name;\n    }\n}\n"
  },
  {
    "contract name": "Vault",
    "contract data": "// SPDX-License-Identifier: GPL-3.0\n//\n// https://muens.io/how-to-implement-lp-tokens-in-solidity\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Vault is ERC20 {\n    IERC20 public immutable token;\n\n    constructor(IERC20 token_) ERC20(\"Liquidity Provider Token\", \"LP-TKN\") {\n        token = token_;\n    }\n\n    function deposit(uint256 amount) external {\n        require(amount > 0);\n\n        uint256 amountToken = amount;\n        uint256 supplyLPToken = this.totalSupply();\n        uint256 balanceToken = token.balanceOf(address(this));\n\n        uint256 amountLPToken;\n        if (supplyLPToken == 0) {\n            amountLPToken = amountToken;\n        } else {\n            amountLPToken = (amountToken * supplyLPToken) / balanceToken;\n        }\n\n        _mint(msg.sender, amountLPToken);\n        token.transferFrom(msg.sender, address(this), amountToken);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount > 0);\n\n        uint256 amountLPToken = amount;\n        uint256 supplyLPToken = this.totalSupply();\n        uint256 balanceToken = token.balanceOf(address(this));\n\n        uint256 amountToken = (amountLPToken * balanceToken) / supplyLPToken;\n\n        _burn(msg.sender, amountLPToken);\n        token.transfer(msg.sender, amountToken);\n    }\n}\n\ncontract AssetToken is ERC20, Ownable {\n    constructor() ERC20(\"Asset Token\", \"AST\") {}\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n"
  },
  {
    "contract name": "FlashBorrower",
    "contract data": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IERC3156FlashBorrower.sol\";\nimport \"./interfaces/IERC3156FlashLender.sol\";\n\ncontract FlashBorrower is IERC3156FlashBorrower {\n    enum Action {\n        NORMAL,\n        OTHER\n    }\n\n    IERC3156FlashLender lender;\n\n    constructor(IERC3156FlashLender lender_) {\n        lender = lender_;\n    }\n\n    /// @dev ERC-3156 Flash loan callback\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external override returns (bytes32) {\n        require(msg.sender == address(lender), \"FlashBorrower: Untrusted lender\");\n        require(initiator == address(this), \"FlashBorrower: Untrusted loan initiator\");\n\n        // silence warning about unused variable without the addition of bytecode.\n        token;\n        amount;\n        fee;\n\n        // Your logic goes here. Do whatever you want with the tokens\n        //...\n        Action action = abi.decode(data, (Action));\n        if (action == Action.NORMAL) {\n            // do one thing\n        } else if (action == Action.OTHER) {\n            // do another\n        }\n\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n\n    /// @dev Initiate a flash loan\n    function flashBorrow(address token, uint256 amount) public {\n        bytes memory data = abi.encode(Action.NORMAL);\n        uint256 _allowance = IERC20(token).allowance(address(this), address(lender));\n        uint256 _fee = lender.flashFee(token, amount);\n        uint256 _repayment = amount + _fee;\n        IERC20(token).approve(address(lender), _allowance + _repayment);\n        lender.flashLoan(this, token, amount, data);\n    }\n}\n"
  },
  {
    "contract name": "FlashLender",
    "contract data": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IERC3156FlashBorrower.sol\";\nimport \"./interfaces/IERC3156FlashLender.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows flash lending.\n */\ncontract FlashLender is IERC3156FlashLender {\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    mapping(address => bool) public supportedTokens;\n    uint256 public fee; //  1 == 0.01 %\n\n    /**\n     * @param supportedTokens_ Token contracts supported for flash lending.\n     * @param fee_ The percentage of the loan `amount` that needs to be repaid, in addition to `amount`.\n     */\n    constructor(address[] memory supportedTokens_, uint256 fee_) {\n        for (uint256 i = 0; i < supportedTokens_.length; i++) {\n            supportedTokens[supportedTokens_[i]] = true;\n        }\n        fee = fee_;\n    }\n\n    /**\n     * @dev Loan `amount` tokens to `receiver`, and takes it back plus a `flashFee` after the callback.\n     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data A data parameter to be passed on to the `receiver` for any custom use.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external override returns (bool) {\n        require(supportedTokens[token], \"FlashLender: Unsupported currency\");\n\n        uint256 _fee = _flashFee(token, amount);\n        require(IERC20(token).transfer(address(receiver), amount), \"FlashLender: Transfer failed\");\n\n        require(\n            receiver.onFlashLoan(msg.sender, token, amount, _fee, data) == CALLBACK_SUCCESS,\n            \"FlashLender: Callback failed\"\n        );\n        require(\n            IERC20(token).transferFrom(address(receiver), address(this), amount + _fee),\n            \"FlashLender: Repay failed\"\n        );\n\n        return true;\n    }\n\n    /**\n     * @dev The amount of currency available to be lent.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashFloan(address token) external view override returns (uint256) {\n        return supportedTokens[token] ? IERC20(token).balanceOf(address(this)) : 0;\n    }\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view override returns (uint256) {\n        require(supportedTokens[token], \"FlashLender: Unsupported currency\");\n\n        return _flashFee(token, amount);\n    }\n\n    /**\n     * @dev The fee to be charged for a given loan. Internal function with no checks.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function _flashFee(address token, uint256 amount) internal view returns (uint256) {\n        // silence warning about unused variable without the addition of bytecode.\n        token;\n\n        return (amount * fee) / 10000;\n    }\n}\n"
  },
  {
    "contract name": "FlashMinter",
    "contract data": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./interfaces/IERC3156FlashBorrower.sol\";\nimport \"./interfaces/IERC3156FlashLender.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows flash minting.\n */\ncontract FlashMinter is ERC20, IERC3156FlashLender {\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    uint256 public fee; //  1 == 0.01 %\n\n    /**\n     * @param fee_ The percentage of the loan `amount` that needs to be repaid, in addition to `amount`.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 fee_\n    ) ERC20(name, symbol) {\n        fee = fee_;\n    }\n\n    /**\n     * @dev The amount of currency available to be lent.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashFloan(address token) external view override returns (uint256) {\n        return token == address(this) ? type(uint256).max - totalSupply() : 0;\n    }\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency. Must match the address of this contract.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view override returns (uint256) {\n        require(token == address(this), \"FlashMinter: Unsupported currency\");\n\n        return _flashFee(token, amount);\n    }\n\n    /**\n     * @dev Loan `amount` tokens to `receiver`, and takes it back plus a `flashFee` after the ERC3156 callback.\n     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n     * @param token The loan currency. Must match the address of this contract.\n     * @param amount The amount of tokens lent.\n     * @param data A data parameter to be passed on to the `receiver` for any custom use.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external override returns (bool) {\n        require(token == address(this), \"FlashMinter: Unsupported currency\");\n\n        uint256 _fee = _flashFee(token, amount);\n        _mint(address(receiver), amount);\n        require(\n            receiver.onFlashLoan(msg.sender, token, amount, _fee, data) == CALLBACK_SUCCESS,\n            \"FlashMinter: Repay not approved\"\n        );\n\n        uint256 _allowance = allowance(address(receiver), address(this));\n        require(_allowance >= (amount + _fee), \"FlashMinter: Repay not approved\");\n        _approve(address(receiver), address(this), _allowance - (amount + _fee));\n\n        _burn(address(receiver), amount + _fee);\n\n        return true;\n    }\n\n    /**\n     * @dev The fee to be charged for a given loan. Internal function with no checks.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function _flashFee(address token, uint256 amount) internal view returns (uint256) {\n        // silence warning about unused variable without the addition of bytecode.\n        token;\n\n        return (amount * fee) / 10000;\n    }\n}\n"
  },
  {
    "contract name": "SimpleSwap",
    "contract data": "// https://uniswap.org/blog/your-first-uniswap-integration\n\n// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.9;\npragma abicoder v2;\n\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\ncontract SimpleSwap {\n    ISwapRouter public immutable swapRouter;\n    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address public constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    uint24 public constant feeTier = 3000;\n\n    constructor(ISwapRouter _swapRouter) {\n        swapRouter = _swapRouter;\n    }\n\n    function swapWETHForDAI(uint256 amountIn) external returns (uint256 amountOut) {\n        // Transfer the specified amount of WETH9 to this contract.\n        TransferHelper.safeTransferFrom(WETH9, msg.sender, address(this), amountIn);\n        // Approve the router to spend WETH9.\n        TransferHelper.safeApprove(WETH9, address(swapRouter), amountIn);\n        // Create the params that will be used to execute the swap\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: WETH9,\n            tokenOut: DAI,\n            fee: feeTier,\n            recipient: msg.sender,\n            deadline: block.timestamp,\n            amountIn: amountIn,\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 0\n        });\n        // The call to `exactInputSingle` executes the swap.\n        amountOut = swapRouter.exactInputSingle(params);\n        return amountOut;\n    }\n}\n"
  }
]