[
  {
    "folderName": "drand",
    "fileName": "lottery_test.move",
    "path": "aptos-core/aptos-move/move-examples/drand/sources/lottery_test.move",
    "content": "module drand::lottery_test {\n    #[test_only]\n    use drand::lottery;\n    #[test_only]\n    use aptos_framework::timestamp;\n    #[test_only]\n    use std::signer;\n    #[test_only]\n    use aptos_framework::account;\n    #[test_only]\n    use aptos_framework::coin;\n    #[test_only]\n    use aptos_framework::aptos_coin::{Self, AptosCoin};\n    #[test_only]\n    use aptos_framework::coin::MintCapability;\n    #[test_only]\n    use std::vector;\n    #[test_only]\n    use std::string;\n    #[test_only]\n    use std::debug;\n    #[test_only]\n    use aptos_std::crypto_algebra::enable_cryptography_algebra_natives;\n\n    #[test_only]\n    fun give_coins(mint_cap: &MintCapability<AptosCoin>, to: &signer) {\n        let to_addr = signer::address_of(to);\n        if (!account::exists_at(to_addr)) {\n            account::create_account_for_test(to_addr);\n        };\n        coin::register<AptosCoin>(to);\n\n        let coins = coin::mint(lottery::get_ticket_price(), mint_cap);\n        coin::deposit(to_addr, coins);\n    }\n\n    #[test(myself = @drand, fx = @aptos_framework, u1 = @0xA001, u2 = @0xA002, u3 = @0xA003, u4 = @0xA004)]\n    fun test_lottery(\n        myself: signer, fx: signer,\n        u1: signer, u2: signer, u3: signer, u4: signer,\n    ) {\n        enable_cryptography_algebra_natives(&fx);\n        timestamp::set_time_has_started_for_testing(&fx);\n\n        // Needed to mint coins out of thin air for testing\n        let (burn_cap, mint_cap) = aptos_coin::initialize_for_test(&fx);\n\n        // Deploy the lottery smart contract\n        lottery::init_module_for_testing(&myself);\n\n        // We simulate different runs of the lottery to demonstrate the uniformity of the outcomes\n        let vec_signed_bytes = vector::empty<vector<u8>>();\n        // curl https://api3.drand.sh/dbd506d6ef76e5f386f41c651dcb808c5bcbd75471cc4eafa3f4df7ad4e4c493/public/202\n        vector::push_back(&mut vec_signed_bytes, x\"a438d55a0a3aeff6c6b78ad40c2dfb55dae5154d86eeb8163138f2bf96294f90841e75ad952bf8101630da7bb527da21\"); // u1 wins.\n        // curl https://api3.drand.sh/dbd506d6ef76e5f386f41c651dcb808c5bcbd75471cc4eafa3f4df7ad4e4c493/public/602\n        vector::push_back(&mut vec_signed_bytes, x\"b0e64fd43f49f3cf20135e7133112c0ae461e6a7b2961ef474f716648a9ab5b67f606af2980944344de131ab970ccb5d\"); // u1 wins.\n        // curl https://api3.drand.sh/dbd506d6ef76e5f386f41c651dcb808c5bcbd75471cc4eafa3f4df7ad4e4c493/public/1002\n        vector::push_back(&mut vec_signed_bytes, x\"8a9b54d4790bcc1e0b8b3e452102bfc091d23ede4b488cb81580f37a52762a283ed8c8dd844f0a112fda3d768ec3f9a2\"); // u4 wins.\n        // curl https://api3.drand.sh/dbd506d6ef76e5f386f41c651dcb808c5bcbd75471cc4eafa3f4df7ad4e4c493/public/1402\n        vector::push_back(&mut vec_signed_bytes, x\"8eaca04732b0de0c2a385f0ccaab9504592fcae7ca621bef58302d4ef0bd2ce3dd9c90153688dedd47efdbeb4d9ecde5\"); // u3 wins.\n\n        let lottery_start_time_secs = 1677685200; // the time that the 1st drand epoch started\n        let lottery_duration = lottery::get_minimum_lottery_duration_in_secs();\n\n        // We pop_back, so we reverse the vector to simulate pop_front\n        vector::reverse(&mut vec_signed_bytes);\n\n        while(!vector::is_empty(&vec_signed_bytes)) {\n            let signed_bytes = vector::pop_back(&mut vec_signed_bytes);\n\n            // Create fake coins for users participating in lottery & initialize aptos_framework\n            give_coins(&mint_cap, &u1);\n            give_coins(&mint_cap, &u2);\n            give_coins(&mint_cap, &u3);\n            give_coins(&mint_cap, &u4);\n\n            // Simulates the lottery starting at the current blockchain time\n            timestamp::update_global_time_for_test(lottery_start_time_secs * 1000 * 1000);\n\n            test_lottery_with_randomness(\n                &u1, &u2, &u3, &u4,\n                lottery_start_time_secs, lottery_duration,\n                signed_bytes\n            );\n\n            // Shift the next lottery's start time a little (otherwise, timestamp::update_global_time_for_test fails\n            // when resetting the time back to the past).\n            lottery_start_time_secs = lottery_start_time_secs + 2 * lottery_duration;\n        };\n\n        // Clean up\n        coin::destroy_burn_cap<AptosCoin>(burn_cap);\n        coin::destroy_mint_cap<AptosCoin>(mint_cap);\n    }\n\n    #[test_only]\n    fun test_lottery_with_randomness(\n        u1: &signer, u2: &signer, u3: &signer, u4: &signer,\n        lottery_start_time_secs: u64,\n        lottery_duration: u64,\n        drand_signed_bytes: vector<u8>,\n    ) {\n        //debug::print(&string::utf8(b\"The lottery duration is: \"));\n        //debug::print(&lottery_duration);\n        //debug::print(&string::utf8(b\"The time before starting it is: \"));\n        //debug::print(&timestamp::now_seconds());\n\n        let lottery_draw_at_time = lottery_start_time_secs + lottery_duration;\n\n        //\n        // Send a TXN to start the lottery\n        //\n        lottery::start_lottery(lottery_draw_at_time);\n\n        //\n        // Each user sends a TXN to buy their ticket\n        //\n        lottery::buy_a_ticket(u1);\n        lottery::buy_a_ticket(u2);\n        lottery::buy_a_ticket(u3);\n        lottery::buy_a_ticket(u4);\n\n        // Advance time far enough so the lottery can be closed\n        timestamp::fast_forward_seconds(lottery_duration);\n        assert!(timestamp::now_seconds() == lottery_draw_at_time, 1);\n        //debug::print(&string::utf8(b\"The time before closing is: \"));\n        //debug::print(&timestamp::now_seconds());\n\n        //\n        // Send a TXN with `drand_signed_bytes` to close the lottery and determine the winner\n        //\n        lottery::close_lottery(drand_signed_bytes);\n        let winner_addr = lottery::get_lottery_winner();\n        debug::print(&string::utf8(b\"The winner is: \"));\n        debug::print(&winner_addr)\n\n    }\n}\n"
  },
  {
    "folderName": "event",
    "fileName": "event.move",
    "path": "aptos-core/aptos-move/move-examples/event/sources/event.move",
    "content": "/// This provides an example shows how to use module events.\n\nmodule event::event {\n    use aptos_framework::event;\n    #[test_only]\n    use std::vector;\n\n    struct Field has store, drop {\n        field: bool,\n    }\n\n    #[event]\n    struct MyEvent has store, drop {\n        seq: u64,\n        field: Field,\n        bytes: vector<u64>\n    }\n\n    public entry fun emit(num: u64) {\n        let i = 0;\n        while (i < num) {\n            let event = MyEvent {\n                seq: i,\n                field: Field { field: false },\n                bytes: vector[]\n            };\n            event::emit(event);\n            i = i + 1;\n        }\n    }\n\n    public entry fun call_inline() {\n        emit_one_event()\n    }\n\n    inline fun emit_one_event() {\n        event::emit(MyEvent {\n            seq: 1,\n            field: Field { field: false },\n            bytes: vector[]\n        });\n    }\n\n    #[test]\n    public entry fun test_emitting() {\n        emit(20);\n        let module_events = event::emitted_events<MyEvent>();\n        assert!(vector::length(&module_events) == 20, 0);\n        let i = 0;\n        while (i < 20) {\n            let event = MyEvent {\n                seq: i,\n                field: Field {field: false},\n                bytes: vector[]\n            };\n            assert!(vector::borrow(&module_events, i) == &event, i);\n            i = i + 1;\n        };\n        let event = MyEvent {\n            seq: 0,\n            field: Field { field: false },\n            bytes: vector[]\n        };\n        assert!(event::was_event_emitted(&event), i);\n    }\n\n    #[test]\n    public entry fun test_inline() {\n        call_inline();\n        assert!(event::was_event_emitted(&MyEvent {\n            seq: 1,\n            field: Field { field: false },\n            bytes: vector[]\n        }), 0);\n    }\n}\n"
  },
  {
    "folderName": "governance",
    "fileName": "block_update_epoch_interval.move",
    "path": "aptos-core/aptos-move/move-examples/governance/sources/block_update_epoch_interval.move",
    "content": "script {\n    use aptos_framework::aptos_governance;\n    use aptos_framework::block;\n\n    fun main(proposal_id: u64) {\n        let framework_signer = aptos_governance::resolve(proposal_id, @aptos_framework);\n        // Update epoch interval to 2 hours.\n        let epoch_interval_secs = 2 * 60 * 60;\n        let epoch_interval_microsecs = epoch_interval_secs * 1000000;\n        block::update_epoch_interval_microsecs(&framework_signer, epoch_interval_microsecs);\n    }\n}\n"
  },
  {
    "folderName": "governance",
    "fileName": "governance_update_voting_duration.move",
    "path": "aptos-core/aptos-move/move-examples/governance/sources/governance_update_voting_duration.move",
    "content": "script {\n    use aptos_framework::aptos_governance;\n\n    fun main(proposal_id: u64) {\n        let framework_signer = aptos_governance::resolve(proposal_id, @aptos_framework);\n        // Update voting duration of Aptos governance proposals to 1 day. Other params don't change.\n        let updated_voting_duration_secs = 24 * 60 * 60;\n        let unchanged_min_voting_threshold = aptos_governance::get_min_voting_threshold();\n        let unchanged_required_proposer_stake = aptos_governance::get_required_proposer_stake();\n        aptos_governance::update_governance_config(\n            &framework_signer,\n            unchanged_min_voting_threshold,\n            unchanged_required_proposer_stake,\n            updated_voting_duration_secs,\n        );\n    }\n}\n"
  },
  {
    "folderName": "governance",
    "fileName": "stake_update_min_max.move",
    "path": "aptos-core/aptos-move/move-examples/governance/sources/stake_update_min_max.move",
    "content": "script {\n    use aptos_framework::aptos_governance;\n    use aptos_framework::coin;\n    use aptos_framework::aptos_coin::AptosCoin;\n    use aptos_framework::staking_config;\n\n    fun main(proposal_id: u64) {\n        let framework_signer = aptos_governance::resolve(proposal_id, @aptos_framework);\n        let one_aptos_coin_with_decimals = 10 ** (coin::decimals<AptosCoin>() as u64);\n        // Change min to 1000 and max to 1M Aptos coins.\n        let new_min_stake = 1000 * one_aptos_coin_with_decimals;\n        let new_max_stake = 1000000 * one_aptos_coin_with_decimals;\n        staking_config::update_required_stake(&framework_signer, new_min_stake, new_max_stake);\n    }\n}\n"
  },
  {
    "folderName": "governance",
    "fileName": "stake_update_recurring_lockup_time.move",
    "path": "aptos-core/aptos-move/move-examples/governance/sources/stake_update_recurring_lockup_time.move",
    "content": "script {\n  use aptos_framework::aptos_governance;\n  use aptos_framework::staking_config;\n\n  fun main(proposal_id: u64) {\n    let framework_signer = aptos_governance::resolve(proposal_id, @aptos_framework);\n    // Change recurring lockup to 1 day.\n    let one_day_in_secs = 24 * 60 * 60;\n    staking_config::update_recurring_lockup_duration_secs(&framework_signer, one_day_in_secs);\n  }\n}\n"
  },
  {
    "folderName": "governance",
    "fileName": "stake_update_rewards_rate.move",
    "path": "aptos-core/aptos-move/move-examples/governance/sources/stake_update_rewards_rate.move",
    "content": "script {\n    use aptos_framework::aptos_governance;\n    use aptos_framework::block;\n    use aptos_framework::staking_config;\n\n    fun main(proposal_id: u64) {\n        let framework_signer = aptos_governance::resolve(proposal_id, @aptos_framework);\n        let num_seconds_in_a_year = 365 * 24 * 60 * 60;\n        let epoch_duration_secs = block::get_epoch_interval_secs();\n        let num_epochs_in_a_year = num_seconds_in_a_year / epoch_duration_secs;\n        // Change reward rate to 5% a year.\n        let apy = 5;\n        // Need to represent reward rate fraction as 2 numbers - numerator and denominator.\n        let reward_rate_denominator = 1000000000;\n        let reward_rate_numerator = apy * reward_rate_denominator / num_epochs_in_a_year / 100;\n        staking_config::update_rewards_rate(\n            &framework_signer, reward_rate_numerator, reward_rate_denominator);\n    }\n}\n"
  },
  {
    "folderName": "governance",
    "fileName": "stake_update_voting_power_increase_limit.move",
    "path": "aptos-core/aptos-move/move-examples/governance/sources/stake_update_voting_power_increase_limit.move",
    "content": "script {\n    use aptos_framework::aptos_governance;\n    use aptos_framework::staking_config;\n\n    fun main(proposal_id: u64) {\n        let framework_signer = aptos_governance::resolve(proposal_id, @aptos_framework);\n        // Update voting power increase limit to 10%.\n        staking_config::update_voting_power_increase_limit(&framework_signer, 10);\n    }\n}\n"
  },
  {
    "folderName": "groth16_example",
    "fileName": "groth16.move",
    "path": "aptos-core/aptos-move/move-examples/groth16_example/sources/groth16.move",
    "content": "/// Generic implementation of Groth16 (proof verification) as defined in https://eprint.iacr.org/2016/260.pdf, Section 3.2.\n/// Actual proof verifiers can be constructed using the pairings supported in the generic algebra module.\n/// See the test cases in this module for an example of constructing with BLS12-381 curves.\n///\n/// **WARNING:** This code has NOT been audited. If using it in a production system, proceed at your own risk.\nmodule groth16_example::groth16 {\n    use aptos_std::crypto_algebra::{Element, from_u64, multi_scalar_mul, eq, multi_pairing, upcast, pairing, add, zero};\n\n    /// Proof verification as specified in the original paper,\n    /// with the following input (in the original paper notations).\n    /// - Verification key: $\\left([\\alpha]_1, [\\beta]_2, [\\gamma]_2, [\\delta]_2, \\left\\\\{ \\left[ \\frac{\\beta \\cdot u_i(x) + \\alpha \\cdot v_i(x) + w_i(x)}{\\gamma} \\right]_1 \\right\\\\}\\_{i=0}^l \\right)$.\n    /// - Public inputs: $\\\\{a_i\\\\}_{i=1}^l$.\n    /// - Proof $\\left( \\left[ A \\right]_1, \\left[ B \\right]_2, \\left[ C \\right]_1 \\right)$.\n    public fun verify_proof<G1,G2,Gt,S>(\n        vk_alpha_g1: &Element<G1>,\n        vk_beta_g2: &Element<G2>,\n        vk_gamma_g2: &Element<G2>,\n        vk_delta_g2: &Element<G2>,\n        vk_uvw_gamma_g1: &vector<Element<G1>>,\n        public_inputs: &vector<Element<S>>,\n        proof_a: &Element<G1>,\n        proof_b: &Element<G2>,\n        proof_c: &Element<G1>,\n    ): bool {\n        let left = pairing<G1,G2,Gt>(proof_a, proof_b);\n        let scalars = vector[from_u64<S>(1)];\n        std::vector::append(&mut scalars, *public_inputs);\n        let right = zero<Gt>();\n        let right = add(&right, &pairing<G1,G2,Gt>(vk_alpha_g1, vk_beta_g2));\n        let right = add(&right, &pairing(&multi_scalar_mul(vk_uvw_gamma_g1, &scalars), vk_gamma_g2));\n        let right = add(&right, &pairing(proof_c, vk_delta_g2));\n        eq(&left, &right)\n    }\n\n    /// Modified proof verification which is optimized for low verification latency\n    /// but requires a pairing and 2 `G2` negations to be pre-computed.\n    /// Below are the full input (in the original paper notations).\n    /// - Prepared verification key: $\\left([\\alpha]_1 \\cdot [\\beta]_2, -[\\gamma]_2, -[\\delta]_2, \\left\\\\{ \\left[ \\frac{\\beta \\cdot u_i(x) + \\alpha \\cdot v_i(x) + w_i(x)}{\\gamma} \\right]_1 \\right\\\\}\\_{i=0}^l \\right)$.\n    /// - Public inputs: $\\\\{a_i\\\\}_{i=1}^l$.\n    /// - Proof: $\\left( \\left[ A \\right]_1, \\left[ B \\right]_2, \\left[ C \\right]_1 \\right)$.\n    public fun verify_proof_prepared<G1,G2,Gt,S>(\n        pvk_alpha_g1_beta_g2: &Element<Gt>,\n        pvk_gamma_g2_neg: &Element<G2>,\n        pvk_delta_g2_neg: &Element<G2>,\n        pvk_uvw_gamma_g1: &vector<Element<G1>>,\n        public_inputs: &vector<Element<S>>,\n        proof_a: &Element<G1>,\n        proof_b: &Element<G2>,\n        proof_c: &Element<G1>,\n    ): bool {\n        let scalars = vector[from_u64<S>(1)];\n        std::vector::append(&mut scalars, *public_inputs);\n        let g1_elements = vector[*proof_a, multi_scalar_mul(pvk_uvw_gamma_g1, &scalars), *proof_c];\n        let g2_elements = vector[*proof_b, *pvk_gamma_g2_neg, *pvk_delta_g2_neg];\n        eq(pvk_alpha_g1_beta_g2, &multi_pairing<G1,G2,Gt>(&g1_elements, &g2_elements))\n    }\n\n    /// A variant of `verify_proof_prepared()` that requires `pvk_alpha_g1_beta_g2` to be an element of `Fq12` instead of its subgroup `Gt`.\n    /// With this variant, the caller may save a `Gt` deserialization (which involves an expensive `Gt` membership test).\n    /// Below are the full input (in the original paper notations).\n    /// - Prepared verification key: $\\left([\\alpha]_1 \\cdot [\\beta]_2, -[\\gamma]_2, -[\\delta]_2, \\left\\\\{ \\left[ \\frac{\\beta \\cdot u_i(x) + \\alpha \\cdot v_i(x) + w_i(x)}{\\gamma} \\right]_1 \\right\\\\}\\_{i=0}^l \\right)$.\n    /// - Public inputs: $\\\\{a_i\\\\}_{i=1}^l$.\n    /// - Proof: $\\left( \\left[ A \\right]_1, \\left[ B \\right]_2, \\left[ C \\right]_1 \\right)$.\n    public fun verify_proof_prepared_fq12<G1, G2, Gt, Fq12, S>(\n        pvk_alpha_g1_beta_g2: &Element<Fq12>,\n        pvk_gamma_g2_neg: &Element<G2>,\n        pvk_delta_g2_neg: &Element<G2>,\n        pvk_uvw_gamma_g1: &vector<Element<G1>>,\n        public_inputs: &vector<Element<S>>,\n        proof_a: &Element<G1>,\n        proof_b: &Element<G2>,\n        proof_c: &Element<G1>,\n    ): bool {\n        let scalars = vector[from_u64<S>(1)];\n        std::vector::append(&mut scalars, *public_inputs);\n        let g1_elements = vector[*proof_a, multi_scalar_mul(pvk_uvw_gamma_g1, &scalars), *proof_c];\n        let g2_elements = vector[*proof_b, *pvk_gamma_g2_neg, *pvk_delta_g2_neg];\n        eq(pvk_alpha_g1_beta_g2, &upcast(&multi_pairing<G1,G2,Gt>(&g1_elements, &g2_elements)))\n    }\n\n    #[test_only]\n    use aptos_std::crypto_algebra::{deserialize, enable_cryptography_algebra_natives};\n    #[test_only]\n    use aptos_std::bls12381_algebra::{Fr, FormatFrLsb, FormatG1Compr, FormatG2Compr, FormatFq12LscLsb, G1, G2, Gt, Fq12, FormatGt};\n    #[test_only]\n    use aptos_std::bn254_algebra;\n    #[test_only]\n    use std::bcs;\n    #[test_only]\n    use std::vector;\n\n    // This test gives an example of how to take a proof, verification key, and public input in the decimal string format\n    // output by snarkjs and verify the proof.\n    // Documentation for the serialization formats used can be found in `aptos-core/aptos-move/framework/aptos-stdlib/sources/cryptography/X.move`,\n    // where X is bn254_algebra for BN254 and bls12381_algebra for BLS12_381\n    // The names are preserved from the snarkjs proof and verifier key JSON file format, with the\n    // exception of \"IC\", which has been renamed to `vk_gamma_abc`\n    // The JSON files output by snarkjs used for this example can be found in \"groth16_example/example_snarkjs_proof.json\"\n    // and \"groth16_example/example_snarkjs_vk.json\"\n    #[test(fx = @std)]\n    fun test_verify_circom_proof(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n        let a_x = 9291141442484249183824149917322150275993152355313319552386216014158050680949u256;\n        let a_y = 4751084799539532208179359846086616641767957505361605807745261011239799367574u256;\n        let a_bytes = bcs::to_bytes<u256>(&a_x);\n        let a_y_bytes = bcs::to_bytes<u256>(&a_y);\n        vector::append(&mut a_bytes, a_y_bytes);\n        let a = std::option::extract(&mut deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Uncompr>(&a_bytes));\n\n        let b_x1 = 4154738608741966676660560127107026081842675422117462672893103452342068780854u256;\n        let b_y1 = 4513470140932917342403349901925141325820502953664313447973655116956106256795u256;\n        let b_x2 = 15981382089229198179693168711034036915586021039523535710774744447138572769902u256;\n        let b_y2 = 11691946641863119124627852663455054061430853487917262585560660740296157381098u256;\n        let b_bytes = bcs::to_bytes<u256>(&b_x1);\n        let b_y1_bytes = bcs::to_bytes<u256>(&b_y1);\n        let b_x2_bytes = bcs::to_bytes<u256>(&b_x2);\n        let b_y2_bytes = bcs::to_bytes<u256>(&b_y2);\n        vector::append(&mut b_bytes, b_y1_bytes);\n        vector::append(&mut b_bytes, b_x2_bytes);\n        vector::append(&mut b_bytes, b_y2_bytes);\n        let b = std::option::extract(&mut deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Uncompr>(&b_bytes));\n\n        let c_x = 19416574444268205378069689424519026208317515867624593374135746889327790637883u256;\n        let c_y = 9387724931669771435449663200581094189180308746057595118467671565223418773035u256;\n        let c_bytes = bcs::to_bytes<u256>(&c_x);\n        let c_y_bytes = bcs::to_bytes<u256>(&c_y);\n        vector::append(&mut c_bytes, c_y_bytes);\n        let c = std::option::extract(&mut deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Uncompr>(&c_bytes));\n\n        let vk_alpha_x = 20491192805390485299153009773594534940189261866228447918068658471970481763042u256;\n        let vk_alpha_y = 9383485363053290200918347156157836566562967994039712273449902621266178545958u256;\n        let vk_alpha_bytes = bcs::to_bytes<u256>(&vk_alpha_x);\n        let vk_alpha_y_bytes = bcs::to_bytes<u256>(&vk_alpha_y);\n        vector::append(&mut vk_alpha_bytes, vk_alpha_y_bytes);\n        let vk_alpha = std::option::extract(&mut deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Uncompr>(&vk_alpha_bytes));\n\n        let vk_beta_x1 = 6375614351688725206403948262868962793625744043794305715222011528459656738731u256;\n        let vk_beta_y1 = 4252822878758300859123897981450591353533073413197771768651442665752259397132u256;\n        let vk_beta_x2 = 10505242626370262277552901082094356697409835680220590971873171140371331206856u256;\n        let vk_beta_y2 = 21847035105528745403288232691147584728191162732299865338377159692350059136679u256;\n        let vk_beta_bytes = bcs::to_bytes<u256>(&vk_beta_x1);\n        let vk_beta_y1_bytes = bcs::to_bytes<u256>(&vk_beta_y1);\n        let vk_beta_x2_bytes = bcs::to_bytes<u256>(&vk_beta_x2);\n        let vk_beta_y2_bytes = bcs::to_bytes<u256>(&vk_beta_y2);\n        vector::append(&mut vk_beta_bytes, vk_beta_y1_bytes);\n        vector::append(&mut vk_beta_bytes, vk_beta_x2_bytes);\n        vector::append(&mut vk_beta_bytes, vk_beta_y2_bytes);\n        let vk_beta = std::option::extract(&mut deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Uncompr>(&vk_beta_bytes));\n\n        let vk_gamma_x1 = 10857046999023057135944570762232829481370756359578518086990519993285655852781u256;\n        let vk_gamma_y1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634u256;\n        let vk_gamma_x2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930u256;\n        let vk_gamma_y2 = 4082367875863433681332203403145435568316851327593401208105741076214120093531u256;\n        let vk_gamma_bytes = bcs::to_bytes<u256>(&vk_gamma_x1);\n        let vk_gamma_y1_bytes = bcs::to_bytes<u256>(&vk_gamma_y1);\n        let vk_gamma_x2_bytes = bcs::to_bytes<u256>(&vk_gamma_x2);\n        let vk_gamma_y2_bytes = bcs::to_bytes<u256>(&vk_gamma_y2);\n        vector::append(&mut vk_gamma_bytes, vk_gamma_y1_bytes);\n        vector::append(&mut vk_gamma_bytes, vk_gamma_x2_bytes);\n        vector::append(&mut vk_gamma_bytes, vk_gamma_y2_bytes);\n        let vk_gamma = std::option::extract(&mut deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Uncompr>(&vk_gamma_bytes));\n\n        let vk_delta_x1 = 11733257046589851891850695012146277477007262722187040969185039828348964552798u256;\n        let vk_delta_y1 = 4027038803827470819590008730534113934894139311083936102089700708335772383417u256;\n        let vk_delta_x2 = 4501048010313692533367858190733760821904297928029128233318781536412685771070u256;\n        let vk_delta_y2 = 7929485975251451284651333169168875690528578182699769192928243180764480545757u256;\n        let vk_delta_bytes = bcs::to_bytes<u256>(&vk_delta_x1);\n        let vk_delta_y1_bytes = bcs::to_bytes<u256>(&vk_delta_y1);\n        let vk_delta_x2_bytes = bcs::to_bytes<u256>(&vk_delta_x2);\n        let vk_delta_y2_bytes = bcs::to_bytes<u256>(&vk_delta_y2);\n        vector::append(&mut vk_delta_bytes, vk_delta_y1_bytes);\n        vector::append(&mut vk_delta_bytes, vk_delta_x2_bytes);\n        vector::append(&mut vk_delta_bytes, vk_delta_y2_bytes);\n        let vk_delta = std::option::extract(&mut deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Uncompr>(&vk_delta_bytes));\n\n        let vk_gamma_abc_1_x = 9301933260370907965380929235907744187309044275532228633956723711236164592702u256;\n        let vk_gamma_abc_1_y = 16430819258686105004298644553325509170608676387027348203797023622583733864344u256;\n        let vk_gamma_abc_2_x = 15788660278421993534955189104796829710153510462607851239961905416961864489081u256;\n        let vk_gamma_abc_2_y = 15949953543860974252716711139898663592700226282992131841266708887108944899694u256;\n        let vk_gamma_abc_3_x = 2752114278074204756951480614592040829268118205913128303990769829555505490153u256;\n        let vk_gamma_abc_3_y = 73756394237398953482375632482393116165824820760002925371208078608366682284u256;\n        let vk_gamma_abc_4_x = 6831852747912655055472532439405874457935232091421568713540315004023659266911u256;\n        let vk_gamma_abc_4_y = 17612881006477748801680400530139134796116043408186867599538777507587075595161u256;\n        let vk_gamma_abc_5_x = 17635013362332631023685688861083101650289128874790189338507065664254475202088u256;\n        let vk_gamma_abc_5_y = 6682655906896444146648448177201874759860197304706943082757442475451670349909u256;\n        let vk_gamma_abc_6_x = 9475873236009016297956856337772183876551495716493352835259515853844766276811u256;\n        let vk_gamma_abc_6_y = 354515196483384658424215379959670593913045973021122448612086705709310867552u256;\n        let vk_gamma_abc_7_x = 7739081130943509516619482455397124703705394954310688728375429231271874275446u256;\n        let vk_gamma_abc_7_y = 20649108686175166181372170979134000369449535282768431130801436273782009562466u256;\n        let vk_gamma_abc_8_x = 19048468636913770448398586085397679668705519948654488617907272996340406724088u256;\n        let vk_gamma_abc_8_y = 16091090919051613132321664644473341983081123954146774949203587504747978913249u256;\n        let vk_gamma_abc_9_x = 15589510145441310638849264936668688491890711017850837908639714876170500087371u256;\n        let vk_gamma_abc_9_y = 160324255716095477979225131314833211463231522810162446268019950262710535809u256;\n\n        let vk_gamma_abc_1_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_1_x);\n        let vk_gamma_abc_1_y_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_1_y);\n        vector::append(&mut vk_gamma_abc_1_bytes, vk_gamma_abc_1_y_bytes);\n        let vk_gamma_abc_1 = std::option::extract(&mut deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Uncompr>(&vk_gamma_abc_1_bytes));\n\n        let vk_gamma_abc_2_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_2_x);\n        let vk_gamma_abc_2_y_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_2_y);\n        vector::append(&mut vk_gamma_abc_2_bytes, vk_gamma_abc_2_y_bytes);\n        let vk_gamma_abc_2 = std::option::extract(&mut deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Uncompr>(&vk_gamma_abc_2_bytes));\n\n        let vk_gamma_abc_3_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_3_x);\n        let vk_gamma_abc_3_y_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_3_y);\n        vector::append(&mut vk_gamma_abc_3_bytes, vk_gamma_abc_3_y_bytes);\n        let vk_gamma_abc_3 = std::option::extract(&mut deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Uncompr>(&vk_gamma_abc_3_bytes));\n\n        let vk_gamma_abc_4_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_4_x);\n        let vk_gamma_abc_4_y_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_4_y);\n        vector::append(&mut vk_gamma_abc_4_bytes, vk_gamma_abc_4_y_bytes);\n        let vk_gamma_abc_4 = std::option::extract(&mut deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Uncompr>(&vk_gamma_abc_4_bytes));\n\n        let vk_gamma_abc_5_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_5_x);\n        let vk_gamma_abc_5_y_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_5_y);\n        vector::append(&mut vk_gamma_abc_5_bytes, vk_gamma_abc_5_y_bytes);\n        let vk_gamma_abc_5 = std::option::extract(&mut deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Uncompr>(&vk_gamma_abc_5_bytes));\n\n        let vk_gamma_abc_6_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_6_x);\n        let vk_gamma_abc_6_y_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_6_y);\n        vector::append(&mut vk_gamma_abc_6_bytes, vk_gamma_abc_6_y_bytes);\n        let vk_gamma_abc_6 = std::option::extract(&mut deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Uncompr>(&vk_gamma_abc_6_bytes));\n\n        let vk_gamma_abc_7_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_7_x);\n        let vk_gamma_abc_7_y_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_7_y);\n        vector::append(&mut vk_gamma_abc_7_bytes, vk_gamma_abc_7_y_bytes);\n        let vk_gamma_abc_7 = std::option::extract(&mut deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Uncompr>(&vk_gamma_abc_7_bytes));\n\n        let vk_gamma_abc_8_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_8_x);\n        let vk_gamma_abc_8_y_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_8_y);\n        vector::append(&mut vk_gamma_abc_8_bytes, vk_gamma_abc_8_y_bytes);\n        let vk_gamma_abc_8 = std::option::extract(&mut deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Uncompr>(&vk_gamma_abc_8_bytes));\n\n        let vk_gamma_abc_9_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_9_x);\n        let vk_gamma_abc_9_y_bytes = bcs::to_bytes<u256>(&vk_gamma_abc_9_y);\n        vector::append(&mut vk_gamma_abc_9_bytes, vk_gamma_abc_9_y_bytes);\n        let vk_gamma_abc_9 = std::option::extract(&mut deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Uncompr>(&vk_gamma_abc_9_bytes));\n\n        let vk_gamma_abc: vector<Element<bn254_algebra::G1>> = vector[\n            vk_gamma_abc_1, vk_gamma_abc_2, vk_gamma_abc_3, vk_gamma_abc_4, vk_gamma_abc_5, vk_gamma_abc_6, vk_gamma_abc_7, vk_gamma_abc_8, vk_gamma_abc_9\n        ];\n\n        let public_1_val = 0u256;\n        let public_2_val = 7714357208561315320836530795186262204499958856333073618293621003566744654598u256;\n        let public_3_val = 91557130945874u256;\n        let public_4_val = 34458076785421617u256;\n        let public_5_val = 2800000u256;\n        let public_6_val = 5591876u256;\n        let public_7_val = 5591876u256;\n        let public_8_val = 751199308u256;\n        let public_1_bytes = bcs::to_bytes<u256>(&public_1_val);\n        let public_2_bytes = bcs::to_bytes<u256>(&public_2_val);\n        let public_3_bytes = bcs::to_bytes<u256>(&public_3_val);\n        let public_4_bytes = bcs::to_bytes<u256>(&public_4_val);\n        let public_5_bytes = bcs::to_bytes<u256>(&public_5_val);\n        let public_6_bytes = bcs::to_bytes<u256>(&public_6_val);\n        let public_7_bytes = bcs::to_bytes<u256>(&public_7_val);\n        let public_8_bytes = bcs::to_bytes<u256>(&public_8_val);\n        let public_1 = std::option::extract(&mut deserialize<bn254_algebra::Fr, bn254_algebra::FormatFrLsb>(&public_1_bytes));\n        let public_2 = std::option::extract(&mut deserialize<bn254_algebra::Fr, bn254_algebra::FormatFrLsb>(&public_2_bytes));\n        let public_3 = std::option::extract(&mut deserialize<bn254_algebra::Fr, bn254_algebra::FormatFrLsb>(&public_3_bytes));\n        let public_4 = std::option::extract(&mut deserialize<bn254_algebra::Fr, bn254_algebra::FormatFrLsb>(&public_4_bytes));\n        let public_5 = std::option::extract(&mut deserialize<bn254_algebra::Fr, bn254_algebra::FormatFrLsb>(&public_5_bytes));\n        let public_6 = std::option::extract(&mut deserialize<bn254_algebra::Fr, bn254_algebra::FormatFrLsb>(&public_6_bytes));\n        let public_7 = std::option::extract(&mut deserialize<bn254_algebra::Fr, bn254_algebra::FormatFrLsb>(&public_7_bytes));\n        let public_8 = std::option::extract(&mut deserialize<bn254_algebra::Fr, bn254_algebra::FormatFrLsb>(&public_8_bytes));\n\n        let public_inputs: vector<Element<bn254_algebra::Fr>> = vector[\n            public_1, public_2, public_3, public_4, public_5, public_6, public_7, public_8\n        ];\n\n        assert!(verify_proof<bn254_algebra::G1, bn254_algebra::G2, bn254_algebra::Gt, bn254_algebra::Fr>(\n            &vk_alpha,\n            &vk_beta,\n            &vk_gamma,\n            &vk_delta,\n            &vk_gamma_abc,\n            &public_inputs,\n            &a,\n            &b,\n            &c,\n        ), 1);\n    }\n\n    #[test(fx = @std)]\n    fun test_verify_proof_with_bls12381(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // Below is an example MIMC proof sampled from test case https://github.com/arkworks-rs/groth16/blob/b6f9166bcf15ff4bfe101bb34e1bdc0d92302e37/tests/mimc.rs#L147.\n        let vk_alpha_g1 = std::option::extract(&mut deserialize<G1, FormatG1Compr>(&x\"9819f632fa8d724e351d25081ea31ccf379991ac25c90666e07103fffb042ed91c76351cd5a24041b40e26d231a5087e\"));\n        let vk_beta_g2 = std::option::extract(&mut deserialize<G2, FormatG2Compr>(&x\"871f36a996c71a89499ffe99aa7d3f94decdd2ca8b070dbb467e42d25aad918af6ec94d61b0b899c8f724b2b549d99fc1623a0e51b6cfbea220e70e7da5803c8ad1144a67f98934a6bf2881ec6407678fd52711466ad608d676c60319a299824\"));\n        let vk_gamma_g2 = std::option::extract(&mut deserialize<G2, FormatG2Compr>(&x\"96750d8445596af8d679487c7267ae9734aeac584ace191d225680a18ecff8ebae6dd6a5fd68e4414b1611164904ee120363c2b49f33a873d6cfc26249b66327a0de03e673b8139f79809e8b641586cde9943fa072ee5ed701c81b3fd426c220\"));\n        let vk_delta_g2 = std::option::extract(&mut deserialize<G2, FormatG2Compr>(&x\"8d3ac832f2508af6f01872ada87ea66d2fb5b099d34c5bac81e7482c956276dfc234c8d2af5fd2394b5440d0708a2c9f124a53c0755e9595cf9f8adade5deefcb8a574a67debd3b74d08c49c23ddc14cd6d48b65dce500c8a5d330e760fe85bb\"));\n        let vk_gamma_abc_g1: vector<Element<G1>> = vector[\n            std::option::extract(&mut deserialize<G1, FormatG1Compr>(&x\"b0df760d0f2d67fdff69d0ed3a0653dd8808df3c407ea4d0e27f8612c3fbb748cb4372d33cac512ee5ef4ee1683c3fe5\")),\n            std::option::extract(&mut deserialize<G1, FormatG1Compr>(&x\"96ec80d6b1050bbfc209f727678acce8788c05475771daffdd444ad8786c7a40195d859850fe2e72be3054e9fb8ce805\")),\n        ];\n        let public_inputs: vector<Element<Fr>> = vector[\n            std::option::extract(&mut deserialize<Fr, FormatFrLsb>(&x\"0ee291cfc951388c3c7f7c85ff2dfd42bbc66a6b4acaef9a5a51ce955125a74f\")),\n        ];\n        let proof_a = std::option::extract(&mut deserialize<G1, FormatG1Compr>(&x\"8a7c7364403d91bfa5c723ce93b920c8d2e559ea5e7e34eb68cea437aa4f26bf56ba22d9400988a86f2943c79401e959\"));\n        let proof_b = std::option::extract(&mut deserialize<G2, FormatG2Compr>(&x\"9352f8a2f9ff60d390e363d063354e9728adf39c91294499575855e803dd80eeaa1488cd24d1b80eb1b2625011e22a5d139e24f2c7ac3508874ec4bdb9c71ddf109e7853d641d23ed27bef265248d78eabe9137c03b088d8adbdf39e10f87eab\"));\n        let proof_c = std::option::extract(&mut deserialize<G1, FormatG1Compr>(&x\"896f68b438e076d3017e64aa47621fcd69b45f49a7038e2b1b9ed4f2de9b8eb8e0a76785a39a08f024435811a73a6818\"));\n\n        assert!(verify_proof<G1, G2, Gt, Fr>(\n            &vk_alpha_g1,\n            &vk_beta_g2,\n            &vk_gamma_g2,\n            &vk_delta_g2,\n            &vk_gamma_abc_g1,\n            &public_inputs,\n            &proof_a,\n            &proof_b,\n            &proof_c,\n        ), 1);\n    }\n\n    #[test(fx = @std)]\n    fun test_verify_proof_prepared_with_bls12381(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // Below is an example MIMC proof sampled from test case https://github.com/arkworks-rs/groth16/blob/b6f9166bcf15ff4bfe101bb34e1bdc0d92302e37/tests/mimc.rs#L147.\n        let pvk_alpha_g1_beta_g2 = std::option::extract(&mut deserialize<Gt, FormatGt>(&x\"15cee98b42f8d158f421bce13983e23597123817a3b19b006294b9145f3f382686706ad9161d6234661fb1a32da19d0e2a9e672901fe4abe9efd4da96bcdb8324459b93aa48a8abb92ddd28ef053f118e190eddd6c6212bc09428ea05e709104290e37f320a3aac1dcf96f66efd9f5826b69cd075b72801ef54ccb740a0947bb3f73174e5d2fdc04292f58841ad9cc0d0c25021dfd8d592943b5e61c97f1ba68dcabd7de970ecc347c04bbaf9a062d9d49476f0b5bc77b2b9c7222781c53b713c0aae7a4cc57ff8cfb433d27fb1328d0c5453dbb97f3a70e9ce3b1da52cee2047cad225410b6dacb28e7b6876795d005cf0aefb7f25350d0197a5c2aa7369a5e06a210580bba1cc1941e1871a465cf68c84f32a29e6e898e4961a2b1fd5f8f03f03b1e1a0e191becdc8f01fb15adeb7cb6cc39e686edfcf7d65e952cf5e19a477fb5f6d2dab61a4d6c07777c1842150646c8b6fcb5989d9e524a97e7bf8b7be6b12983205970f16aeaccbdbe6cd565fa570dc45b0ad8f51c46e1f05e9f3f230dcf7567db5fc9a59a55c39139c7b357103c26bca9b70032cccff2345b76f596901ea81dc28f1d490a129501cf02204e00e8b59770188d69379144629239933523a8ec71ce6f91fbd01b2b9c411f89948183fea3949d89919e239a4aadb2347803e97ae8f7f20ade26da001f803cd61eb9bf8a67356f7cf6ec1744720b078eb992529f5c219bf16d5ef2e233a04572730e7c9572eadd9aa63c69c9f7dcf3423b1dc4c9b2032c8a7bbe91505283163a85413ecf0a0095fe1899b29f60011226f009\"));\n        let pvk_gamma_g2_neg = std::option::extract(&mut deserialize<G2, FormatG2Compr>(&x\"b6750d8445596af8d679487c7267ae9734aeac584ace191d225680a18ecff8ebae6dd6a5fd68e4414b1611164904ee120363c2b49f33a873d6cfc26249b66327a0de03e673b8139f79809e8b641586cde9943fa072ee5ed701c81b3fd426c220\"));\n        let pvk_delta_g2_neg = std::option::extract(&mut deserialize<G2, FormatG2Compr>(&x\"ad3ac832f2508af6f01872ada87ea66d2fb5b099d34c5bac81e7482c956276dfc234c8d2af5fd2394b5440d0708a2c9f124a53c0755e9595cf9f8adade5deefcb8a574a67debd3b74d08c49c23ddc14cd6d48b65dce500c8a5d330e760fe85bb\"));\n        let pvk_gamma_abc_g1: vector<Element<G1>> = vector[\n            std::option::extract(&mut deserialize<G1, FormatG1Compr>(&x\"b0df760d0f2d67fdff69d0ed3a0653dd8808df3c407ea4d0e27f8612c3fbb748cb4372d33cac512ee5ef4ee1683c3fe5\")),\n            std::option::extract(&mut deserialize<G1, FormatG1Compr>(&x\"96ec80d6b1050bbfc209f727678acce8788c05475771daffdd444ad8786c7a40195d859850fe2e72be3054e9fb8ce805\")),\n        ];\n        let public_inputs: vector<Element<Fr>> = vector[\n            std::option::extract(&mut deserialize<Fr, FormatFrLsb>(&x\"0ee291cfc951388c3c7f7c85ff2dfd42bbc66a6b4acaef9a5a51ce955125a74f\")),\n        ];\n        let proof_a = std::option::extract(&mut deserialize<G1, FormatG1Compr>(&x\"8a7c7364403d91bfa5c723ce93b920c8d2e559ea5e7e34eb68cea437aa4f26bf56ba22d9400988a86f2943c79401e959\"));\n        let proof_b = std::option::extract(&mut deserialize<G2, FormatG2Compr>(&x\"9352f8a2f9ff60d390e363d063354e9728adf39c91294499575855e803dd80eeaa1488cd24d1b80eb1b2625011e22a5d139e24f2c7ac3508874ec4bdb9c71ddf109e7853d641d23ed27bef265248d78eabe9137c03b088d8adbdf39e10f87eab\"));\n        let proof_c = std::option::extract(&mut deserialize<G1, FormatG1Compr>(&x\"896f68b438e076d3017e64aa47621fcd69b45f49a7038e2b1b9ed4f2de9b8eb8e0a76785a39a08f024435811a73a6818\"));\n\n        assert!(verify_proof_prepared<G1, G2, Gt, Fr>(\n            &pvk_alpha_g1_beta_g2,\n            &pvk_gamma_g2_neg,\n            &pvk_delta_g2_neg,\n            &pvk_gamma_abc_g1,\n            &public_inputs,\n            &proof_a,\n            &proof_b,\n            &proof_c,\n        ), 1);\n    }\n\n    #[test(fx = @std)]\n    fun test_verify_proof_prepared_fq12_with_bls12381(fx: signer) {\n        enable_cryptography_algebra_natives(&fx);\n\n        // Below is an example MIMC proof sampled from test case https://github.com/arkworks-rs/groth16/blob/b6f9166bcf15ff4bfe101bb34e1bdc0d92302e37/tests/mimc.rs#L147.\n        let pvk_alpha_g1_beta_g2 = std::option::extract(&mut deserialize<Fq12, FormatFq12LscLsb>(&x\"15cee98b42f8d158f421bce13983e23597123817a3b19b006294b9145f3f382686706ad9161d6234661fb1a32da19d0e2a9e672901fe4abe9efd4da96bcdb8324459b93aa48a8abb92ddd28ef053f118e190eddd6c6212bc09428ea05e709104290e37f320a3aac1dcf96f66efd9f5826b69cd075b72801ef54ccb740a0947bb3f73174e5d2fdc04292f58841ad9cc0d0c25021dfd8d592943b5e61c97f1ba68dcabd7de970ecc347c04bbaf9a062d9d49476f0b5bc77b2b9c7222781c53b713c0aae7a4cc57ff8cfb433d27fb1328d0c5453dbb97f3a70e9ce3b1da52cee2047cad225410b6dacb28e7b6876795d005cf0aefb7f25350d0197a5c2aa7369a5e06a210580bba1cc1941e1871a465cf68c84f32a29e6e898e4961a2b1fd5f8f03f03b1e1a0e191becdc8f01fb15adeb7cb6cc39e686edfcf7d65e952cf5e19a477fb5f6d2dab61a4d6c07777c1842150646c8b6fcb5989d9e524a97e7bf8b7be6b12983205970f16aeaccbdbe6cd565fa570dc45b0ad8f51c46e1f05e9f3f230dcf7567db5fc9a59a55c39139c7b357103c26bca9b70032cccff2345b76f596901ea81dc28f1d490a129501cf02204e00e8b59770188d69379144629239933523a8ec71ce6f91fbd01b2b9c411f89948183fea3949d89919e239a4aadb2347803e97ae8f7f20ade26da001f803cd61eb9bf8a67356f7cf6ec1744720b078eb992529f5c219bf16d5ef2e233a04572730e7c9572eadd9aa63c69c9f7dcf3423b1dc4c9b2032c8a7bbe91505283163a85413ecf0a0095fe1899b29f60011226f009\"));\n        let pvk_gamma_g2_neg = std::option::extract(&mut deserialize<G2, FormatG2Compr>(&x\"b6750d8445596af8d679487c7267ae9734aeac584ace191d225680a18ecff8ebae6dd6a5fd68e4414b1611164904ee120363c2b49f33a873d6cfc26249b66327a0de03e673b8139f79809e8b641586cde9943fa072ee5ed701c81b3fd426c220\"));\n        let pvk_delta_g2_neg = std::option::extract(&mut deserialize<G2, FormatG2Compr>(&x\"ad3ac832f2508af6f01872ada87ea66d2fb5b099d34c5bac81e7482c956276dfc234c8d2af5fd2394b5440d0708a2c9f124a53c0755e9595cf9f8adade5deefcb8a574a67debd3b74d08c49c23ddc14cd6d48b65dce500c8a5d330e760fe85bb\"));\n        let pvk_gamma_abc_g1: vector<Element<G1>> = vector[\n            std::option::extract(&mut deserialize<G1, FormatG1Compr>(&x\"b0df760d0f2d67fdff69d0ed3a0653dd8808df3c407ea4d0e27f8612c3fbb748cb4372d33cac512ee5ef4ee1683c3fe5\")),\n            std::option::extract(&mut deserialize<G1, FormatG1Compr>(&x\"96ec80d6b1050bbfc209f727678acce8788c05475771daffdd444ad8786c7a40195d859850fe2e72be3054e9fb8ce805\")),\n        ];\n        let public_inputs: vector<Element<Fr>> = vector[\n            std::option::extract(&mut deserialize<Fr, FormatFrLsb>(&x\"0ee291cfc951388c3c7f7c85ff2dfd42bbc66a6b4acaef9a5a51ce955125a74f\")),\n        ];\n        let proof_a = std::option::extract(&mut deserialize<G1, FormatG1Compr>(&x\"8a7c7364403d91bfa5c723ce93b920c8d2e559ea5e7e34eb68cea437aa4f26bf56ba22d9400988a86f2943c79401e959\"));\n        let proof_b = std::option::extract(&mut deserialize<G2, FormatG2Compr>(&x\"9352f8a2f9ff60d390e363d063354e9728adf39c91294499575855e803dd80eeaa1488cd24d1b80eb1b2625011e22a5d139e24f2c7ac3508874ec4bdb9c71ddf109e7853d641d23ed27bef265248d78eabe9137c03b088d8adbdf39e10f87eab\"));\n        let proof_c = std::option::extract(&mut deserialize<G1, FormatG1Compr>(&x\"896f68b438e076d3017e64aa47621fcd69b45f49a7038e2b1b9ed4f2de9b8eb8e0a76785a39a08f024435811a73a6818\"));\n\n        assert!(verify_proof_prepared_fq12<G1, G2, Gt, Fq12, Fr>(\n            &pvk_alpha_g1_beta_g2,\n            &pvk_gamma_g2_neg,\n            &pvk_delta_g2_neg,\n            &pvk_gamma_abc_g1,\n            &public_inputs,\n            &proof_a,\n            &proof_b,\n            &proof_c,\n        ), 1);\n    }\n}\n"
  },
  {
    "folderName": "hello_blockchain",
    "fileName": "hello_blockchain.move",
    "path": "aptos-core/aptos-move/move-examples/hello_blockchain/sources/hello_blockchain.move",
    "content": "module hello_blockchain::message {\n    use std::error;\n    use std::signer;\n    use std::string;\n    use aptos_framework::event;\n    #[test_only]\n    use std::debug;\n\n    //:!:>resource\n    struct MessageHolder has key {\n        message: string::String,\n    }\n    //<:!:resource\n\n    #[event]\n    struct MessageChange has drop, store {\n        account: address,\n        from_message: string::String,\n        to_message: string::String,\n    }\n\n    /// There is no message present\n    const ENO_MESSAGE: u64 = 0;\n\n    #[view]\n    public fun get_message(addr: address): string::String acquires MessageHolder {\n        assert!(exists<MessageHolder>(addr), error::not_found(ENO_MESSAGE));\n        borrow_global<MessageHolder>(addr).message\n    }\n\n    public entry fun set_message(account: signer, message: string::String)\n    acquires MessageHolder {\n        let account_addr = signer::address_of(&account);\n        if (!exists<MessageHolder>(account_addr)) {\n            move_to(&account, MessageHolder {\n                message,\n            })\n        } else {\n            let old_message_holder = borrow_global_mut<MessageHolder>(account_addr);\n            let from_message = old_message_holder.message;\n            event::emit(MessageChange {\n                account: account_addr,\n                from_message,\n                to_message: copy message,\n            });\n            old_message_holder.message = message;\n        }\n    }\n\n    #[test(account = @0x1)]\n    public entry fun sender_can_set_message(account: signer) acquires MessageHolder {\n        let msg: string::String = string::utf8(b\"Running test for sender_can_set_message...\");\n        debug::print(&msg);\n\n        let addr = signer::address_of(&account);\n        aptos_framework::account::create_account_for_test(addr);\n        set_message(account, string::utf8(b\"Hello, Blockchain\"));\n\n        assert!(\n            get_message(addr) == string::utf8(b\"Hello, Blockchain\"),\n            ENO_MESSAGE\n        );\n    }\n}\n"
  },
  {
    "folderName": "hello_blockchain",
    "fileName": "hello_blockchain_test.move",
    "path": "aptos-core/aptos-move/move-examples/hello_blockchain/sources/hello_blockchain_test.move",
    "content": "#[test_only]\nmodule hello_blockchain::message_tests {\n    use std::signer;\n    use std::unit_test;\n    use std::vector;\n    use std::string;\n\n    use hello_blockchain::message;\n\n    fun get_account(): signer {\n        vector::pop_back(&mut unit_test::create_signers_for_testing(1))\n    }\n\n    #[test]\n    public entry fun sender_can_set_message() {\n        let account = get_account();\n        let addr = signer::address_of(&account);\n        aptos_framework::account::create_account_for_test(addr);\n        message::set_message(account,  string::utf8(b\"Hello, Blockchain\"));\n\n        assert!(\n          message::get_message(addr) == string::utf8(b\"Hello, Blockchain\"),\n          0\n        );\n    }\n}\n"
  },
  {
    "folderName": "hello_prover",
    "fileName": "prove.move",
    "path": "aptos-core/aptos-move/move-examples/hello_prover/sources/prove.move",
    "content": "module 0x42::prove {\n    fun plus1(x: u64): u64 {\n        x+1\n    }\n    spec plus1 {\n        ensures result == x+1;\n    }\n\n    fun abortsIf0(x: u64) {\n        if (x == 0) {\n            abort(0)\n        };\n    }\n    spec abortsIf0 {\n        aborts_if x == 0;\n    }\n}\n"
  },
  {
    "folderName": "large_packages",
    "fileName": "large_packages.move",
    "path": "aptos-core/aptos-move/move-examples/large_packages/sources/large_packages.move",
    "content": "/// This provides a framework for uploading large packages to standard accounts or objects.\n/// In each pass, the caller pushes more code by calling `stage_code_chunk`.\n/// In the final call, the caller can use `stage_code_chunk_and_publish_to_account`, `stage_code_chunk_and_publish_to_object`, or\n/// `stage_code_chunk_and_upgrade_object_code` to upload the final data chunk and publish or upgrade the package on-chain.\n///\n/// Note that `code_indices` must not have gaps. For example, if `code_indices` are provided as [0, 1, 3]\n/// (skipping index 2), the inline function `assemble_module_code` will abort. This is because `StagingArea.last_module_idx`\n/// is set to the maximum value from `code_indices`. When `assemble_module_code` iterates over the range from 0 to\n/// `StagingArea.last_module_idx`, it expects each index to be present in the `StagingArea.code` SmartTable.\n/// Any missing index in this range will cause the function to fail.\nmodule large_packages::large_packages {\n    use std::error;\n    use std::signer;\n    use std::vector;\n    use aptos_std::smart_table::{Self, SmartTable};\n\n    use aptos_framework::code::{Self, PackageRegistry};\n    use aptos_framework::object::{Object};\n    use aptos_framework::object_code_deployment;\n\n    /// code_indices and code_chunks should be the same length.\n    const ECODE_MISMATCH: u64 = 1;\n    /// Object reference should be provided when upgrading object code.\n    const EMISSING_OBJECT_REFERENCE: u64 = 2;\n\n    struct StagingArea has key {\n        metadata_serialized: vector<u8>,\n        code: SmartTable<u64, vector<u8>>,\n        last_module_idx: u64,\n    }\n\n    public entry fun stage_code_chunk(\n        owner: &signer,\n        metadata_chunk: vector<u8>,\n        code_indices: vector<u16>,\n        code_chunks: vector<vector<u8>>,\n    ) acquires StagingArea {\n        stage_code_chunk_internal(owner, metadata_chunk, code_indices, code_chunks);\n    }\n\n    public entry fun stage_code_chunk_and_publish_to_account(\n        owner: &signer,\n        metadata_chunk: vector<u8>,\n        code_indices: vector<u16>,\n        code_chunks: vector<vector<u8>>,\n    ) acquires StagingArea {\n        let staging_area = stage_code_chunk_internal(owner, metadata_chunk, code_indices, code_chunks);\n        publish_to_account(owner, staging_area);\n        cleanup_staging_area(owner);\n    }\n\n    public entry fun stage_code_chunk_and_publish_to_object(\n        owner: &signer,\n        metadata_chunk: vector<u8>,\n        code_indices: vector<u16>,\n        code_chunks: vector<vector<u8>>,\n    ) acquires StagingArea {\n        let staging_area = stage_code_chunk_internal(owner, metadata_chunk, code_indices, code_chunks);\n        publish_to_object(owner, staging_area);\n        cleanup_staging_area(owner);\n    }\n\n    public entry fun stage_code_chunk_and_upgrade_object_code(\n        owner: &signer,\n        metadata_chunk: vector<u8>,\n        code_indices: vector<u16>,\n        code_chunks: vector<vector<u8>>,\n        code_object: Object<PackageRegistry>,\n    ) acquires StagingArea {\n        let staging_area = stage_code_chunk_internal(owner, metadata_chunk, code_indices, code_chunks);\n        upgrade_object_code(owner, staging_area, code_object);\n        cleanup_staging_area(owner);\n    }\n\n    inline fun stage_code_chunk_internal(\n        owner: &signer,\n        metadata_chunk: vector<u8>,\n        code_indices: vector<u16>,\n        code_chunks: vector<vector<u8>>,\n    ): &mut StagingArea acquires StagingArea {\n        assert!(\n            vector::length(&code_indices) == vector::length(&code_chunks),\n            error::invalid_argument(ECODE_MISMATCH),\n        );\n\n        let owner_address = signer::address_of(owner);\n\n        if (!exists<StagingArea>(owner_address)) {\n            move_to(owner, StagingArea {\n                metadata_serialized: vector[],\n                code: smart_table::new(),\n                last_module_idx: 0,\n            });\n        };\n\n        let staging_area = borrow_global_mut<StagingArea>(owner_address);\n\n        if (!vector::is_empty(&metadata_chunk)) {\n            vector::append(&mut staging_area.metadata_serialized, metadata_chunk);\n        };\n\n        let i = 0;\n        while (i < vector::length(&code_chunks)) {\n            let inner_code = *vector::borrow(&code_chunks, i);\n            let idx = (*vector::borrow(&code_indices, i) as u64);\n\n            if (smart_table::contains(&staging_area.code, idx)) {\n                vector::append(smart_table::borrow_mut(&mut staging_area.code, idx), inner_code);\n            } else {\n                smart_table::add(&mut staging_area.code, idx, inner_code);\n                if (idx > staging_area.last_module_idx) {\n                    staging_area.last_module_idx = idx;\n                }\n            };\n            i = i + 1;\n        };\n\n        staging_area\n    }\n\n    inline fun publish_to_account(\n        publisher: &signer,\n        staging_area: &mut StagingArea,\n    ) {\n        let code = assemble_module_code(staging_area);\n        code::publish_package_txn(publisher, staging_area.metadata_serialized, code);\n    }\n\n    inline fun publish_to_object(\n        publisher: &signer,\n        staging_area: &mut StagingArea,\n    ) {\n        let code = assemble_module_code(staging_area);\n        object_code_deployment::publish(publisher, staging_area.metadata_serialized, code);\n    }\n\n    inline fun upgrade_object_code(\n        publisher: &signer,\n        staging_area: &mut StagingArea,\n        code_object: Object<PackageRegistry>,\n    ) {\n        let code = assemble_module_code(staging_area);\n        object_code_deployment::upgrade(publisher, staging_area.metadata_serialized, code, code_object);\n    }\n\n    inline fun assemble_module_code(\n        staging_area: &mut StagingArea,\n    ): vector<vector<u8>> {\n        let last_module_idx = staging_area.last_module_idx;\n        let code = vector[];\n        let i = 0;\n        while (i <= last_module_idx) {\n            vector::push_back(\n                &mut code,\n                *smart_table::borrow(&staging_area.code, i)\n            );\n            i = i + 1;\n        };\n        code\n    }\n\n    public entry fun cleanup_staging_area(owner: &signer) acquires StagingArea {\n        let StagingArea {\n            metadata_serialized: _,\n            code,\n            last_module_idx: _,\n        } = move_from<StagingArea>(signer::address_of(owner));\n        smart_table::destroy(code);\n    }\n}\n"
  },
  {
    "folderName": "marketplace",
    "fileName": "coin_listing.move",
    "path": "aptos-core/aptos-move/move-examples/marketplace/sources/coin_listing.move",
    "content": "address marketplace {\n/// Defines a single listing or an item for sale or auction. This is an escrow service that\n/// enables two parties to exchange one asset for another.\n/// Each listing has the following properties:\n/// * FeeSchedule specifying payment flows\n/// * Owner or the person that can end the sale or auction\n/// * Optional buy it now price\n/// * Ending time at which point it can be claimed by the highest bidder or left in escrow.\n/// * For auctions, the minimum bid rate and optional increase in duration of the auction if bids\n///   are made toward the end of the auction.\nmodule coin_listing {\n    use std::error;\n    use std::option::{Self, Option};\n    use std::signer;\n    use std::string::{Self, String};\n    use aptos_std::math64;\n\n    use aptos_framework::coin::{Self, Coin};\n    use aptos_framework::object::{Self, ConstructorRef, Object, ObjectCore};\n    use aptos_framework::timestamp;\n\n    use marketplace::events;\n    use marketplace::fee_schedule::{Self, FeeSchedule};\n    use marketplace::listing::{Self, Listing};\n    use aptos_framework::aptos_account;\n\n    #[test_only]\n    friend marketplace::listing_tests;\n\n    /// There exists no listing.\n    const ENO_LISTING: u64 = 1;\n    /// This is an auction without buy it now.\n    const ENO_BUY_IT_NOW: u64 = 2;\n    /// The proposed bid is insufficient.\n    const EBID_TOO_LOW: u64 = 3;\n    /// The auction has not yet ended.\n    const EAUCTION_NOT_ENDED: u64 = 4;\n    /// The auction has already ended.\n    const EAUCTION_ENDED: u64 = 5;\n    /// The entity is not the seller.\n    const ENOT_SELLER: u64 = 6;\n\n    // Core data structures\n    const FIXED_PRICE_TYPE: vector<u8> = b\"fixed price\";\n    const AUCTION_TYPE: vector<u8> = b\"auction\";\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Fixed-price market place listing.\n    struct FixedPriceListing<phantom CoinType> has key {\n        /// The price to purchase the item up for listing.\n        price: u64,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// An auction-based listing with optional buy it now semantics.\n    struct AuctionListing<phantom CoinType> has key {\n        /// Starting bid price.\n        starting_bid: u64,\n        /// Price increment from the current bid.\n        bid_increment: u64,\n        /// Current bid, if one exists.\n        current_bid: Option<Bid<CoinType>>,\n        /// Auction end time in Unix time as seconds.\n        auction_end_time: u64,\n        /// If a bid time comes within this amount of time before the end bid, extend the end bid\n        /// to the current time plus this amount.\n        minimum_bid_time_before_end: u64,\n        /// Buy it now price, ends auction immediately.\n        buy_it_now_price: Option<u64>,\n    }\n\n    /// Represents a single bid within this auction house.\n    struct Bid<phantom CoinType> has store {\n        bidder: address,\n        coins: Coin<CoinType>,\n    }\n\n    // Init functions\n\n    public entry fun init_fixed_price<CoinType>(\n        seller: &signer,\n        object: Object<ObjectCore>,\n        fee_schedule: Object<FeeSchedule>,\n        start_time: u64,\n        price: u64,\n    ) {\n        init_fixed_price_internal<CoinType>(seller, object, fee_schedule, start_time, price);\n    }\n\n    public(friend) fun init_fixed_price_internal<CoinType>(\n        seller: &signer,\n        object: Object<ObjectCore>,\n        fee_schedule: Object<FeeSchedule>,\n        start_time: u64,\n        price: u64,\n    ): Object<Listing> {\n        let (listing_signer, constructor_ref) = init<CoinType>(\n            seller,\n            object,\n            fee_schedule,\n            start_time,\n            price,\n        );\n\n        let fixed_price_listing = FixedPriceListing<CoinType> {\n            price,\n        };\n        move_to(&listing_signer, fixed_price_listing);\n\n        let listing = object::object_from_constructor_ref(&constructor_ref);\n\n        events::emit_listing_placed(\n            fee_schedule,\n            string::utf8(FIXED_PRICE_TYPE),\n            object::object_address(&listing),\n            signer::address_of(seller),\n            price,\n            listing::token_metadata(listing),\n        );\n\n        listing\n    }\n\n    public entry fun init_fixed_price_for_tokenv1<CoinType>(\n        seller: &signer,\n        token_creator: address,\n        token_collection: String,\n        token_name: String,\n        token_property_version: u64,\n        fee_schedule: Object<FeeSchedule>,\n        start_time: u64,\n        price: u64,\n    ) {\n        init_fixed_price_for_tokenv1_internal<CoinType>(\n            seller,\n            token_creator,\n            token_collection,\n            token_name,\n            token_property_version,\n            fee_schedule,\n            start_time,\n            price,\n        );\n    }\n\n    public(friend) fun init_fixed_price_for_tokenv1_internal<CoinType>(\n        seller: &signer,\n        token_creator: address,\n        token_collection: String,\n        token_name: String,\n        token_property_version: u64,\n        fee_schedule: Object<FeeSchedule>,\n        start_time: u64,\n        price: u64,\n    ): Object<Listing> {\n        let object = listing::create_tokenv1_container(\n            seller,\n            token_creator,\n            token_collection,\n            token_name,\n            token_property_version,\n        );\n        init_fixed_price_internal<CoinType>(\n            seller,\n            object::convert(object),\n            fee_schedule,\n            start_time,\n            price,\n        )\n    }\n\n    public entry fun init_auction<CoinType>(\n        seller: &signer,\n        object: Object<ObjectCore>,\n        fee_schedule: Object<FeeSchedule>,\n        start_time: u64,\n        starting_bid: u64,\n        bid_increment: u64,\n        auction_end_time: u64,\n        minimum_bid_time_before_end: u64,\n        buy_it_now_price: Option<u64>,\n    ) {\n        init_auction_internal<CoinType>(\n            seller,\n            object,\n            fee_schedule,\n            start_time,\n            starting_bid,\n            bid_increment,\n            auction_end_time,\n            minimum_bid_time_before_end,\n            buy_it_now_price,\n        );\n    }\n\n    public(friend) fun init_auction_internal<CoinType>(\n        seller: &signer,\n        object: Object<ObjectCore>,\n        fee_schedule: Object<FeeSchedule>,\n        start_time: u64,\n        starting_bid: u64,\n        bid_increment: u64,\n        auction_end_time: u64,\n        minimum_bid_time_before_end: u64,\n        buy_it_now_price: Option<u64>,\n    ): Object<Listing> {\n        let (listing_signer, constructor_ref) = init<CoinType>(\n            seller,\n            object,\n            fee_schedule,\n            start_time,\n            starting_bid,\n        );\n\n        let auction_listing = AuctionListing<CoinType> {\n            starting_bid,\n            bid_increment,\n            current_bid: option::none(),\n            auction_end_time,\n            minimum_bid_time_before_end,\n            buy_it_now_price,\n        };\n        move_to(&listing_signer, auction_listing);\n        let listing = object::object_from_constructor_ref(&constructor_ref);\n\n        events::emit_listing_placed(\n            fee_schedule,\n            string::utf8(AUCTION_TYPE),\n            object::object_address(&listing),\n            signer::address_of(seller),\n            starting_bid,\n            listing::token_metadata(listing),\n        );\n\n        listing\n    }\n\n    public entry fun init_auction_for_tokenv1<CoinType>(\n        seller: &signer,\n        token_creator: address,\n        token_collection: String,\n        token_name: String,\n        token_property_version: u64,\n        fee_schedule: Object<FeeSchedule>,\n        start_time: u64,\n        starting_bid: u64,\n        bid_increment: u64,\n        auction_end_time: u64,\n        minimum_bid_time_before_end: u64,\n        buy_it_now_price: Option<u64>,\n    ) {\n        init_auction_for_tokenv1_internal<CoinType>(\n            seller,\n            token_creator,\n            token_collection,\n            token_name,\n            token_property_version,\n            fee_schedule,\n            start_time,\n            starting_bid,\n            bid_increment,\n            auction_end_time,\n            minimum_bid_time_before_end,\n            buy_it_now_price,\n        );\n    }\n\n    public(friend) fun init_auction_for_tokenv1_internal<CoinType>(\n        seller: &signer,\n        token_creator: address,\n        token_collection: String,\n        token_name: String,\n        token_property_version: u64,\n        fee_schedule: Object<FeeSchedule>,\n        start_time: u64,\n        starting_bid: u64,\n        bid_increment: u64,\n        auction_end_time: u64,\n        minimum_bid_time_before_end: u64,\n        buy_it_now_price: Option<u64>,\n    ): Object<Listing> {\n        let object = listing::create_tokenv1_container(\n            seller,\n            token_creator,\n            token_collection,\n            token_name,\n            token_property_version,\n        );\n        init_auction_internal<CoinType>(\n            seller,\n            object::convert(object),\n            fee_schedule,\n            start_time,\n            starting_bid,\n            bid_increment,\n            auction_end_time,\n            minimum_bid_time_before_end,\n            buy_it_now_price,\n        )\n    }\n\n    inline fun init<CoinType>(\n        seller: &signer,\n        object: Object<ObjectCore>,\n        fee_schedule: Object<FeeSchedule>,\n        start_time: u64,\n        initial_price: u64,\n    ): (signer, ConstructorRef) {\n        aptos_account::transfer_coins<CoinType>(\n            seller,\n            fee_schedule::fee_address(fee_schedule),\n            fee_schedule::listing_fee(fee_schedule, initial_price),\n        );\n\n        listing::init(seller, object, fee_schedule, start_time)\n    }\n\n    // Mutators\n\n    /// Purchase outright an item from an auction or a fixed price listing.\n    public entry fun purchase<CoinType>(\n        purchaser: &signer,\n        object: Object<Listing>,\n    ) acquires AuctionListing, FixedPriceListing {\n        let listing_addr = listing::assert_started(&object);\n\n        // Retrieve the purchase price if the auction has buy it now or this is a fixed listing.\n        let (price, type) = if (exists<AuctionListing<CoinType>>(listing_addr)) {\n            let AuctionListing {\n                starting_bid: _,\n                bid_increment: _,\n                current_bid,\n                auction_end_time,\n                minimum_bid_time_before_end: _,\n                buy_it_now_price,\n            } = move_from<AuctionListing<CoinType>>(listing_addr);\n\n            let now = timestamp::now_seconds();\n            assert!(now < auction_end_time, error::invalid_state(EAUCTION_ENDED));\n\n            assert!(option::is_some(&buy_it_now_price), error::invalid_argument(ENO_BUY_IT_NOW));\n            if (option::is_some(&current_bid)) {\n                let Bid { bidder, coins } = option::destroy_some(current_bid);\n                aptos_account::deposit_coins(bidder, coins);\n            } else {\n                option::destroy_none(current_bid);\n            };\n            (option::destroy_some(buy_it_now_price), string::utf8(AUCTION_TYPE))\n        } else if (exists<FixedPriceListing<CoinType>>(listing_addr)) {\n            let FixedPriceListing {\n                price,\n            } = move_from<FixedPriceListing<CoinType>>(listing_addr);\n            (price, string::utf8(FIXED_PRICE_TYPE))\n        } else {\n            // This should just be an abort but the compiler errors.\n            abort (error::not_found(ENO_LISTING))\n        };\n\n        let coins = coin::withdraw<CoinType>(purchaser, price);\n\n        complete_purchase(purchaser, signer::address_of(purchaser), object, coins, type)\n    }\n\n    /// End a fixed price listing early.\n    public entry fun end_fixed_price<CoinType>(\n        seller: &signer,\n        object: Object<Listing>,\n    ) acquires FixedPriceListing {\n        let token_metadata = listing::token_metadata(object);\n\n        let expected_seller_addr = signer::address_of(seller);\n        let (actual_seller_addr, fee_schedule) = listing::close(seller, object, expected_seller_addr);\n        assert!(expected_seller_addr == actual_seller_addr, error::permission_denied(ENOT_SELLER));\n\n        let listing_addr = object::object_address(&object);\n        assert!(exists<FixedPriceListing<CoinType>>(listing_addr), error::not_found(ENO_LISTING));\n        let FixedPriceListing {\n            price,\n        } = move_from<FixedPriceListing<CoinType>>(listing_addr);\n\n        events::emit_listing_canceled(\n            fee_schedule,\n            string::utf8(FIXED_PRICE_TYPE),\n            listing_addr,\n            actual_seller_addr,\n            price,\n            token_metadata,\n        );\n    }\n\n    /// Make a bid on a listing. If the listing comes in near the end of an auction, the auction\n    /// may be extended to give at least minimum_bid_time_before_end time remaining in the auction.\n    public entry fun bid<CoinType>(\n        bidder: &signer,\n        object: Object<Listing>,\n        bid_amount: u64,\n    ) acquires AuctionListing {\n        let listing_addr = listing::assert_started(&object);\n        assert!(exists<AuctionListing<CoinType>>(listing_addr), error::not_found(ENO_LISTING));\n        let auction_listing = borrow_global_mut<AuctionListing<CoinType>>(listing_addr);\n\n        let now = timestamp::now_seconds();\n        assert!(now < auction_listing.auction_end_time, error::invalid_state(EAUCTION_ENDED));\n\n        let (previous_bidder, previous_bid, minimum_bid) = if (option::is_some(&auction_listing.current_bid)) {\n            let Bid { bidder, coins } = option::extract(&mut auction_listing.current_bid);\n            let current_bid = coin::value(&coins);\n            aptos_account::deposit_coins(bidder, coins);\n            (option::some(bidder), option::some(current_bid), current_bid + auction_listing.bid_increment)\n        } else {\n            (option::none(), option::none(), auction_listing.starting_bid)\n        };\n\n        assert!(bid_amount >= minimum_bid, error::invalid_argument(EBID_TOO_LOW));\n        let coins = coin::withdraw<CoinType>(bidder, bid_amount);\n        let bid = Bid {\n            bidder: signer::address_of(bidder),\n            coins,\n        };\n        option::fill(&mut auction_listing.current_bid, bid);\n\n        let fee_schedule = listing::fee_schedule(object);\n        aptos_account::transfer_coins<CoinType>(\n            bidder,\n            fee_schedule::fee_address(fee_schedule),\n            fee_schedule::bidding_fee(fee_schedule, bid_amount),\n        );\n\n        let now = timestamp::now_seconds();\n        let current_end_time = auction_listing.auction_end_time;\n        let minimum_end_time = now + auction_listing.minimum_bid_time_before_end;\n\n        if (current_end_time < minimum_end_time) {\n            auction_listing.auction_end_time = minimum_end_time\n        };\n\n        events::emit_bid_event(\n            fee_schedule,\n            listing_addr,\n            signer::address_of(bidder),\n            bid_amount,\n            auction_listing.auction_end_time,\n            previous_bidder,\n            previous_bid,\n            current_end_time,\n            listing::token_metadata(object),\n        );\n    }\n\n    /// Once the current time has elapsed the auctions run time, allow the auction to be settled by\n    /// distributing out the asset to the winner or the auction seller if no one bid as well as\n    /// giving any fees to the marketplace that hosted the auction.\n    public entry fun complete_auction<CoinType>(\n        completer: &signer,\n        object: Object<Listing>,\n    ) acquires AuctionListing {\n        let listing_addr = listing::assert_started(&object);\n        assert!(exists<AuctionListing<CoinType>>(listing_addr), error::not_found(ENO_LISTING));\n\n        let AuctionListing {\n            starting_bid: _,\n            bid_increment: _,\n            current_bid,\n            auction_end_time,\n            minimum_bid_time_before_end: _,\n            buy_it_now_price: _,\n        } = move_from<AuctionListing<CoinType>>(listing_addr);\n\n        let now = timestamp::now_seconds();\n        assert!(auction_end_time <= now, error::invalid_state(EAUCTION_NOT_ENDED));\n\n        let seller = listing::seller(object);\n\n        let (purchaser, coins) = if (option::is_some(&current_bid)) {\n            let Bid { bidder, coins } = option::destroy_some(current_bid);\n            (bidder, coins)\n        } else {\n            option::destroy_none(current_bid);\n            (seller, coin::zero<CoinType>())\n        };\n\n        complete_purchase(completer, purchaser, object, coins, string::utf8(AUCTION_TYPE));\n    }\n\n    inline fun complete_purchase<CoinType>(\n        completer: &signer,\n        purchaser_addr: address,\n        object: Object<Listing>,\n        coins: Coin<CoinType>,\n        type: String,\n    ) {\n        let token_metadata = listing::token_metadata(object);\n\n        let price = coin::value(&coins);\n        let (royalty_addr, royalty_charge) = listing::compute_royalty(object, price);\n        let (seller, fee_schedule) = listing::close(completer, object, purchaser_addr);\n\n        // Take royalty first\n        if (royalty_charge != 0) {\n            let royalty = coin::extract(&mut coins, royalty_charge);\n            aptos_account::deposit_coins(royalty_addr, royalty);\n        };\n\n        // Take commission of what's left, creators get paid first\n        let commission_charge = fee_schedule::commission(fee_schedule, price);\n        let actual_commission_charge = math64::min(coin::value(&coins), commission_charge);\n        let commission = coin::extract(&mut coins, actual_commission_charge);\n        aptos_account::deposit_coins(fee_schedule::fee_address(fee_schedule), commission);\n\n        // Seller gets what is left\n        aptos_account::deposit_coins(seller, coins);\n\n        events::emit_listing_filled(\n            fee_schedule,\n            type,\n            object::object_address(&object),\n            seller,\n            purchaser_addr,\n            price,\n            commission_charge,\n            royalty_charge,\n            token_metadata,\n        );\n    }\n\n    // View\n\n    #[view]\n    public fun price<CoinType>(\n        object: Object<Listing>,\n    ): Option<u64> acquires AuctionListing, FixedPriceListing {\n        let listing_addr = object::object_address(&object);\n        if (exists<FixedPriceListing<CoinType>>(listing_addr)) {\n            let fixed_price = borrow_global<FixedPriceListing<CoinType>>(listing_addr);\n            option::some(fixed_price.price)\n        } else if (exists<AuctionListing<CoinType>>(listing_addr)) {\n            borrow_global<AuctionListing<CoinType>>(listing_addr).buy_it_now_price\n        } else {\n            // This should just be an abort but the compiler errors.\n            assert!(false, error::not_found(ENO_LISTING));\n            option::none()\n        }\n    }\n\n    #[view]\n    public fun is_auction<CoinType>(object: Object<Listing>): bool {\n        let obj_addr = object::object_address(&object);\n        exists<AuctionListing<CoinType>>(obj_addr)\n    }\n\n    #[view]\n    public fun starting_bid<CoinType>(object: Object<Listing>): u64 acquires AuctionListing {\n        let auction = borrow_auction<CoinType>(object);\n        auction.starting_bid\n    }\n\n    #[view]\n    public fun bid_increment<CoinType>(object: Object<Listing>): u64 acquires AuctionListing {\n        let auction = borrow_auction<CoinType>(object);\n        auction.bid_increment\n    }\n\n    #[view]\n    public fun auction_end_time<CoinType>(object: Object<Listing>): u64 acquires AuctionListing {\n        let auction = borrow_auction<CoinType>(object);\n        auction.auction_end_time\n    }\n\n    #[view]\n    public fun minimum_bid_time_before_end<CoinType>(\n        object: Object<Listing>,\n    ): u64 acquires AuctionListing {\n        let auction = borrow_auction<CoinType>(object);\n        auction.minimum_bid_time_before_end\n    }\n\n    #[view]\n    public fun current_bidder<CoinType>(\n        object: Object<Listing>,\n    ): Option<address> acquires AuctionListing {\n        let auction = borrow_auction<CoinType>(object);\n        if (option::is_some(&auction.current_bid)) {\n            option::some(option::borrow(&auction.current_bid).bidder)\n        } else {\n            option::none()\n        }\n    }\n\n    #[view]\n    public fun current_amount<CoinType>(\n        object: Object<Listing>,\n    ): Option<u64> acquires AuctionListing {\n        let auction = borrow_auction<CoinType>(object);\n        if (option::is_some(&auction.current_bid)) {\n            let coins = &option::borrow(&auction.current_bid).coins;\n            option::some(coin::value(coins))\n        } else {\n            option::none()\n        }\n    }\n\n    inline fun borrow_auction<CoinType>(\n        object: Object<Listing>,\n    ): &AuctionListing<CoinType> acquires AuctionListing {\n        let obj_addr = object::object_address(&object);\n        assert!(exists<AuctionListing<CoinType>>(obj_addr), error::not_found(ENO_LISTING));\n        borrow_global<AuctionListing<CoinType>>(obj_addr)\n    }\n\n    inline fun borrow_fixed_price<CoinType>(\n        object: Object<Listing>,\n    ): &FixedPriceListing<CoinType> acquires FixedPriceListing {\n        let obj_addr = object::object_address(&object);\n        assert!(exists<FixedPriceListing<CoinType>>(obj_addr), error::not_found(ENO_LISTING));\n        borrow_global<FixedPriceListing<CoinType>>(obj_addr)\n    }\n}\n\n// Tests\n\n#[test_only]\nmodule listing_tests {\n    use std::option;\n\n    use aptos_framework::aptos_coin::AptosCoin;\n    use aptos_framework::coin;\n    use aptos_framework::object::{Self, Object};\n    use aptos_framework::timestamp;\n\n    use aptos_token::token as tokenv1;\n\n    use aptos_token_objects::token::Token;\n    use marketplace::test_utils::{mint_tokenv2_with_collection_royalty, mint_tokenv1_additional_royalty, mint_tokenv1};\n\n    use marketplace::coin_listing;\n    use marketplace::fee_schedule::FeeSchedule;\n    use marketplace::listing::{Self, Listing};\n    use marketplace::test_utils;\n\n    fun test_fixed_price(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (marketplace_addr, seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let (token, fee_schedule, listing) = fixed_price_listing(marketplace, seller);\n\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 1, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 9999, 0);\n        assert!(listing::listed_object(listing) == object::convert(token), 0);\n        assert!(listing::fee_schedule(listing) == fee_schedule, 0);\n        assert!(coin_listing::price<AptosCoin>(listing) == option::some(500), 0);\n        assert!(!coin_listing::is_auction<AptosCoin>(listing), 0);\n\n        coin_listing::purchase<AptosCoin>(purchaser, listing);\n\n        assert!(object::owner(token) == purchaser_addr, 0);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 6, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 10494, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 9500, 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_fixed_price_high_royalty(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (marketplace_addr, seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        // TODO: add test that separates seller and creator\n        let (_collection, additional_token) = mint_tokenv2_with_collection_royalty(seller, 100, 100);\n        let (token, fee_schedule, listing) = fixed_price_listing_with_token(marketplace, seller, additional_token);\n\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 1, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 9999, 0);\n        assert!(listing::listed_object(listing) == object::convert(token), 0);\n        assert!(listing::fee_schedule(listing) == fee_schedule, 0);\n        assert!(coin_listing::price<AptosCoin>(listing) == option::some(500), 0);\n        assert!(!coin_listing::is_auction<AptosCoin>(listing), 0);\n\n        coin_listing::purchase<AptosCoin>(purchaser, listing);\n\n        assert!(object::owner(token) == purchaser_addr, 0);\n        // Because royalty is 100, no commission is taken just the listing fee\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 1, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 10499, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 9500, 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_fixed_price_end(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (marketplace_addr, seller_addr, _purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let (token, _fee_schedule, listing) = fixed_price_listing(marketplace, seller);\n\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 1, 0);\n        coin_listing::end_fixed_price<AptosCoin>(seller, listing);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 1, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 9999, 0);\n        assert!(object::owner(token) == seller_addr, 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_auction_purchase(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (marketplace_addr, seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let (token, fee_schedule, listing) = auction_listing(marketplace, seller);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 1, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 9999, 0);\n        assert!(listing::listed_object(listing) == object::convert(token), 0);\n        assert!(listing::fee_schedule(listing) == fee_schedule, 0);\n        assert!(coin_listing::price<AptosCoin>(listing) == option::some(500), 0);\n        assert!(coin_listing::is_auction<AptosCoin>(listing), 0);\n        assert!(coin_listing::starting_bid<AptosCoin>(listing) == 100, 0);\n        assert!(coin_listing::bid_increment<AptosCoin>(listing) == 50, 0);\n        assert!(coin_listing::auction_end_time<AptosCoin>(listing) == timestamp::now_seconds() + 200, 0);\n        assert!(coin_listing::minimum_bid_time_before_end<AptosCoin>(listing) == 150, 0);\n        assert!(coin_listing::current_amount<AptosCoin>(listing) == option::none(), 0);\n        assert!(coin_listing::current_bidder<AptosCoin>(listing) == option::none(), 0);\n\n        coin_listing::purchase<AptosCoin>(purchaser, listing);\n\n        assert!(object::owner(token) == purchaser_addr, 0);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 6, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 10494, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 9500, 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_auction_bid_then_purchase(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (marketplace_addr, seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let (token, _fee_schedule, listing) = auction_listing(marketplace, seller);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 1, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 9999, 0);\n\n        coin_listing::bid<AptosCoin>(seller, listing, 100);\n        assert!(coin_listing::current_amount<AptosCoin>(listing) == option::some(100), 0);\n        assert!(coin_listing::current_bidder<AptosCoin>(listing) == option::some(seller_addr), 0);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 3, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 9897, 0);\n\n        // Return the bid and insert a new bid\n        coin_listing::bid<AptosCoin>(purchaser, listing, 150);\n        assert!(coin_listing::current_amount<AptosCoin>(listing) == option::some(150), 0);\n        assert!(coin_listing::current_bidder<AptosCoin>(listing) == option::some(purchaser_addr), 0);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 5, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 9997, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 9848, 0);\n\n        // Return the bid and replace with a purchase\n        coin_listing::purchase<AptosCoin>(purchaser, listing);\n        assert!(object::owner(token) == purchaser_addr, 0);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 10, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 9498, 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_auction_bidding(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (marketplace_addr, seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let (token, _fee_schedule, listing) = auction_listing(marketplace, seller);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 1, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 9999, 0);\n        let end_time = timestamp::now_seconds() + 200;\n        assert!(coin_listing::auction_end_time<AptosCoin>(listing) == end_time, 0);\n\n        // Bid but do not affect end timing\n        coin_listing::bid<AptosCoin>(seller, listing, 100);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 3, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 9897, 0);\n        assert!(coin_listing::auction_end_time<AptosCoin>(listing) == end_time, 0);\n\n        // Return the bid and insert a new bid and affect end timing\n        test_utils::increment_timestamp(150);\n        coin_listing::bid<AptosCoin>(purchaser, listing, 150);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 5, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 9997, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 9848, 0);\n        assert!(coin_listing::auction_end_time<AptosCoin>(listing) != end_time, 0);\n\n        // End the auction as out of time\n        test_utils::increment_timestamp(150);\n        coin_listing::complete_auction<AptosCoin>(aptos_framework, listing);\n        assert!(object::owner(token) == purchaser_addr, 0);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 6, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 10146, 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_ended_auction_no_bid(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (marketplace_addr, seller_addr, _purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let (token, _fee_schedule, listing) = auction_listing(marketplace, seller);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 1, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 9999, 0);\n\n        test_utils::increment_timestamp(200);\n        coin_listing::complete_auction<AptosCoin>(aptos_framework, listing);\n\n        assert!(object::owner(token) == seller_addr, 0);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 1, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 9999, 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x30002, location = marketplace::listing)]\n    fun test_not_started_fixed_price(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let token = test_utils::mint_tokenv2(seller);\n        let fee_schedule = test_utils::fee_schedule(marketplace);\n        let listing = coin_listing::init_fixed_price_internal<AptosCoin>(\n            seller,\n            object::convert(token),\n            fee_schedule,\n            timestamp::now_seconds() + 1,\n            500,\n        );\n\n        coin_listing::purchase<AptosCoin>(purchaser, listing);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x30002, location = marketplace::listing)]\n    fun test_not_started_auction(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let token = test_utils::mint_tokenv2(seller);\n        let fee_schedule = test_utils::fee_schedule(marketplace);\n        let listing = coin_listing::init_auction_internal<AptosCoin>(\n            seller,\n            object::convert(token),\n            fee_schedule,\n            timestamp::now_seconds() + 1,\n            100,\n            50,\n            timestamp::now_seconds() + 200,\n            150,\n            option::some(500),\n        );\n\n        coin_listing::bid<AptosCoin>(purchaser, listing, 1000);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x30005, location = marketplace::coin_listing)]\n    fun test_ended_auction_bid(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let (_token, _fee_schedule, listing) = auction_listing(marketplace, seller);\n        test_utils::increment_timestamp(200);\n        coin_listing::bid<AptosCoin>(purchaser, listing, 1000);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x30005, location = marketplace::coin_listing)]\n    fun test_ended_auction_purchase(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let (_token, _fee_schedule, listing) = auction_listing(marketplace, seller);\n        test_utils::increment_timestamp(200);\n        coin_listing::purchase<AptosCoin>(purchaser, listing);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x10006, location = aptos_framework::coin)]\n    fun test_not_enough_coin_fixed_price(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let token = test_utils::mint_tokenv2(seller);\n        let fee_schedule = test_utils::fee_schedule(marketplace);\n        let listing = coin_listing::init_fixed_price_internal<AptosCoin>(\n            seller,\n            object::convert(token),\n            fee_schedule,\n            timestamp::now_seconds(),\n            100000,\n        );\n\n        coin_listing::purchase<AptosCoin>(purchaser, listing);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x10006, location = aptos_framework::coin)]\n    fun test_not_enough_coin_auction_bid(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let (_token, _fee_schedule, listing) = auction_listing(marketplace, seller);\n        coin_listing::bid<AptosCoin>(purchaser, listing, 100000);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x10003, location = marketplace::coin_listing)]\n    fun test_bid_too_low(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let (_token, _fee_schedule, listing) = auction_listing(marketplace, seller);\n        coin_listing::bid<AptosCoin>(purchaser, listing, 100);\n        coin_listing::bid<AptosCoin>(purchaser, listing, 125);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x10006, location = aptos_framework::coin)]\n    fun test_not_enough_coin_auction_purchase(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let token = test_utils::mint_tokenv2(seller);\n        let fee_schedule = test_utils::fee_schedule(marketplace);\n        let listing = coin_listing::init_auction_internal<AptosCoin>(\n            seller,\n            object::convert(token),\n            fee_schedule,\n            timestamp::now_seconds(),\n            100,\n            50,\n            timestamp::now_seconds() + 200,\n            150,\n            option::some(50000),\n        );\n\n        coin_listing::purchase<AptosCoin>(purchaser, listing);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x60001, location = marketplace::coin_listing)]\n    fun test_auction_view_on_fixed_price(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let (_token, _fee_schedule, listing) = fixed_price_listing(marketplace, seller);\n        coin_listing::auction_end_time<AptosCoin>(listing);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x10002, location = marketplace::coin_listing)]\n    fun test_purchase_on_auction_without_buy_it_now(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let token = test_utils::mint_tokenv2(seller);\n        let fee_schedule = test_utils::fee_schedule(marketplace);\n        let listing = coin_listing::init_auction_internal<AptosCoin>(\n            seller,\n            object::convert(token),\n            fee_schedule,\n            timestamp::now_seconds(),\n            100,\n            50,\n            timestamp::now_seconds() + 200,\n            150,\n            option::none(),\n        );\n\n        coin_listing::purchase<AptosCoin>(purchaser, listing);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x50006, location = marketplace::coin_listing)]\n    fun test_bad_fixed_price_end(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let (_token, _fee_schedule, listing) = fixed_price_listing(marketplace, seller);\n        coin_listing::end_fixed_price<AptosCoin>(purchaser, listing);\n    }\n\n    // Objects and TokenV2 stuff\n\n    inline fun fixed_price_listing(\n        marketplace: &signer,\n        seller: &signer,\n    ): (Object<Token>, Object<FeeSchedule>, Object<Listing>) {\n        let token = test_utils::mint_tokenv2(seller);\n        fixed_price_listing_with_token(marketplace, seller, token)\n    }\n\n    inline fun fixed_price_listing_with_token(\n        marketplace: &signer,\n        seller: &signer,\n        token: Object<Token>\n    ): (Object<Token>, Object<FeeSchedule>, Object<Listing>) {\n        let fee_schedule = test_utils::fee_schedule(marketplace);\n        let listing = coin_listing::init_fixed_price_internal<AptosCoin>(\n            seller,\n            object::convert(token),\n            fee_schedule,\n            timestamp::now_seconds(),\n            500,\n        );\n        (token, fee_schedule, listing)\n    }\n\n\n    inline fun auction_listing(\n        marketplace: &signer,\n        seller: &signer,\n    ): (Object<Token>, Object<FeeSchedule>, Object<Listing>) {\n        let token = test_utils::mint_tokenv2(seller);\n        let fee_schedule = test_utils::fee_schedule(marketplace);\n        let listing = coin_listing::init_auction_internal<AptosCoin>(\n            seller,\n            object::convert(token),\n            fee_schedule,\n            timestamp::now_seconds(),\n            100,\n            50,\n            timestamp::now_seconds() + 200,\n            150,\n            option::some(500),\n        );\n        (token, fee_schedule, listing)\n    }\n\n    // TokenV1\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_fixed_price_for_token_v1(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (_marketplace_addr, _seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        tokenv1::opt_in_direct_transfer(purchaser, true);\n\n        let (token_id, _fee_schedule, listing) = fixed_price_listing_for_tokenv1(marketplace, seller);\n        coin_listing::purchase<AptosCoin>(purchaser, listing);\n        assert!(tokenv1::balance_of(purchaser_addr, token_id) == 1, 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_fixed_price_for_token_v1_high_royalty(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (_marketplace_addr, _seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        tokenv1::opt_in_direct_transfer(purchaser, true);\n        let _token = mint_tokenv1(seller);\n        let token_id = mint_tokenv1_additional_royalty(seller, 100, 100);\n\n        let (_fee_schedule, listing) = fixed_price_listing_for_tokenv1_with_token(marketplace, seller, &token_id);\n        coin_listing::purchase<AptosCoin>(purchaser, listing);\n        assert!(tokenv1::balance_of(purchaser_addr, token_id) == 1, 0);\n        // TODO balance checks\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_fixed_price_for_token_v1_bad_royalty(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (_marketplace_addr, _seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        tokenv1::opt_in_direct_transfer(purchaser, true);\n        let _token = mint_tokenv1(seller);\n        let token_id = mint_tokenv1_additional_royalty(seller, 0, 0);\n\n        let (_fee_schedule, listing) = fixed_price_listing_for_tokenv1_with_token(marketplace, seller, &token_id);\n        // This should not fail, and no royalty is taken\n        coin_listing::purchase<AptosCoin>(purchaser, listing);\n        assert!(tokenv1::balance_of(purchaser_addr, token_id) == 1, 0);\n        // TODO balance checks\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_auction_purchase_for_tokenv1(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (_marketplace_addr, _seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        tokenv1::opt_in_direct_transfer(purchaser, true);\n\n        let (token_id, _fee_schedule, listing) = auction_listing_for_tokenv1(marketplace, seller);\n        coin_listing::purchase<AptosCoin>(purchaser, listing);\n        assert!(tokenv1::balance_of(purchaser_addr, token_id) == 1, 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_auction_purchase_for_tokenv1_without_direct_transfer(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (_marketplace_addr, _seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let (token_id, _fee_schedule, listing) = auction_listing_for_tokenv1(marketplace, seller);\n        coin_listing::purchase<AptosCoin>(purchaser, listing);\n        assert!(tokenv1::balance_of(purchaser_addr, token_id) == 1, 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_auction_win_for_tokenv1_without_direct_transfer_and_non_winner_completer(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (_marketplace_addr, _seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let (token_id, _fee_schedule, listing) = auction_listing_for_tokenv1(marketplace, seller);\n        coin_listing::bid<AptosCoin>(purchaser, listing, 100);\n        test_utils::increment_timestamp(1000);\n        let token_object = listing::listed_object(listing);\n        coin_listing::complete_auction<AptosCoin>(aptos_framework, listing);\n        listing::extract_tokenv1(purchaser, object::convert(token_object));\n        assert!(tokenv1::balance_of(purchaser_addr, token_id) == 1, 0);\n    }\n\n    inline fun fixed_price_listing_for_tokenv1(\n        marketplace: &signer,\n        seller: &signer,\n    ): (tokenv1::TokenId, Object<FeeSchedule>, Object<Listing>) {\n        let token_id = test_utils::mint_tokenv1(seller);\n        let (fee_schedule, listing) = fixed_price_listing_for_tokenv1_with_token(marketplace, seller, &token_id);\n        (token_id, fee_schedule, listing)\n    }\n\n    inline fun fixed_price_listing_for_tokenv1_with_token(\n        marketplace: &signer,\n        seller: &signer,\n        token_id: &tokenv1::TokenId,\n    ): (Object<FeeSchedule>, Object<Listing>) {\n        let (creator_addr, collection_name, token_name, property_version) =\n            tokenv1::get_token_id_fields(token_id);\n        let fee_schedule = test_utils::fee_schedule(marketplace);\n        let listing = coin_listing::init_fixed_price_for_tokenv1_internal<AptosCoin>(\n            seller,\n            creator_addr,\n            collection_name,\n            token_name,\n            property_version,\n            fee_schedule,\n            timestamp::now_seconds(),\n            500,\n        );\n        (fee_schedule, listing)\n    }\n\n    inline fun auction_listing_for_tokenv1(\n        marketplace: &signer,\n        seller: &signer,\n    ): (tokenv1::TokenId, Object<FeeSchedule>, Object<Listing>) {\n        let token_id = test_utils::mint_tokenv1(seller);\n        let (creator_addr, collection_name, token_name, property_version) =\n            tokenv1::get_token_id_fields(&token_id);\n        let fee_schedule = test_utils::fee_schedule(marketplace);\n        let listing = coin_listing::init_auction_for_tokenv1_internal<AptosCoin>(\n            seller,\n            creator_addr,\n            collection_name,\n            token_name,\n            property_version,\n            fee_schedule,\n            timestamp::now_seconds(),\n            100,\n            50,\n            timestamp::now_seconds() + 200,\n            150,\n            option::some(500),\n        );\n        (token_id, fee_schedule, listing)\n    }\n}\n}\n"
  },
  {
    "folderName": "marketplace",
    "fileName": "collection_offer.move",
    "path": "aptos-core/aptos-move/move-examples/marketplace/sources/collection_offer.move",
    "content": "address marketplace {\n/// Provides the ability to make collection offers to both Tokenv1 and Tokenv2 collections.\n/// A collection offer allows an entity to buy up to N assets within a collection at their\n/// specified amount. The amount offered is extracted from their account and stored at an\n/// escrow. A seller can then exchange the token for the escrowed payment. If it is a\n/// a tokenv2 or the recipient has enabled direct deposit, the token is immediately\n/// transferred. If it is tokenv1 without direct deposit, it is stored in a container\n/// until the recipient extracts it.\nmodule collection_offer {\n    use std::error;\n    use std::option::{Self, Option};\n    use std::signer;\n    use std::string::String;\n    use aptos_std::math64;\n\n    use aptos_framework::coin::{Self, Coin};\n    use aptos_framework::object::{Self, DeleteRef, Object};\n    use aptos_framework::timestamp;\n\n    use aptos_token::token as tokenv1;\n\n    use aptos_token_objects::collection::Collection;\n    use aptos_token_objects::royalty;\n    use aptos_token_objects::token::{Self as tokenv2, Token as TokenV2};\n\n    use marketplace::events;\n    use marketplace::fee_schedule::{Self, FeeSchedule};\n    use marketplace::listing::{Self, TokenV1Container};\n    use aptos_framework::aptos_account;\n\n    /// No collection offer defined.\n    const ENO_COLLECTION_OFFER: u64 = 1;\n    /// No coin offer defined.\n    const ENO_COIN_OFFER: u64 = 2;\n    /// No token offer defined.\n    const ENO_TOKEN_OFFER: u64 = 3;\n    /// This is not the owner of the collection offer.\n    const ENOT_OWNER: u64 = 4;\n    /// The offered token is not within the expected collection.\n    const EINCORRECT_COLLECTION: u64 = 5;\n    /// The collection offer has expired.\n    const EEXPIRED: u64 = 6;\n\n    // Core data structures\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Create a timed offer to buy tokens from a collection. The collection and\n    /// assets used to buy are stored in other resources within the object.\n    struct CollectionOffer has key {\n        fee_schedule: Object<FeeSchedule>,\n        item_price: u64,\n        remaining: u64,\n        expiration_time: u64,\n        delete_ref: DeleteRef,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Stores coins for a collection offer.\n    struct CoinOffer<phantom CoinType> has key {\n        coins: Coin<CoinType>,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Stores the metadata associated with a tokenv1 collection offer.\n    struct CollectionOfferTokenV1 has copy, drop, key {\n        creator_address: address,\n        collection_name: String,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Stores the metadata associated with a tokenv2 collection offer.\n    struct CollectionOfferTokenV2 has copy, drop, key {\n        collection: Object<Collection>,\n    }\n\n    // Initializers\n\n    /// Create a tokenv1 collection offer.\n    public entry fun init_for_tokenv1_entry<CoinType>(\n        purchaser: &signer,\n        creator_address: address,\n        collection_name: String,\n        fee_schedule: Object<FeeSchedule>,\n        item_price: u64,\n        amount: u64,\n        expiration_time: u64,\n    ) {\n        init_for_tokenv1<CoinType>(\n            purchaser,\n            creator_address,\n            collection_name,\n            fee_schedule,\n            item_price,\n            amount,\n            expiration_time\n        );\n    }\n\n    public fun init_for_tokenv1<CoinType>(\n        purchaser: &signer,\n        creator_address: address,\n        collection_name: String,\n        fee_schedule: Object<FeeSchedule>,\n        item_price: u64,\n        amount: u64,\n        expiration_time: u64,\n    ): Object<CollectionOffer> {\n        let offer_signer = init_offer(purchaser, fee_schedule, item_price, amount, expiration_time);\n        init_coin_holder<CoinType>(purchaser, &offer_signer, fee_schedule, item_price * amount);\n        move_to(&offer_signer, CollectionOfferTokenV1 { creator_address, collection_name });\n\n        let collection_offer_addr = signer::address_of(&offer_signer);\n        events::emit_collection_offer_placed(\n            fee_schedule,\n            collection_offer_addr,\n            signer::address_of(purchaser),\n            item_price,\n            amount,\n            events::collection_metadata_for_tokenv1(creator_address, collection_name),\n        );\n\n        object::address_to_object(collection_offer_addr)\n    }\n\n    /// Create a tokenv2 collection offer.\n    public entry fun init_for_tokenv2_entry<CoinType>(\n        purchaser: &signer,\n        collection: Object<Collection>,\n        fee_schedule: Object<FeeSchedule>,\n        item_price: u64,\n        amount: u64,\n        expiration_time: u64,\n    ) {\n        init_for_tokenv2<CoinType>(\n            purchaser,\n            collection,\n            fee_schedule,\n            item_price,\n            amount,\n            expiration_time\n        );\n    }\n\n    public fun init_for_tokenv2<CoinType>(\n        purchaser: &signer,\n        collection: Object<Collection>,\n        fee_schedule: Object<FeeSchedule>,\n        item_price: u64,\n        amount: u64,\n        expiration_time: u64,\n    ): Object<CollectionOffer> {\n        let offer_signer = init_offer(purchaser, fee_schedule, item_price, amount, expiration_time);\n        init_coin_holder<CoinType>(purchaser, &offer_signer, fee_schedule, item_price * amount);\n        move_to(&offer_signer, CollectionOfferTokenV2 { collection });\n\n        let collection_offer_addr = signer::address_of(&offer_signer);\n        events::emit_collection_offer_placed(\n            fee_schedule,\n            collection_offer_addr,\n            signer::address_of(purchaser),\n            item_price,\n            amount,\n            events::collection_metadata_for_tokenv2(collection),\n        );\n\n        object::address_to_object(collection_offer_addr)\n    }\n\n    inline fun init_offer(\n        purchaser: &signer,\n        fee_schedule: Object<FeeSchedule>,\n        item_price: u64,\n        amount: u64,\n        expiration_time: u64,\n    ): signer {\n        let constructor_ref = object::create_object_from_account(purchaser);\n        // Once we construct this, both the listing and its contents are soulbound until the conclusion.\n        let transfer_ref = object::generate_transfer_ref(&constructor_ref);\n        object::disable_ungated_transfer(&transfer_ref);\n\n        let offer_signer = object::generate_signer(&constructor_ref);\n        let offer = CollectionOffer {\n            fee_schedule,\n            item_price,\n            remaining: amount,\n            expiration_time,\n            delete_ref: object::generate_delete_ref(&constructor_ref),\n        };\n        move_to(&offer_signer, offer);\n\n        offer_signer\n    }\n\n    inline fun init_coin_holder<CoinType>(\n        purchaser: &signer,\n        offer_signer: &signer,\n        fee_schedule: Object<FeeSchedule>,\n        total_to_extract: u64,\n    ) {\n        let fee = fee_schedule::listing_fee(fee_schedule, total_to_extract);\n        let fee_address = fee_schedule::fee_address(fee_schedule);\n        aptos_account::transfer_coins<CoinType>(purchaser, fee_address, fee);\n\n        let coins = coin::withdraw<CoinType>(purchaser, total_to_extract);\n        move_to(offer_signer, CoinOffer { coins });\n    }\n\n    // Mutators\n\n    ///\n    public entry fun cancel<CoinType>(\n        purchaser: &signer,\n        collection_offer: Object<CollectionOffer>,\n    ) acquires CoinOffer, CollectionOffer, CollectionOfferTokenV1, CollectionOfferTokenV2 {\n        let collection_offer_addr = object::object_address(&collection_offer);\n        assert!(\n            exists<CollectionOffer>(collection_offer_addr),\n            error::not_found(ENO_COLLECTION_OFFER),\n        );\n        assert!(\n            object::is_owner(collection_offer, signer::address_of(purchaser)),\n            error::permission_denied(ENOT_OWNER),\n        );\n        let collection_offer_obj = borrow_global_mut<CollectionOffer>(collection_offer_addr);\n        let collection_metadata = if (exists<CollectionOfferTokenV2>(collection_offer_addr)) {\n            events::collection_metadata_for_tokenv2(\n                borrow_global<CollectionOfferTokenV2>(collection_offer_addr).collection,\n            )\n        } else {\n            let offer_info = borrow_global<CollectionOfferTokenV1>(collection_offer_addr);\n            events::collection_metadata_for_tokenv1(\n                offer_info.creator_address,\n                offer_info.collection_name,\n            )\n        };\n\n        events::emit_collection_offer_canceled(\n            collection_offer_obj.fee_schedule,\n            collection_offer_addr,\n            signer::address_of(purchaser),\n            collection_offer_obj.item_price,\n            collection_offer_obj.remaining,\n            collection_metadata,\n        );\n\n        cleanup<CoinType>(collection_offer);\n    }\n\n    /// Sell a tokenv1 to a collection offer.\n    public entry fun sell_tokenv1_entry<CoinType>(\n        seller: &signer,\n        collection_offer: Object<CollectionOffer>,\n        token_name: String,\n        property_version: u64,\n    ) acquires CoinOffer, CollectionOffer, CollectionOfferTokenV1, CollectionOfferTokenV2\n    {\n        sell_tokenv1<CoinType>(seller, collection_offer, token_name, property_version);\n    }\n\n    /// Sell a tokenv1 to a collection offer.\n    public fun sell_tokenv1<CoinType>(\n        seller: &signer,\n        collection_offer: Object<CollectionOffer>,\n        token_name: String,\n        property_version: u64,\n    ): Option<Object<TokenV1Container>>\n    acquires\n    CoinOffer,\n    CollectionOffer,\n    CollectionOfferTokenV1,\n    CollectionOfferTokenV2\n    {\n        let collection_offer_addr = object::object_address(&collection_offer);\n        assert!(\n            exists<CollectionOfferTokenV1>(collection_offer_addr),\n            error::not_found(ENO_TOKEN_OFFER),\n        );\n        let collection_offer_tokenv1_offer =\n            borrow_global_mut<CollectionOfferTokenV1>(collection_offer_addr);\n\n        // Move the token to its destination\n\n        let token_id = tokenv1::create_token_id_raw(\n            collection_offer_tokenv1_offer.creator_address,\n            collection_offer_tokenv1_offer.collection_name,\n            token_name,\n            property_version,\n        );\n\n        let token = tokenv1::withdraw_token(seller, token_id, 1);\n\n        let recipient = object::owner(collection_offer);\n        let container = if (tokenv1::get_direct_transfer(recipient)) {\n            tokenv1::direct_deposit_with_opt_in(recipient, token);\n            option::none()\n        } else {\n            let container = listing::create_tokenv1_container_with_token(seller, token);\n            object::transfer(seller, container, recipient);\n            option::some(container)\n        };\n\n        // Pay fees\n\n        let royalty = tokenv1::get_royalty(token_id);\n        settle_payments<CoinType>(\n            object::owner(collection_offer),\n            signer::address_of(seller),\n            collection_offer_addr,\n            tokenv1::get_royalty_payee(&royalty),\n            tokenv1::get_royalty_denominator(&royalty),\n            tokenv1::get_royalty_numerator(&royalty),\n            events::token_metadata_for_tokenv1(token_id),\n        );\n\n        container\n    }\n\n    /// Sell a tokenv2 to a collection offer.\n    public entry fun sell_tokenv2<CoinType>(\n        seller: &signer,\n        collection_offer: Object<CollectionOffer>,\n        token: Object<TokenV2>,\n    ) acquires CoinOffer, CollectionOffer, CollectionOfferTokenV1, CollectionOfferTokenV2 {\n        let collection_offer_addr = object::object_address(&collection_offer);\n        assert!(\n            exists<CollectionOfferTokenV2>(collection_offer_addr),\n            error::not_found(ENO_TOKEN_OFFER),\n        );\n        let collection_offer_token_v2 =\n            borrow_global_mut<CollectionOfferTokenV2>(collection_offer_addr);\n\n        // Move the token to its destination\n\n        assert!(\n            tokenv2::collection_object(token) == collection_offer_token_v2.collection,\n            error::invalid_argument(EINCORRECT_COLLECTION),\n        );\n        let recipient = object::owner(collection_offer);\n        object::transfer(seller, token, recipient);\n\n        // Pay fees\n\n        let royalty = tokenv2::royalty(token);\n        let (royalty_payee, royalty_denominator, royalty_numerator) = if (option::is_some(&royalty)) {\n            let royalty = option::destroy_some(royalty);\n            let payee_address = royalty::payee_address(&royalty);\n            let denominator = royalty::denominator(&royalty);\n            let numerator = royalty::numerator(&royalty);\n            (payee_address, denominator, numerator)\n        } else {\n            (signer::address_of(seller), 1, 0)\n        };\n\n        settle_payments<CoinType>(\n            object::owner(collection_offer),\n            signer::address_of(seller),\n            collection_offer_addr,\n            royalty_payee,\n            royalty_denominator,\n            royalty_numerator,\n            events::token_metadata_for_tokenv2(token),\n        );\n    }\n\n    /// From the coin offer remove appropriate payment for the token and distribute to the seller,\n    /// the creator for royalties, and the marketplace for commission. If there are no more slots,\n    /// cleanup the offer.\n    inline fun settle_payments<CoinType>(\n        buyer: address,\n        seller: address,\n        collection_offer_addr: address,\n        royalty_payee: address,\n        royalty_denominator: u64,\n        royalty_numerator: u64,\n        token_metadata: events::TokenMetadata,\n    ) acquires CoinOffer, CollectionOffer, CollectionOfferTokenV1, CollectionOfferTokenV2 {\n        assert!(exists<CollectionOffer>(collection_offer_addr), error::not_found(ENO_COLLECTION_OFFER));\n        let collection_offer_obj = borrow_global_mut<CollectionOffer>(collection_offer_addr);\n        assert!(\n            timestamp::now_seconds() < collection_offer_obj.expiration_time,\n            error::invalid_state(EEXPIRED),\n        );\n        let price = collection_offer_obj.item_price;\n\n        assert!(\n            exists<CoinOffer<CoinType>>(collection_offer_addr),\n            error::not_found(ENO_COIN_OFFER),\n        );\n        let coin_offer = borrow_global_mut<CoinOffer<CoinType>>(collection_offer_addr);\n        let coins = coin::extract(&mut coin_offer.coins, price);\n\n        let royalty_charge = listing::bounded_percentage(price, royalty_numerator, royalty_denominator);\n\n        let royalties = coin::extract(&mut coins, royalty_charge);\n        aptos_account::deposit_coins(royalty_payee, royalties);\n\n        // Commission can only be of whatever is left\n        let fee_schedule = collection_offer_obj.fee_schedule;\n        let commission_charge = fee_schedule::commission(fee_schedule, price);\n        let actual_commission_charge = math64::min(commission_charge, coin::value(&coins));\n        let commission = coin::extract(&mut coins, actual_commission_charge);\n        aptos_account::deposit_coins(fee_schedule::fee_address(fee_schedule), commission);\n\n        // Seller gets what is left\n        aptos_account::deposit_coins(seller, coins);\n\n        events::emit_collection_offer_filled(\n            fee_schedule,\n            collection_offer_addr,\n            buyer,\n            seller,\n            price,\n            royalty_charge,\n            commission_charge,\n            token_metadata,\n        );\n\n        collection_offer_obj.remaining = collection_offer_obj.remaining - 1;\n        if (collection_offer_obj.remaining == 0) {\n            cleanup<CoinType>(object::address_to_object(collection_offer_addr));\n        };\n    }\n\n    /// Cleanup the offer by deleting it and returning the remaining funds to the collection offer\n    /// creator.\n    inline fun cleanup<CoinType>(\n        collection_offer: Object<CollectionOffer>,\n    ) acquires CoinOffer, CollectionOffer, CollectionOfferTokenV1, CollectionOfferTokenV2 {\n        let collection_offer_addr = object::object_address(&collection_offer);\n        let CoinOffer<CoinType> { coins } = move_from(collection_offer_addr);\n        aptos_account::deposit_coins(object::owner(collection_offer), coins);\n\n        let CollectionOffer {\n            fee_schedule: _,\n            item_price: _,\n            remaining: _,\n            expiration_time: _,\n            delete_ref,\n        } = move_from(collection_offer_addr);\n        object::delete(delete_ref);\n\n        if (exists<CollectionOfferTokenV2>(collection_offer_addr)) {\n            move_from<CollectionOfferTokenV2>(collection_offer_addr);\n        } else if (exists<CollectionOfferTokenV1>(collection_offer_addr)) {\n            move_from<CollectionOfferTokenV1>(collection_offer_addr);\n        };\n    }\n\n    // View\n\n    #[view]\n    public fun exists_at(collection_offer: Object<CollectionOffer>): bool {\n        exists<CollectionOffer>(object::object_address(&collection_offer))\n    }\n\n    #[view]\n    public fun expired(collection_offer: Object<CollectionOffer>): bool acquires CollectionOffer {\n        borrow_collection_offer(collection_offer).expiration_time < timestamp::now_seconds()\n    }\n\n    #[view]\n    public fun expiration_time(\n        collection_offer: Object<CollectionOffer>,\n    ): u64 acquires CollectionOffer {\n        borrow_collection_offer(collection_offer).expiration_time\n    }\n\n    #[view]\n    public fun fee_schedule(\n        collection_offer: Object<CollectionOffer>,\n    ): Object<FeeSchedule> acquires CollectionOffer {\n        borrow_collection_offer(collection_offer).fee_schedule\n    }\n\n    #[view]\n    public fun price(collection_offer: Object<CollectionOffer>): u64 acquires CollectionOffer {\n        borrow_collection_offer(collection_offer).item_price\n    }\n\n    #[view]\n    public fun remaining(collection_offer: Object<CollectionOffer>): u64 acquires CollectionOffer {\n        borrow_collection_offer(collection_offer).remaining\n    }\n\n    #[view]\n    public fun collectionv1(\n        collection_offer: Object<CollectionOffer>,\n    ): CollectionOfferTokenV1 acquires CollectionOfferTokenV1 {\n        let collection_offer_addr = object::object_address(&collection_offer);\n        assert!(\n            exists<CollectionOfferTokenV1>(collection_offer_addr),\n            error::not_found(ENO_TOKEN_OFFER),\n        );\n        *borrow_global(collection_offer_addr)\n    }\n\n    #[view]\n    public fun collectionv2(\n        collection_offer: Object<CollectionOffer>,\n    ): CollectionOfferTokenV2 acquires CollectionOfferTokenV2 {\n        let collection_offer_addr = object::object_address(&collection_offer);\n        assert!(\n            exists<CollectionOffer>(collection_offer_addr),\n            error::not_found(ENO_COLLECTION_OFFER),\n        );\n        *borrow_global(collection_offer_addr)\n    }\n\n    inline fun borrow_collection_offer(\n        collection_offer: Object<CollectionOffer>,\n    ): &CollectionOffer acquires CollectionOffer {\n        let collection_offer_addr = object::object_address(&collection_offer);\n        assert!(\n            exists<CollectionOffer>(collection_offer_addr),\n            error::not_found(ENO_COLLECTION_OFFER),\n        );\n        borrow_global(collection_offer_addr)\n    }\n}\n\n#[test_only]\nmodule collection_offer_tests {\n    use std::string;\n    use std::option;\n\n    use aptos_framework::aptos_coin::AptosCoin;\n    use aptos_framework::coin;\n    use aptos_framework::object;\n    use aptos_framework::timestamp;\n\n    use aptos_token::token as tokenv1;\n\n    use aptos_token_objects::collection as collectionv2;\n\n    use marketplace::collection_offer;\n    use marketplace::listing;\n    use marketplace::test_utils;\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_token_v2(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (marketplace_addr, seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        let (collection, token) = test_utils::mint_tokenv2_with_collection(seller);\n        assert!(object::is_owner(token, seller_addr), 0);\n        let collection_offer = collection_offer::init_for_tokenv2<AptosCoin>(\n            purchaser,\n            collection,\n            test_utils::fee_schedule(marketplace),\n            500,\n            2,\n            timestamp::now_seconds() + 200,\n        );\n        assert!(!collection_offer::expired(collection_offer), 0);\n        assert!(collection_offer::expiration_time(collection_offer) == timestamp::now_seconds() + 200, 0);\n        assert!(collection_offer::price(collection_offer) == 500, 0);\n\n        assert!(collection_offer::remaining(collection_offer) == 2, 0);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 1, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 8999, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 10000, 0);\n\n        collection_offer::sell_tokenv2<AptosCoin>(seller, collection_offer, token);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 6, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 8999, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 10495, 0);\n        assert!(object::is_owner(token, purchaser_addr), 0);\n        assert!(collection_offer::remaining(collection_offer) == 1, 0);\n\n        collection_offer::sell_tokenv2<AptosCoin>(purchaser, collection_offer, token);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 11, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 9489, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 10500, 0);\n        assert!(object::is_owner(token, purchaser_addr), 0);\n        assert!(!collection_offer::exists_at(collection_offer), 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_token_v2_high_royalty(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (marketplace_addr, seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        let (collection, token) = test_utils::mint_tokenv2_with_collection_royalty(seller, 1, 1);\n        assert!(object::is_owner(token, seller_addr), 0);\n        let collection_offer = collection_offer::init_for_tokenv2<AptosCoin>(\n            purchaser,\n            collection,\n            test_utils::fee_schedule(marketplace),\n            500,\n            2,\n            timestamp::now_seconds() + 200,\n        );\n        assert!(!collection_offer::expired(collection_offer), 0);\n        assert!(collection_offer::expiration_time(collection_offer) == timestamp::now_seconds() + 200, 0);\n        assert!(collection_offer::price(collection_offer) == 500, 0);\n\n        assert!(collection_offer::remaining(collection_offer) == 2, 0);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 1, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 8999, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 10000, 0);\n\n        collection_offer::sell_tokenv2<AptosCoin>(seller, collection_offer, token);\n        assert!(object::is_owner(token, purchaser_addr), 0);\n        assert!(collection_offer::remaining(collection_offer) == 1, 0);\n\n        collection_offer::sell_tokenv2<AptosCoin>(purchaser, collection_offer, token);\n        assert!(object::is_owner(token, purchaser_addr), 0);\n        assert!(!collection_offer::exists_at(collection_offer), 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_token_v1_direct_deposit(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (marketplace_addr, seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        tokenv1::opt_in_direct_transfer(purchaser, true);\n        tokenv1::opt_in_direct_transfer(seller, true);\n\n        let token_id = test_utils::mint_tokenv1(seller);\n        assert!(tokenv1::balance_of(seller_addr, token_id) == 1, 0);\n\n        let (creator_addr, collection_name, token_name, property_version) =\n            tokenv1::get_token_id_fields(&token_id);\n\n        let collection_offer = collection_offer::init_for_tokenv1<AptosCoin>(\n            purchaser,\n            creator_addr,\n            collection_name,\n            test_utils::fee_schedule(marketplace),\n            500,\n            2,\n            timestamp::now_seconds() + 200,\n        );\n\n        assert!(collection_offer::remaining(collection_offer) == 2, 0);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 1, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 8999, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 10000, 0);\n\n        collection_offer::sell_tokenv1<AptosCoin>(seller, collection_offer, token_name, property_version);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 6, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 8999, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 10495, 0);\n        assert!(tokenv1::balance_of(purchaser_addr, token_id) == 1, 0);\n        assert!(collection_offer::remaining(collection_offer) == 1, 0);\n\n        collection_offer::sell_tokenv1<AptosCoin>(purchaser, collection_offer, token_name, property_version);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 11, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 9489, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 10500, 0);\n        assert!(tokenv1::balance_of(purchaser_addr, token_id) == 1, 0);\n        assert!(!collection_offer::exists_at(collection_offer), 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_token_v1_indirect(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (_marketplace_addr, seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let token_id = test_utils::mint_tokenv1(seller);\n        assert!(tokenv1::balance_of(seller_addr, token_id) == 1, 0);\n\n        let (creator_addr, collection_name, token_name, property_version) =\n            tokenv1::get_token_id_fields(&token_id);\n\n        let collection_offer = collection_offer::init_for_tokenv1<AptosCoin>(\n            purchaser,\n            creator_addr,\n            collection_name,\n            test_utils::fee_schedule(marketplace),\n            500,\n            1,\n            timestamp::now_seconds() + 200,\n        );\n\n        let token_container = collection_offer::sell_tokenv1<AptosCoin>(\n            seller,\n            collection_offer,\n            token_name,\n            property_version,\n        );\n        listing::extract_tokenv1(purchaser, option::destroy_some(token_container));\n        assert!(tokenv1::balance_of(purchaser_addr, token_id) == 1, 0);\n        assert!(!collection_offer::exists_at(collection_offer), 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x50004, location = aptos_framework::object)]\n    fun test_token_v2_has_none(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        let (collection, token) = test_utils::mint_tokenv2_with_collection(seller);\n        let collection_offer = collection_offer::init_for_tokenv2<AptosCoin>(\n            purchaser,\n            collection,\n            test_utils::fee_schedule(marketplace),\n            500,\n            2,\n            timestamp::now_seconds() + 200,\n        );\n        collection_offer::sell_tokenv2<AptosCoin>(marketplace, collection_offer, token);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x10005, location = aptos_token::token)]\n    fun test_token_v1_has_none(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        let token_id = test_utils::mint_tokenv1(seller);\n        let (creator_addr, collection_name, token_name, property_version) =\n            tokenv1::get_token_id_fields(&token_id);\n\n        let collection_offer = collection_offer::init_for_tokenv1<AptosCoin>(\n            purchaser,\n            creator_addr,\n            collection_name,\n            test_utils::fee_schedule(marketplace),\n            500,\n            1,\n            timestamp::now_seconds() + 200,\n        );\n\n        collection_offer::sell_tokenv1<AptosCoin>(\n            marketplace,\n            collection_offer,\n            token_name,\n            property_version,\n        );\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x30006, location = marketplace::collection_offer)]\n    fun test_token_v2_expired(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        let (collection, token) = test_utils::mint_tokenv2_with_collection(seller);\n        let collection_offer = collection_offer::init_for_tokenv2<AptosCoin>(\n            purchaser,\n            collection,\n            test_utils::fee_schedule(marketplace),\n            500,\n            2,\n            timestamp::now_seconds() + 200,\n        );\n        test_utils::increment_timestamp(200);\n        collection_offer::sell_tokenv2<AptosCoin>(seller, collection_offer, token);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x60003, location = marketplace::collection_offer)]\n    fun test_token_v2_exhausted(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        let (collection, token) = test_utils::mint_tokenv2_with_collection(seller);\n        let collection_offer = collection_offer::init_for_tokenv2<AptosCoin>(\n            purchaser,\n            collection,\n            test_utils::fee_schedule(marketplace),\n            500,\n            2,\n            timestamp::now_seconds() + 200,\n        );\n        collection_offer::sell_tokenv2<AptosCoin>(seller, collection_offer, token);\n        collection_offer::sell_tokenv2<AptosCoin>(purchaser, collection_offer, token);\n        collection_offer::sell_tokenv2<AptosCoin>(purchaser, collection_offer, token);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x10005, location = marketplace::collection_offer)]\n    fun test_token_v2_other_collection(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        let token = test_utils::mint_tokenv2(seller);\n\n        let other_collection = collectionv2::create_unlimited_collection(\n            purchaser,\n            string::utf8(b\"...\"),\n            string::utf8(b\"...\"),\n            option::none(),\n            string::utf8(b\"...\"),\n        );\n\n        let collection_offer = collection_offer::init_for_tokenv2<AptosCoin>(\n            purchaser,\n            object::object_from_constructor_ref(&other_collection),\n            test_utils::fee_schedule(marketplace),\n            500,\n            2,\n            timestamp::now_seconds() + 200,\n        );\n        collection_offer::sell_tokenv2<AptosCoin>(marketplace, collection_offer, token);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x10005, location = aptos_token::token)]\n    fun test_token_v1_other_collection(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (_marketplace_addr, _seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        tokenv1::create_collection(\n            purchaser,\n            string::utf8(b\"...\"),\n            string::utf8(b\"...\"),\n            string::utf8(b\"...\"),\n            1,\n            vector[true, true, true],\n        );\n\n        let collection_offer = collection_offer::init_for_tokenv1<AptosCoin>(\n            purchaser,\n            purchaser_addr,\n            string::utf8(b\"...\"),\n            test_utils::fee_schedule(marketplace),\n            500,\n            1,\n            timestamp::now_seconds() + 200,\n        );\n\n        let token_id = test_utils::mint_tokenv1(seller);\n        let (_creator_addr, _collection_name, token_name, property_version) =\n            tokenv1::get_token_id_fields(&token_id);\n        collection_offer::sell_tokenv1<AptosCoin>(\n            marketplace,\n            collection_offer,\n            token_name,\n            property_version,\n        );\n    }\n}\n}\n"
  },
  {
    "folderName": "marketplace",
    "fileName": "events.move",
    "path": "aptos-core/aptos-move/move-examples/marketplace/sources/events.move",
    "content": "/// Defines all the events associated with a marketplace. Note: this is attached to a FeeSchedule.\nmodule marketplace::events {\n    use std::option::{Self, Option};\n    use std::string::String;\n\n    use aptos_framework::event;\n    use aptos_framework::object::{Self, Object};\n\n    use aptos_token::token as tokenv1;\n    use aptos_token_objects::collection as collectionv2;\n    use aptos_token_objects::token as tokenv2;\n\n    friend marketplace::coin_listing;\n    friend marketplace::collection_offer;\n    friend marketplace::fee_schedule;\n    friend marketplace::listing;\n    friend marketplace::token_offer;\n\n    // TokenMetadata and helpers\n    struct TokenMetadata has drop, store {\n        creator_address: address,\n        collection_name: String,\n        collection: Option<Object<collectionv2::Collection>>,\n        token_name: String,\n        token: Option<Object<tokenv2::Token>>,\n        property_version: Option<u64>,\n    }\n\n    public fun token_metadata_for_tokenv1(token_id: tokenv1::TokenId): TokenMetadata {\n        let (creator_address, collection_name, token_name, property_version) =\n            tokenv1::get_token_id_fields(&token_id);\n\n        TokenMetadata {\n            creator_address,\n            collection_name,\n            collection: option::none(),\n            token_name,\n            token: option::none(),\n            property_version: option::some(property_version),\n        }\n    }\n\n    public fun token_metadata_for_tokenv2(token: Object<tokenv2::Token>): TokenMetadata {\n        TokenMetadata {\n            creator_address: tokenv2::creator(token),\n            collection_name: tokenv2::collection_name(token),\n            collection: option::some(tokenv2::collection_object(token)),\n            token_name: tokenv2::name(token),\n            token: option::some(token),\n            property_version: option::none(),\n        }\n    }\n\n    // CollectionMetadata and helpers\n\n    struct CollectionMetadata has drop, store {\n        creator_address: address,\n        collection_name: String,\n        collection: Option<Object<collectionv2::Collection>>,\n    }\n\n    public fun collection_metadata_for_tokenv1(\n        creator_address: address,\n        collection_name: String,\n    ): CollectionMetadata {\n        CollectionMetadata {\n            creator_address,\n            collection_name,\n            collection: option::none(),\n        }\n    }\n\n    public fun collection_metadata_for_tokenv2(\n        collection: Object<collectionv2::Collection>,\n    ): CollectionMetadata {\n        CollectionMetadata {\n            creator_address: collectionv2::creator(collection),\n            collection_name: collectionv2::name(collection),\n            collection: option::some(collection),\n        }\n    }\n\n    // Listing events\n\n    #[event]\n    /// An event triggered upon each bid.\n    struct AuctionBid has drop, store {\n        marketplace: address,\n        listing: address,\n        new_bidder: address,\n        new_bid: u64,\n        new_end_time: u64,\n        previous_bidder: Option<address>,\n        previous_bid: Option<u64>,\n        previous_end_time: u64,\n        token_metadata: TokenMetadata,\n    }\n\n    public(friend) fun emit_bid_event<T: key>(\n        marketplace: Object<T>,\n        listing: address,\n        new_bidder: address,\n        new_bid: u64,\n        new_end_time: u64,\n        previous_bidder: Option<address>,\n        previous_bid: Option<u64>,\n        previous_end_time: u64,\n        token_metadata: TokenMetadata,\n    ) {\n        event::emit(AuctionBid {\n            marketplace: object::object_address(&marketplace),\n            listing,\n            new_bidder,\n            new_bid,\n            new_end_time,\n            previous_bidder,\n            previous_bid,\n            previous_end_time,\n            token_metadata,\n        });\n    }\n\n    #[event]\n    struct ListingPlaced has drop, store {\n        marketplace: address,\n        type: String,\n        listing: address,\n        seller: address,\n        price: u64,\n        token_metadata: TokenMetadata\n    }\n\n    public(friend) fun emit_listing_placed<T: key>(\n        marketplace: Object<T>,\n        type: String,\n        listing: address,\n        seller: address,\n        price: u64,\n        token_metadata: TokenMetadata,\n    ) {\n        event::emit(ListingPlaced {\n            marketplace: object::object_address(&marketplace),\n            type,\n            listing,\n            seller,\n            price,\n            token_metadata,\n        });\n    }\n\n    #[event]\n    struct ListingCanceled has drop, store {\n        marketplace: address,\n        type: String,\n        listing: address,\n        seller: address,\n        price: u64,\n        token_metadata: TokenMetadata\n    }\n\n    public(friend) fun emit_listing_canceled<T: key>(\n        marketplace: Object<T>,\n        type: String,\n        listing: address,\n        seller: address,\n        price: u64,\n        token_metadata: TokenMetadata,\n    ) {\n        event::emit(ListingCanceled {\n            marketplace: object::object_address(&marketplace),\n            type,\n            listing,\n            seller,\n            price,\n            token_metadata,\n        });\n    }\n\n    #[event]\n    struct ListingFilled has drop, store {\n        marketplace: address,\n        type: String,\n        listing: address,\n        seller: address,\n        purchaser: address,\n        price: u64,\n        commission: u64,\n        royalties: u64,\n        token_metadata: TokenMetadata\n    }\n\n    public(friend) fun emit_listing_filled<T: key>(\n        marketplace: Object<T>,\n        type: String,\n        listing: address,\n        seller: address,\n        purchaser: address,\n        price: u64,\n        commission: u64,\n        royalties: u64,\n        token_metadata: TokenMetadata,\n    ) {\n        event::emit(ListingFilled {\n            marketplace: object::object_address(&marketplace),\n            type,\n            listing,\n            seller,\n            purchaser,\n            price,\n            commission,\n            royalties,\n            token_metadata,\n        });\n    }\n\n    // Collection offer events\n\n    #[event]\n    struct CollectionOfferPlaced has drop, store {\n        marketplace: address,\n        collection_offer: address,\n        purchaser: address,\n        price: u64,\n        token_amount: u64,\n        collection_metadata: CollectionMetadata,\n    }\n\n    public(friend) fun emit_collection_offer_placed<T: key>(\n        marketplace: Object<T>,\n        collection_offer: address,\n        purchaser: address,\n        price: u64,\n        token_amount: u64,\n        collection_metadata: CollectionMetadata,\n    ) {\n        event::emit(CollectionOfferPlaced {\n            marketplace: object::object_address(&marketplace),\n            collection_offer,\n            purchaser,\n            price,\n            token_amount,\n            collection_metadata,\n        });\n    }\n\n    #[event]\n    struct CollectionOfferCanceled has drop, store {\n        marketplace: address,\n        collection_offer: address,\n        purchaser: address,\n        price: u64,\n        remaining_token_amount: u64,\n        collection_metadata: CollectionMetadata,\n    }\n\n    public(friend) fun emit_collection_offer_canceled<T: key>(\n        marketplace: Object<T>,\n        collection_offer: address,\n        purchaser: address,\n        price: u64,\n        remaining_token_amount: u64,\n        collection_metadata: CollectionMetadata,\n    ) {\n        event::emit(CollectionOfferCanceled {\n            marketplace: object::object_address(&marketplace),\n            collection_offer,\n            purchaser,\n            price,\n            remaining_token_amount,\n            collection_metadata,\n        });\n    }\n\n    #[event]\n    struct CollectionOfferFilled has drop, store {\n        marketplace: address,\n        collection_offer: address,\n        purchaser: address,\n        seller: address,\n        price: u64,\n        royalties: u64,\n        commission: u64,\n        token_metadata: TokenMetadata,\n    }\n\n    public(friend) fun emit_collection_offer_filled<T: key>(\n        marketplace: Object<T>,\n        collection_offer: address,\n        purchaser: address,\n        seller: address,\n        price: u64,\n        royalties: u64,\n        commission: u64,\n        token_metadata: TokenMetadata,\n    ) {\n        event::emit(CollectionOfferFilled {\n            marketplace: object::object_address(&marketplace),\n            collection_offer,\n            purchaser,\n            seller,\n            price,\n            royalties,\n            commission,\n            token_metadata,\n        });\n    }\n\n    #[event]\n    // Token offer events\n    struct TokenOfferPlaced has drop, store {\n        marketplace: address,\n        token_offer: address,\n        purchaser: address,\n        price: u64,\n        token_metadata: TokenMetadata,\n    }\n\n    public(friend) fun emit_token_offer_placed<T: key>(\n        marketplace: Object<T>,\n        token_offer: address,\n        purchaser: address,\n        price: u64,\n        token_metadata: TokenMetadata,\n    ) {\n        event::emit(TokenOfferPlaced {\n            marketplace: object::object_address(&marketplace),\n            token_offer,\n            purchaser,\n            price,\n            token_metadata,\n        });\n    }\n\n    #[event]\n    struct TokenOfferCanceled has drop, store {\n        marketplace: address,\n        token_offer: address,\n        purchaser: address,\n        price: u64,\n        token_metadata: TokenMetadata,\n    }\n\n    public(friend) fun emit_token_offer_canceled<T: key>(\n        marketplace: Object<T>,\n        token_offer: address,\n        purchaser: address,\n        price: u64,\n        token_metadata: TokenMetadata,\n    ) {\n        event::emit(TokenOfferCanceled {\n            marketplace: object::object_address(&marketplace),\n            token_offer,\n            purchaser,\n            price,\n            token_metadata,\n        });\n    }\n\n    #[event]\n    struct TokenOfferFilled has drop, store {\n        marketplace: address,\n        token_offer: address,\n        purchaser: address,\n        seller: address,\n        price: u64,\n        royalties: u64,\n        commission: u64,\n        token_metadata: TokenMetadata,\n    }\n\n    public(friend) fun emit_token_offer_filled<T: key>(\n        marketplace: Object<T>,\n        token_offer: address,\n        purchaser: address,\n        seller: address,\n        price: u64,\n        royalties: u64,\n        commission: u64,\n        token_metadata: TokenMetadata,\n    ) {\n        event::emit(TokenOfferFilled {\n            marketplace: object::object_address(&marketplace),\n            token_offer,\n            purchaser,\n            seller,\n            price,\n            royalties,\n            commission,\n            token_metadata,\n        });\n    }\n}\n"
  },
  {
    "folderName": "marketplace",
    "fileName": "fee_schedule.move",
    "path": "aptos-core/aptos-move/move-examples/marketplace/sources/fee_schedule.move",
    "content": "/// Defines the charges associated with using a marketplace, namely:\n/// * Listing rate, the units charged for creating a listing.\n/// * Bidding rate, the units per bid made by a potential buyer.\n/// * Commission, the units transferred to the marketplace upon sale.\nmodule marketplace::fee_schedule {\n    use std::error;\n    use std::signer;\n    use std::string::{Self, String};\n    use aptos_std::math64;\n\n    use aptos_std::type_info;\n\n    use aptos_framework::event;\n    use aptos_framework::object::{Self, ConstructorRef, ExtendRef, Object};\n\n    /// FeeSchedule does not exist.\n    const ENO_FEE_SCHEDULE: u64 = 1;\n    /// The denominator in a fraction cannot be zero.\n    const EDENOMINATOR_IS_ZERO: u64 = 2;\n    /// The value represented by a fraction cannot be greater than 1.\n    const EEXCEEDS_MAXIMUM: u64 = 3;\n    /// The passed in signer is not the owner of the marketplace.\n    const ENOT_OWNER: u64 = 4;\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Defines marketplace fees\n    struct FeeSchedule has key {\n        /// Address to send fees to\n        fee_address: address,\n        /// Ref for changing the configuration of the marketplace\n        extend_ref: ExtendRef,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Fixed rate for bidding\n    struct FixedRateBiddingFee has drop, key {\n        /// Fixed rate for bidding\n        bidding_fee: u64,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Fixed rate for listing\n    struct FixedRateListingFee has drop, key {\n        /// Fixed rate for listing\n        listing_fee: u64,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Fixed rate for commission\n    struct FixedRateCommission has drop, key {\n        /// Fixed rate for commission\n        commission: u64,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Percentage-based rate for commission\n    struct PercentageRateCommission has drop, key {\n        /// Denominator for the commission rate\n        denominator: u64,\n        /// Numerator for the commission rate\n        numerator: u64,\n    }\n\n    #[event]\n    /// Event representing a change to the marketplace configuration\n    struct Mutation has drop, store {\n        marketplace: address,\n        /// The type info of the struct that was updated.\n        updated_resource: String,\n    }\n\n    // Initializers\n\n    /// Create a marketplace with a fixed bidding and listing rate and a percentage commission.\n    public entry fun init_entry(\n        creator: &signer,\n        fee_address: address,\n        bidding_fee: u64,\n        listing_fee: u64,\n        commission_denominator: u64,\n        commission_numerator: u64,\n    ) {\n        init(\n            creator,\n            fee_address,\n            bidding_fee,\n            listing_fee,\n            commission_denominator,\n            commission_numerator,\n        );\n    }\n\n\n    public fun init(\n        creator: &signer,\n        fee_address: address,\n        bidding_fee: u64,\n        listing_fee: u64,\n        commission_denominator: u64,\n        commission_numerator: u64,\n    ): Object<FeeSchedule> {\n        assert!(\n            commission_numerator <= commission_denominator,\n            error::invalid_argument(EEXCEEDS_MAXIMUM),\n        );\n        assert!(\n            commission_denominator != 0,\n            error::out_of_range(EDENOMINATOR_IS_ZERO),\n        );\n\n        let (constructor_ref, fee_schedule_signer) = empty_init(creator, fee_address);\n        move_to(&fee_schedule_signer, FixedRateBiddingFee { bidding_fee });\n        move_to(&fee_schedule_signer, FixedRateListingFee { listing_fee });\n        let commission_rate = PercentageRateCommission {\n            denominator: commission_denominator,\n            numerator: commission_numerator,\n        };\n        move_to(&fee_schedule_signer, commission_rate);\n        object::object_from_constructor_ref(&constructor_ref)\n    }\n\n    /// Create a marketplace with no fees.\n    public entry fun empty(creator: &signer, fee_address: address) {\n        empty_init(creator, fee_address);\n    }\n\n    inline fun empty_init(creator: &signer, fee_address: address): (ConstructorRef, signer) {\n        let constructor_ref = object::create_object_from_account(creator);\n        let extend_ref = object::generate_extend_ref(&constructor_ref);\n        let fee_schedule_signer = object::generate_signer(&constructor_ref);\n\n        let marketplace = FeeSchedule {\n            fee_address,\n            extend_ref,\n        };\n        move_to(&fee_schedule_signer, marketplace);\n\n        (constructor_ref, fee_schedule_signer)\n    }\n\n    // Mutators\n\n    /// Set the fee address\n    public entry fun set_fee_address(\n        creator: &signer,\n        marketplace: Object<FeeSchedule>,\n        fee_address: address,\n    ) acquires FeeSchedule {\n        let fee_schedule_addr = assert_exists_internal(&marketplace);\n        assert!(\n            object::is_owner(marketplace, signer::address_of(creator)),\n            error::permission_denied(ENOT_OWNER),\n        );\n        let fee_schedule_obj = borrow_global_mut<FeeSchedule>(fee_schedule_addr);\n        fee_schedule_obj.fee_address = fee_address;\n        let updated_resource = string::utf8(b\"fee_address\");\n        event::emit(Mutation { marketplace: fee_schedule_addr, updated_resource });\n    }\n\n    /// Remove any existing listing fees and set a fixed rate listing fee.\n    public entry fun set_fixed_rate_listing_fee(\n        creator: &signer,\n        marketplace: Object<FeeSchedule>,\n        fee: u64,\n    ) acquires FeeSchedule, FixedRateListingFee {\n        let fee_schedule_signer = remove_listing_fee(creator, marketplace);\n        move_to(&fee_schedule_signer, FixedRateListingFee { listing_fee: fee });\n        let updated_resource = type_info::type_name<FixedRateListingFee>();\n        event::emit(Mutation { marketplace: signer::address_of(&fee_schedule_signer), updated_resource });\n    }\n\n    inline fun remove_listing_fee(\n        creator: &signer,\n        marketplace: Object<FeeSchedule>,\n    ): signer acquires FeeSchedule, FixedRateListingFee {\n        let (fee_schedule_signer, fee_schedule_addr) = assert_access(creator, marketplace);\n        if (exists<FixedRateListingFee>(fee_schedule_addr)) {\n            move_from<FixedRateListingFee>(fee_schedule_addr);\n        };\n        fee_schedule_signer\n    }\n\n    /// Remove any existing bidding fees and set a fixed rate bidding fee.\n    public entry fun set_fixed_rate_bidding_fee(\n        creator: &signer,\n        marketplace: Object<FeeSchedule>,\n        fee: u64,\n    ) acquires FeeSchedule, FixedRateBiddingFee {\n        let fee_schedule_signer = remove_bidding_fee(creator, marketplace);\n        move_to(&fee_schedule_signer, FixedRateBiddingFee { bidding_fee: fee });\n        let updated_resource = type_info::type_name<FixedRateListingFee>();\n        event::emit(Mutation { marketplace: signer::address_of(&fee_schedule_signer), updated_resource });\n    }\n\n    inline fun remove_bidding_fee(\n        creator: &signer,\n        marketplace: Object<FeeSchedule>,\n    ): signer acquires FeeSchedule, FixedRateBiddingFee {\n        let (fee_schedule_signer, fee_schedule_addr) = assert_access(creator, marketplace);\n        if (exists<FixedRateBiddingFee>(fee_schedule_addr)) {\n            move_from<FixedRateBiddingFee>(fee_schedule_addr);\n        };\n        fee_schedule_signer\n    }\n\n    /// Remove any existing commission and set a fixed rate commission.\n    public entry fun set_fixed_rate_commission(\n        creator: &signer,\n        marketplace: Object<FeeSchedule>,\n        commission: u64,\n    ) acquires FeeSchedule, FixedRateCommission, PercentageRateCommission {\n        let fee_schedule_signer = remove_commission(creator, marketplace);\n        move_to(&fee_schedule_signer, FixedRateCommission { commission });\n        let updated_resource = type_info::type_name<FixedRateListingFee>();\n        event::emit(Mutation { marketplace: signer::address_of(&fee_schedule_signer), updated_resource });\n    }\n\n    /// Remove any existing commission and set a percentage rate commission.\n    public entry fun set_percentage_rate_commission(\n        creator: &signer,\n        marketplace: Object<FeeSchedule>,\n        denominator: u64,\n        numerator: u64,\n    ) acquires FeeSchedule, FixedRateCommission, PercentageRateCommission {\n        assert!(\n            numerator <= denominator,\n            error::invalid_argument(EEXCEEDS_MAXIMUM),\n        );\n        assert!(\n            denominator != 0,\n            error::out_of_range(EDENOMINATOR_IS_ZERO),\n        );\n\n        let fee_schedule_signer = remove_commission(creator, marketplace);\n        move_to(&fee_schedule_signer, PercentageRateCommission { denominator, numerator });\n        let updated_resource = type_info::type_name<FixedRateListingFee>();\n        event::emit(Mutation { marketplace: signer::address_of(&fee_schedule_signer), updated_resource });\n    }\n\n    inline fun remove_commission(\n        creator: &signer,\n        marketplace: Object<FeeSchedule>,\n    ): signer acquires FeeSchedule, FixedRateCommission, PercentageRateCommission {\n        let (fee_schedule_signer, fee_schedule_addr) = assert_access(creator, marketplace);\n        if (exists<FixedRateCommission>(fee_schedule_addr)) {\n            move_from<FixedRateCommission>(fee_schedule_addr);\n        } else if (exists<PercentageRateCommission>(fee_schedule_addr)) {\n            move_from<PercentageRateCommission>(fee_schedule_addr);\n        };\n        fee_schedule_signer\n    }\n\n    inline fun assert_access(\n        creator: &signer,\n        marketplace: Object<FeeSchedule>,\n    ): (signer, address) acquires FeeSchedule {\n        let fee_schedule_addr = assert_exists_internal(&marketplace);\n        assert!(\n            object::is_owner(marketplace, signer::address_of(creator)),\n            error::permission_denied(ENOT_OWNER),\n        );\n        let fee_schedule_obj = borrow_global<FeeSchedule>(fee_schedule_addr);\n        let fee_schedule_signer = object::generate_signer_for_extending(&fee_schedule_obj.extend_ref);\n        (fee_schedule_signer, fee_schedule_addr)\n    }\n\n    // View functions\n    #[view]\n    public fun fee_address(marketplace: Object<FeeSchedule>): address acquires FeeSchedule {\n        let fee_schedule_addr = assert_exists_internal(&marketplace);\n        borrow_global<FeeSchedule>(fee_schedule_addr).fee_address\n    }\n\n    #[view]\n    public fun listing_fee(\n        marketplace: Object<FeeSchedule>,\n        _base: u64,\n    ): u64 acquires FixedRateListingFee {\n        let fee_schedule_addr = assert_exists_internal(&marketplace);\n        if (exists<FixedRateListingFee>(fee_schedule_addr)) {\n            borrow_global<FixedRateListingFee>(fee_schedule_addr).listing_fee\n        } else {\n            0\n        }\n    }\n\n    #[view]\n    public fun bidding_fee(\n        marketplace: Object<FeeSchedule>,\n        _bid: u64,\n    ): u64 acquires FixedRateBiddingFee {\n        let fee_schedule_addr = assert_exists_internal(&marketplace);\n        if (exists<FixedRateBiddingFee>(fee_schedule_addr)) {\n            borrow_global<FixedRateBiddingFee>(fee_schedule_addr).bidding_fee\n        } else {\n            0\n        }\n    }\n\n    #[view]\n    public fun commission(\n        marketplace: Object<FeeSchedule>,\n        price: u64,\n    ): u64 acquires FixedRateCommission, PercentageRateCommission {\n        let fee_schedule_addr = assert_exists_internal(&marketplace);\n        if (exists<FixedRateCommission>(fee_schedule_addr)) {\n            borrow_global<FixedRateCommission>(fee_schedule_addr).commission\n        } else if (exists<PercentageRateCommission>(fee_schedule_addr)) {\n            let fees = borrow_global<PercentageRateCommission>(fee_schedule_addr);\n            math64::mul_div(price, fees.numerator, fees.denominator)\n        } else {\n            0\n        }\n    }\n\n    public fun assert_exists(marketplace: &Object<FeeSchedule>) {\n        assert_exists_internal(marketplace);\n    }\n\n    inline fun assert_exists_internal(marketplace: &Object<FeeSchedule>): address {\n        let fee_schedule_addr = object::object_address(marketplace);\n        assert!(\n            exists<FeeSchedule>(fee_schedule_addr),\n            error::not_found(ENO_FEE_SCHEDULE),\n        );\n        fee_schedule_addr\n    }\n\n    // Tests\n\n    #[test_only]\n    use aptos_framework::account;\n\n    #[test(creator = @0x123)]\n    fun test_init(\n        creator: &signer,\n    ) acquires FeeSchedule, FixedRateBiddingFee, FixedRateCommission, FixedRateListingFee, PercentageRateCommission {\n        let creator_addr = signer::address_of(creator);\n        account::create_account_for_test(creator_addr);\n        let obj = init(creator, creator_addr, 0, 0, 1, 0);\n\n        assert!(fee_address(obj) == creator_addr, 0);\n        assert!(listing_fee(obj, 5) == 0, 0);\n        assert!(bidding_fee(obj, 5) == 0, 0);\n        assert!(commission(obj, 5) == 0, 0);\n\n        set_fee_address(creator, obj, @0x0);\n        set_fixed_rate_listing_fee(creator, obj, 5);\n        set_fixed_rate_bidding_fee(creator, obj, 6);\n        set_percentage_rate_commission(creator, obj, 10, 1);\n\n        assert!(fee_address(obj) == @0x0, 0);\n        assert!(listing_fee(obj, 5) == 5, 0);\n        assert!(bidding_fee(obj, 5) == 6, 0);\n        assert!(commission(obj, 20) == 2, 0);\n\n        set_fixed_rate_commission(creator, obj, 8);\n        assert!(commission(obj, 20) == 8, 0);\n    }\n\n    #[test(creator = @0x123)]\n    fun test_empty_init(\n        creator: &signer,\n    ) acquires FeeSchedule, FixedRateBiddingFee, FixedRateCommission, FixedRateListingFee, PercentageRateCommission {\n        let creator_addr = signer::address_of(creator);\n        account::create_account_for_test(creator_addr);\n        let (constructor_ref, _fee_schedule_signer) = empty_init(creator, creator_addr);\n        let obj = object::object_from_constructor_ref(&constructor_ref);\n\n        assert!(fee_address(obj) == creator_addr, 0);\n        assert!(listing_fee(obj, 5) == 0, 0);\n        assert!(bidding_fee(obj, 5) == 0, 0);\n        assert!(commission(obj, 5) == 0, 0);\n\n        set_fee_address(creator, obj, @0x0);\n        set_fixed_rate_listing_fee(creator, obj, 5);\n        set_fixed_rate_bidding_fee(creator, obj, 6);\n        set_percentage_rate_commission(creator, obj, 10, 1);\n\n        assert!(fee_address(obj) == @0x0, 0);\n        assert!(listing_fee(obj, 5) == 5, 0);\n        assert!(bidding_fee(obj, 5) == 6, 0);\n        assert!(commission(obj, 20) == 2, 0);\n\n        set_fixed_rate_commission(creator, obj, 8);\n        assert!(commission(obj, 20) == 8, 0);\n    }\n\n    #[test(creator = @0x123, non_creator = @0x223)]\n    #[expected_failure(abort_code = 0x50004, location = Self)]\n    fun test_non_creator_fee_address(creator: &signer, non_creator: &signer) acquires FeeSchedule {\n        let creator_addr = signer::address_of(creator);\n        account::create_account_for_test(creator_addr);\n        let obj = init(creator, creator_addr, 0, 0, 1, 0);\n        set_fee_address(non_creator, obj, @0x0);\n    }\n\n    #[test(creator = @0x123, non_creator = @0x223)]\n    #[expected_failure(abort_code = 0x50004, location = Self)]\n    fun test_non_creator_fixed_listing(\n        creator: &signer,\n        non_creator: &signer,\n    ) acquires FeeSchedule, FixedRateListingFee {\n        let creator_addr = signer::address_of(creator);\n        account::create_account_for_test(creator_addr);\n        let obj = init(creator, creator_addr, 0, 0, 1, 0);\n        set_fixed_rate_listing_fee(non_creator, obj, 5);\n    }\n\n    #[test(creator = @0x123, non_creator = @0x223)]\n    #[expected_failure(abort_code = 0x50004, location = Self)]\n    fun test_non_creator_fixed_bidding(\n        creator: &signer,\n        non_creator: &signer,\n    ) acquires FeeSchedule, FixedRateBiddingFee {\n        let creator_addr = signer::address_of(creator);\n        account::create_account_for_test(creator_addr);\n        let obj = init(creator, creator_addr, 0, 0, 1, 0);\n        set_fixed_rate_bidding_fee(non_creator, obj, 6);\n    }\n\n    #[test(creator = @0x123, non_creator = @0x223)]\n    #[expected_failure(abort_code = 0x50004, location = Self)]\n    fun test_non_creator_percentage_commission(\n        creator: &signer,\n        non_creator: &signer,\n    ) acquires FeeSchedule, FixedRateCommission, PercentageRateCommission {\n        let creator_addr = signer::address_of(creator);\n        account::create_account_for_test(creator_addr);\n        let obj = init(creator, creator_addr, 0, 0, 1, 0);\n        set_percentage_rate_commission(non_creator, obj, 10, 1);\n    }\n\n    #[test(creator = @0x123, non_creator = @0x223)]\n    #[expected_failure(abort_code = 0x50004, location = Self)]\n    fun test_non_creator_fixed_commission(\n        creator: &signer,\n        non_creator: &signer,\n    ) acquires FeeSchedule, FixedRateCommission, PercentageRateCommission {\n        let creator_addr = signer::address_of(creator);\n        account::create_account_for_test(creator_addr);\n        let obj = init(creator, creator_addr, 0, 0, 1, 0);\n        set_fixed_rate_commission(non_creator, obj, 8);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x20002, location = Self)]\n    fun test_init_zero_denominator_percentage_commission(creator: &signer) {\n        let creator_addr = signer::address_of(creator);\n        account::create_account_for_test(creator_addr);\n        init(creator, creator_addr, 0, 0, 0, 0);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x20002, location = Self)]\n    fun test_set_zero_denominator_percentage_commission(\n        creator: &signer,\n    ) acquires FeeSchedule, FixedRateCommission, PercentageRateCommission {\n        let creator_addr = signer::address_of(creator);\n        account::create_account_for_test(creator_addr);\n        let obj = init(creator, creator_addr, 0, 0, 1, 0);\n        set_percentage_rate_commission(creator, obj, 0, 0);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x10003, location = Self)]\n    fun test_init_too_big_percentage_commission(creator: &signer) {\n        let creator_addr = signer::address_of(creator);\n        account::create_account_for_test(creator_addr);\n        init(creator, creator_addr, 0, 0, 1, 2);\n    }\n\n    #[test(creator = @0x123)]\n    #[expected_failure(abort_code = 0x10003, location = Self)]\n    fun test_set_too_big_percentage_commission(\n        creator: &signer,\n    ) acquires FeeSchedule, FixedRateCommission, PercentageRateCommission {\n        let creator_addr = signer::address_of(creator);\n        account::create_account_for_test(creator_addr);\n        let obj = init(creator, creator_addr, 0, 0, 1, 0);\n        set_percentage_rate_commission(creator, obj, 1, 2);\n    }\n}\n"
  },
  {
    "folderName": "marketplace",
    "fileName": "listing.move",
    "path": "aptos-core/aptos-move/move-examples/marketplace/sources/listing.move",
    "content": "/// Defines a single listing or an item for sale or auction. This is an escrow service that\n/// enables two parties to exchange one asset for another.\n/// Each listing has the following properties:\n/// * FeeSchedule specifying payment flows\n/// * Owner or the person that can end the sale or auction\n/// * Starting time\n/// * Logic for cleanup\nmodule marketplace::listing {\n    use std::error;\n    use std::option;\n    use std::signer;\n    use std::string::String;\n\n    use aptos_std::math64;\n\n    use aptos_framework::object::{Self, ConstructorRef, DeleteRef, ExtendRef, Object, ObjectCore, TransferRef};\n    use aptos_framework::timestamp;\n\n    use aptos_token::token::{Self as tokenv1, Token as TokenV1};\n    use aptos_token_objects::token as tokenv2;\n    use aptos_token_objects::royalty;\n\n    use marketplace::events;\n    use marketplace::fee_schedule::FeeSchedule;\n\n    friend marketplace::coin_listing;\n\n    /// There exists no listing.\n    const ENO_LISTING: u64 = 1;\n    /// The listing is not yet live.\n    const ELISTING_NOT_STARTED: u64 = 2;\n    /// The entity is not the creator.\n    const ENOT_CREATOR: u64 = 3;\n    /// The entity is not the owner of the wrapped token.\n    const ENOT_OWNER: u64 = 4;\n\n    // Core data structures\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Corner-stone for all listings, represents the core utility layer including object\n    /// cleanup.\n    struct Listing has key {\n        /// The item owned by this listing, transferred to the new owner at the end.\n        object: Object<ObjectCore>,\n        /// The seller of the object\n        seller: address,\n        /// The fees associated with claiming this listing.\n        fee_schedule: Object<FeeSchedule>,\n        /// The Unix timestamp in seconds at which point bidding and purchasing can occur\n        start_time: u64,\n        /// Used to clean-up at the end.\n        delete_ref: DeleteRef,\n        /// Used to create a signer to transfer the listed item, ideally the TransferRef would\n        /// support this.\n        extend_ref: ExtendRef,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Contains a tokenv1 as an object\n    struct TokenV1Container has key {\n        /// The stored token.\n        token: TokenV1,\n        /// Used to cleanup the object at the end\n        delete_ref: DeleteRef,\n        /// Used to transfer the tokenv1 at the conclusion of a purchase.\n        transfer_ref: TransferRef,\n    }\n\n    // Init functions\n\n    public(friend) fun init(\n        creator: &signer,\n        object: Object<ObjectCore>,\n        fee_schedule: Object<FeeSchedule>,\n        start_time: u64,\n    ): (signer, ConstructorRef) {\n        let constructor_ref = object::create_object_from_account(creator);\n        // Once we construct this, both the listing and its contents are soulbound until the conclusion.\n        let transfer_ref = object::generate_transfer_ref(&constructor_ref);\n        object::disable_ungated_transfer(&transfer_ref);\n        let listing_signer = object::generate_signer(&constructor_ref);\n\n        let listing = Listing {\n            object,\n            seller: signer::address_of(creator),\n            fee_schedule,\n            start_time,\n            delete_ref: object::generate_delete_ref(&constructor_ref),\n            extend_ref: object::generate_extend_ref(&constructor_ref),\n        };\n        move_to(&listing_signer, listing);\n\n        let listing_addr = object::address_from_constructor_ref(&constructor_ref);\n        object::transfer(creator, object, listing_addr);\n\n        (listing_signer, constructor_ref)\n    }\n\n    public(friend) fun create_tokenv1_container(\n        seller: &signer,\n        token_creator: address,\n        token_collection: String,\n        token_name: String,\n        token_property_version: u64,\n    ): Object<TokenV1Container> {\n        let token_id = tokenv1::create_token_id_raw(\n            token_creator,\n            token_collection,\n            token_name,\n            token_property_version,\n        );\n        let token = tokenv1::withdraw_token(seller, token_id, 1);\n        create_tokenv1_container_with_token(seller, token)\n    }\n\n    public fun create_tokenv1_container_with_token(\n        seller: &signer,\n        token: TokenV1,\n    ): Object<TokenV1Container> {\n        let constructor_ref = object::create_object_from_account(seller);\n        let container_signer = object::generate_signer(&constructor_ref);\n        let delete_ref = object::generate_delete_ref(&constructor_ref);\n        let transfer_ref = object::generate_transfer_ref(&constructor_ref);\n\n        move_to(&container_signer, TokenV1Container { token, delete_ref, transfer_ref });\n        object::object_from_constructor_ref(&constructor_ref)\n    }\n\n    // Mutators\n\n    /// This should be called at the end of a listing.\n    public(friend) fun extract_or_transfer_tokenv1(\n        closer: &signer,\n        recipient: address,\n        object: Object<TokenV1Container>,\n    ) acquires TokenV1Container {\n        let direct_transfer_enabled = tokenv1::get_direct_transfer(recipient);\n        let object_addr = object::object_address(&object);\n        if (direct_transfer_enabled) {\n            let TokenV1Container {\n                token,\n                delete_ref,\n                transfer_ref: _,\n            } = move_from(object_addr);\n            tokenv1::direct_deposit_with_opt_in(recipient, token);\n            object::delete(delete_ref);\n        } else if (signer::address_of(closer) == recipient) {\n            let TokenV1Container {\n                token,\n                delete_ref,\n                transfer_ref: _,\n            } = move_from(object_addr);\n            tokenv1::deposit_token(closer, token);\n            object::delete(delete_ref);\n        } else {\n            let tokenv1_container = borrow_global<TokenV1Container>(object_addr);\n            let linear_transfer_ref =\n                object::generate_linear_transfer_ref(&tokenv1_container.transfer_ref);\n            object::transfer_with_ref(linear_transfer_ref, recipient);\n        };\n    }\n\n    /// If the account did not have tokenv1 enabled, then it must call this after making the\n    /// purchase to extract the token.\n    public entry fun extract_tokenv1(\n        owner: &signer,\n        object: Object<TokenV1Container>,\n    ) acquires TokenV1Container {\n        let object_addr = object::object_address(&object);\n        assert!(\n            object::is_owner(object, signer::address_of(owner)),\n            error::permission_denied(ENOT_OWNER),\n        );\n        let TokenV1Container {\n            token,\n            delete_ref,\n            transfer_ref: _,\n        } = move_from(object_addr);\n        object::delete(delete_ref);\n        tokenv1::deposit_token(owner, token);\n    }\n\n    /// The listing has concluded, transfer the asset and delete the listing. Returns the seller\n    /// for depositing any profit and the fee schedule for the marketplaces commission.\n    public(friend) fun close(\n        closer: &signer,\n        object: Object<Listing>,\n        recipient: address,\n    ): (address, Object<FeeSchedule>) acquires Listing, TokenV1Container {\n        let listing_addr = object::object_address(&object);\n        let Listing {\n            object,\n            seller,\n            fee_schedule,\n            start_time: _,\n            delete_ref,\n            extend_ref,\n        } = move_from<Listing>(listing_addr);\n\n        let obj_signer = object::generate_signer_for_extending(&extend_ref);\n        if (exists<TokenV1Container>(object::object_address(&object))) {\n            extract_or_transfer_tokenv1(closer, recipient, object::convert(object));\n        } else {\n            object::transfer(&obj_signer, object, recipient);\n        };\n        object::delete(delete_ref);\n\n        (seller, fee_schedule)\n    }\n\n    public(friend) fun assert_started(object: &Object<Listing>): address acquires Listing {\n        let listing_addr = object::object_address(object);\n        assert!(exists<Listing>(listing_addr), error::not_found(ENO_LISTING));\n\n        let listing = borrow_global<Listing>(listing_addr);\n        let now = timestamp::now_seconds();\n        assert!(listing.start_time <= now, error::invalid_state(ELISTING_NOT_STARTED));\n        listing_addr\n    }\n\n    // View\n\n    #[view]\n    public fun seller(object: Object<Listing>): address acquires Listing {\n        let listing = borrow_listing(object);\n        listing.seller\n    }\n\n    #[view]\n    public fun listed_object(object: Object<Listing>): Object<ObjectCore> acquires Listing {\n        let listing = borrow_listing(object);\n        listing.object\n    }\n\n    #[view]\n    public fun fee_schedule(object: Object<Listing>): Object<FeeSchedule> acquires Listing {\n        let listing = borrow_listing(object);\n        listing.fee_schedule\n    }\n\n    #[view]\n    /// Compute the royalty either from the internal TokenV1, TokenV2 if it exists, or return\n    /// no royalty.\n    public fun compute_royalty(\n        object: Object<Listing>,\n        amount: u64,\n    ): (address, u64) acquires Listing, TokenV1Container {\n        let listing = borrow_listing(object);\n        let obj_addr = object::object_address(&listing.object);\n        if (exists<TokenV1Container>(obj_addr)) {\n            let token_container = borrow_global<TokenV1Container>(obj_addr);\n            let token_id = tokenv1::get_token_id(&token_container.token);\n            let royalty = tokenv1::get_royalty(token_id);\n\n            let payee_address = tokenv1::get_royalty_payee(&royalty);\n            let numerator = tokenv1::get_royalty_numerator(&royalty);\n            let denominator = tokenv1::get_royalty_denominator(&royalty);\n            let royalty_amount = bounded_percentage(amount, numerator, denominator);\n            (payee_address, royalty_amount)\n        } else {\n            let royalty = tokenv2::royalty(listing.object);\n            if (option::is_some(&royalty)) {\n                let royalty = option::destroy_some(royalty);\n                let payee_address = royalty::payee_address(&royalty);\n                let numerator = royalty::numerator(&royalty);\n                let denominator = royalty::denominator(&royalty);\n\n                let royalty_amount = bounded_percentage(amount, numerator, denominator);\n                (payee_address, royalty_amount)\n            } else {\n                (@0x0, 0)\n            }\n        }\n    }\n\n    #[view]\n    /// Produce a events::TokenMetadata for a listing\n    public fun token_metadata(\n        object: Object<Listing>,\n    ): events::TokenMetadata acquires Listing, TokenV1Container {\n        let listing = borrow_listing(object);\n        let obj_addr = object::object_address(&listing.object);\n        if (exists<TokenV1Container>(obj_addr)) {\n            let token_container = borrow_global<TokenV1Container>(obj_addr);\n            let token_id = tokenv1::get_token_id(&token_container.token);\n            events::token_metadata_for_tokenv1(token_id)\n        } else {\n            events::token_metadata_for_tokenv2(object::convert(listing.object))\n        }\n    }\n\n    /// Calculates a bounded percentage that can't go over 100% and handles 0 denominator as 0\n    public inline fun bounded_percentage(amount: u64, numerator: u64, denominator: u64): u64 {\n        if (denominator == 0) {\n            0\n        } else {\n            math64::min(amount, math64::mul_div(amount, numerator, denominator))\n        }\n    }\n\n    inline fun borrow_listing(object: Object<Listing>): &Listing acquires Listing {\n        let obj_addr = object::object_address(&object);\n        assert!(exists<Listing>(obj_addr), error::not_found(ENO_LISTING));\n        borrow_global<Listing>(obj_addr)\n    }\n}\n"
  },
  {
    "folderName": "marketplace",
    "fileName": "test_utils.move",
    "path": "aptos-core/aptos-move/move-examples/marketplace/sources/test_utils.move",
    "content": "#[test_only]\nmodule marketplace::test_utils {\n    use std::signer;\n    use std::string;\n    use std::vector;\n\n    use aptos_framework::account;\n    use aptos_framework::aptos_coin::{Self, AptosCoin};\n    use aptos_framework::coin;\n    use aptos_framework::object::{Self, Object};\n    use aptos_framework::timestamp;\n\n    use aptos_token::token as tokenv1;\n    use aptos_token_objects::token::Token;\n    use aptos_token_objects::aptos_token;\n    use aptos_token_objects::collection::Collection;\n\n    use marketplace::fee_schedule::{Self, FeeSchedule};\n\n    public inline fun setup(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ): (address, address, address) {\n        timestamp::set_time_has_started_for_testing(aptos_framework);\n        let (burn_cap, mint_cap) = aptos_coin::initialize_for_test(aptos_framework);\n\n        let marketplace_addr = signer::address_of(marketplace);\n        account::create_account_for_test(marketplace_addr);\n        coin::register<AptosCoin>(marketplace);\n\n        let seller_addr = signer::address_of(seller);\n        account::create_account_for_test(seller_addr);\n        coin::register<AptosCoin>(seller);\n\n        let purchaser_addr = signer::address_of(purchaser);\n        account::create_account_for_test(purchaser_addr);\n        coin::register<AptosCoin>(purchaser);\n\n        let coins = coin::mint(10000, &mint_cap);\n        coin::deposit(seller_addr, coins);\n        let coins = coin::mint(10000, &mint_cap);\n        coin::deposit(purchaser_addr, coins);\n\n        coin::destroy_burn_cap(burn_cap);\n        coin::destroy_mint_cap(mint_cap);\n\n        (marketplace_addr, seller_addr, purchaser_addr)\n    }\n\n    public fun fee_schedule(seller: &signer): Object<FeeSchedule> {\n        fee_schedule::init(\n            seller,\n            signer::address_of(seller),\n            2,\n            1,\n            100,\n            1,\n        )\n    }\n\n    public inline fun increment_timestamp(seconds: u64) {\n        timestamp::update_global_time_for_test(timestamp::now_microseconds() + (seconds * 1000000));\n    }\n\n    public fun mint_tokenv2_with_collection(seller: &signer): (Object<Collection>, Object<Token>) {\n        let collection_name = string::utf8(b\"collection_name\");\n\n        let collection_object = aptos_token::create_collection_object(\n            seller,\n            string::utf8(b\"collection description\"),\n            2,\n            collection_name,\n            string::utf8(b\"collection uri\"),\n            true,\n            true,\n            true,\n            true,\n            true,\n            true,\n            true,\n            true,\n            true,\n            1,\n            100,\n        );\n\n        let aptos_token = aptos_token::mint_token_object(\n            seller,\n            collection_name,\n            string::utf8(b\"description\"),\n            string::utf8(b\"token_name\"),\n            string::utf8(b\"uri\"),\n            vector::empty(),\n            vector::empty(),\n            vector::empty(),\n        );\n        (object::convert(collection_object), object::convert(aptos_token))\n    }\n\n    public fun mint_tokenv2_with_collection_royalty(\n        seller: &signer,\n        royalty_numerator: u64,\n        royalty_denominator: u64\n    ): (Object<Collection>, Object<Token>) {\n        let collection_name = string::utf8(b\"collection_name\");\n\n        let collection_object = aptos_token::create_collection_object(\n            seller,\n            string::utf8(b\"collection description\"),\n            2,\n            collection_name,\n            string::utf8(b\"collection uri\"),\n            true,\n            true,\n            true,\n            true,\n            true,\n            true,\n            true,\n            true,\n            true,\n            royalty_numerator,\n            royalty_denominator,\n        );\n\n        let aptos_token = aptos_token::mint_token_object(\n            seller,\n            collection_name,\n            string::utf8(b\"description\"),\n            string::utf8(b\"token_name\"),\n            string::utf8(b\"uri\"),\n            vector::empty(),\n            vector::empty(),\n            vector::empty(),\n        );\n        (object::convert(collection_object), object::convert(aptos_token))\n    }\n\n    public fun mint_tokenv2(seller: &signer): Object<Token> {\n        let (_collection, token) = mint_tokenv2_with_collection(seller);\n        token\n    }\n\n    public fun mint_tokenv2_additional(seller: &signer): Object<Token> {\n        let collection_name = string::utf8(b\"collection_name\");\n\n        let aptos_token = aptos_token::mint_token_object(\n            seller,\n            collection_name,\n            string::utf8(b\"description\"),\n            string::utf8(b\"token_name_2\"),\n            string::utf8(b\"uri\"),\n            vector::empty(),\n            vector::empty(),\n            vector::empty(),\n        );\n        object::convert(aptos_token)\n    }\n\n    public fun mint_tokenv1(seller: &signer): tokenv1::TokenId {\n        let collection_name = string::utf8(b\"collection_name\");\n        let token_name = string::utf8(b\"token_name\");\n\n        tokenv1::create_collection(\n            seller,\n            collection_name,\n            string::utf8(b\"Collection: Hello, World\"),\n            string::utf8(b\"https://aptos.dev\"),\n            2,\n            vector[true, true, true],\n        );\n\n        tokenv1::create_token_script(\n            seller,\n            collection_name,\n            token_name,\n            string::utf8(b\"Hello, Token\"),\n            1,\n            1,\n            string::utf8(b\"https://aptos.dev\"),\n            signer::address_of(seller),\n            100,\n            1,\n            vector[true, true, true, true, true],\n            vector::empty(),\n            vector::empty(),\n            vector::empty(),\n        );\n\n        tokenv1::create_token_id_raw(\n            signer::address_of(seller),\n            collection_name,\n            token_name,\n            0,\n        )\n    }\n\n    public fun mint_tokenv1_additional(seller: &signer): tokenv1::TokenId {\n        let collection_name = string::utf8(b\"collection_name\");\n        let token_name = string::utf8(b\"token_name_2\");\n        tokenv1::create_token_script(\n            seller,\n            collection_name,\n            token_name,\n            string::utf8(b\"Hello, Token\"),\n            1,\n            1,\n            string::utf8(b\"https://aptos.dev\"),\n            signer::address_of(seller),\n            100,\n            1,\n            vector[true, true, true, true, true],\n            vector::empty(),\n            vector::empty(),\n            vector::empty(),\n        );\n\n        tokenv1::create_token_id_raw(\n            signer::address_of(seller),\n            collection_name,\n            token_name,\n            0,\n        )\n    }\n\n    public fun mint_tokenv1_additional_royalty(\n        seller: &signer,\n        royalty_numerator: u64,\n        royalty_denominator: u64\n    ): tokenv1::TokenId {\n        let collection_name = string::utf8(b\"collection_name\");\n        let token_name = string::utf8(b\"token_name_2\");\n        tokenv1::create_token_script(\n            seller,\n            collection_name,\n            token_name,\n            string::utf8(b\"Hello, Token\"),\n            1,\n            1,\n            string::utf8(b\"https://aptos.dev\"),\n            signer::address_of(seller),\n            royalty_denominator,\n            royalty_numerator,\n            vector[true, true, true, true, true],\n            vector::empty(),\n            vector::empty(),\n            vector::empty(),\n        );\n\n        tokenv1::create_token_id_raw(\n            signer::address_of(seller),\n            collection_name,\n            token_name,\n            0,\n        )\n    }\n}\n"
  },
  {
    "folderName": "marketplace",
    "fileName": "token_offer.move",
    "path": "aptos-core/aptos-move/move-examples/marketplace/sources/token_offer.move",
    "content": "address marketplace {\n/// Provides the ability to make token offers to both Tokenv1 and Tokenv2 tokens.\n/// A token offer allows an entity to place a bid on a token at any time. The amount\n/// offered is extracted from their account and stored at an escrow. A seller can then\n/// exchange the token for the escrowed payment. If it is a tokenv2 or the recipient\n/// has enabled direct deposit, the token is immediately transferred. If it is tokenv1\n/// without direct deposit, it is stored in a container until the recipient extracts it.\nmodule token_offer {\n    use std::error;\n    use std::option::{Self, Option};\n    use std::signer;\n    use std::string::String;\n\n    use aptos_framework::coin::{Self, Coin};\n    use aptos_framework::object::{Self, DeleteRef, Object};\n    use aptos_framework::timestamp;\n\n    use aptos_token::token as tokenv1;\n\n    use aptos_token_objects::royalty;\n    use aptos_token_objects::token::{Self as tokenv2, Token as TokenV2};\n\n    use marketplace::events;\n    use marketplace::fee_schedule::{Self, FeeSchedule};\n    use marketplace::listing::{Self, TokenV1Container};\n    use aptos_token::token::TokenId;\n    use aptos_framework::aptos_account;\n\n    /// No token offer defined.\n    const ENO_TOKEN_OFFER: u64 = 1;\n    /// No coin offer defined.\n    const ENO_COIN_OFFER: u64 = 2;\n    /// This is not the owner of the token.\n    const ENOT_TOKEN_OWNER: u64 = 3;\n    /// This is not the owner of the token offer.\n    const ENOT_OWNER: u64 = 4;\n    /// The token offer has expired.\n    const EEXPIRED: u64 = 6;\n\n    // Core data structures\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Create a timed offer to buy a token. The token and\n    /// assets used to buy are stored in other resources within the object.\n    struct TokenOffer has key {\n        fee_schedule: Object<FeeSchedule>,\n        item_price: u64,\n        expiration_time: u64,\n        delete_ref: DeleteRef,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Stores coins for a token offer.\n    struct CoinOffer<phantom CoinType> has key {\n        coins: Coin<CoinType>,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Stores the metadata associated with a tokenv1 token offer.\n    struct TokenOfferTokenV1 has copy, drop, key {\n        creator_address: address,\n        collection_name: String,\n        token_name: String,\n        property_version: u64,\n    }\n\n    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n    /// Stores the metadata associated with a tokenv2 token offer.\n    struct TokenOfferTokenV2 has copy, drop, key {\n        token: Object<TokenV2>,\n    }\n\n    // Initializers\n\n    /// Create a tokenv1 token offer.\n    public entry fun init_for_tokenv1_entry<CoinType>(\n        purchaser: &signer,\n        creator_address: address,\n        collection_name: String,\n        token_name: String,\n        property_version: u64,\n        fee_schedule: Object<FeeSchedule>,\n        item_price: u64,\n        expiration_time: u64,\n    ) {\n        init_for_tokenv1<CoinType>(\n            purchaser,\n            creator_address,\n            collection_name,\n            token_name,\n            property_version,\n            fee_schedule,\n            item_price,\n            expiration_time\n        );\n    }\n\n    public fun init_for_tokenv1<CoinType>(\n        purchaser: &signer,\n        creator_address: address,\n        collection_name: String,\n        token_name: String,\n        property_version: u64,\n        fee_schedule: Object<FeeSchedule>,\n        item_price: u64,\n        expiration_time: u64,\n    ): Object<TokenOffer> {\n        let offer_signer = init_offer(purchaser, fee_schedule, item_price, expiration_time);\n        init_coin_holder<CoinType>(purchaser, &offer_signer, fee_schedule, item_price);\n        move_to(&offer_signer, TokenOfferTokenV1 { creator_address, collection_name, token_name, property_version });\n\n        let token_id = tokenv1::create_token_id(\n            tokenv1::create_token_data_id(creator_address, collection_name, token_name),\n            property_version\n        );\n        let token_offer_addr = signer::address_of(&offer_signer);\n        events::emit_token_offer_placed(\n            fee_schedule,\n            token_offer_addr,\n            signer::address_of(purchaser),\n            item_price,\n            events::token_metadata_for_tokenv1(token_id),\n        );\n\n        object::address_to_object(token_offer_addr)\n    }\n\n    /// Create a tokenv2 token offer.\n    public entry fun init_for_tokenv2_entry<CoinType>(\n        purchaser: &signer,\n        token: Object<TokenV2>,\n        fee_schedule: Object<FeeSchedule>,\n        item_price: u64,\n        expiration_time: u64,\n    ) {\n        init_for_tokenv2<CoinType>(\n            purchaser,\n            token,\n            fee_schedule,\n            item_price,\n            expiration_time\n        );\n    }\n\n    public fun init_for_tokenv2<CoinType>(\n        purchaser: &signer,\n        token: Object<TokenV2>,\n        fee_schedule: Object<FeeSchedule>,\n        item_price: u64,\n        expiration_time: u64,\n    ): Object<TokenOffer> {\n        let offer_signer = init_offer(purchaser, fee_schedule, item_price, expiration_time);\n        init_coin_holder<CoinType>(purchaser, &offer_signer, fee_schedule, item_price);\n        move_to(&offer_signer, TokenOfferTokenV2 { token });\n\n        let token_offer_addr = signer::address_of(&offer_signer);\n        events::emit_token_offer_placed(\n            fee_schedule,\n            token_offer_addr,\n            signer::address_of(purchaser),\n            item_price,\n            events::token_metadata_for_tokenv2(token),\n        );\n\n        object::address_to_object(token_offer_addr)\n    }\n\n    inline fun init_offer(\n        purchaser: &signer,\n        fee_schedule: Object<FeeSchedule>,\n        item_price: u64,\n        expiration_time: u64,\n    ): signer {\n        let constructor_ref = object::create_object_from_account(purchaser);\n        // Once we construct this, both the listing and its contents are soulbound until the conclusion.\n        let transfer_ref = object::generate_transfer_ref(&constructor_ref);\n        object::disable_ungated_transfer(&transfer_ref);\n\n        let offer_signer = object::generate_signer(&constructor_ref);\n        let offer = TokenOffer {\n            fee_schedule,\n            item_price,\n            expiration_time,\n            delete_ref: object::generate_delete_ref(&constructor_ref),\n        };\n        move_to(&offer_signer, offer);\n\n        offer_signer\n    }\n\n    inline fun init_coin_holder<CoinType>(\n        purchaser: &signer,\n        offer_signer: &signer,\n        fee_schedule: Object<FeeSchedule>,\n        total_to_extract: u64,\n    ) {\n        let fee = fee_schedule::listing_fee(fee_schedule, total_to_extract);\n        let fee_address = fee_schedule::fee_address(fee_schedule);\n        aptos_account::transfer_coins<CoinType>(purchaser, fee_address, fee);\n\n        let coins = coin::withdraw<CoinType>(purchaser, total_to_extract);\n        move_to(offer_signer, CoinOffer { coins });\n    }\n\n    // Mutators\n\n    ///\n    public entry fun cancel<CoinType>(\n        purchaser: &signer,\n        token_offer: Object<TokenOffer>,\n    ) acquires CoinOffer, TokenOffer, TokenOfferTokenV1, TokenOfferTokenV2 {\n        let token_offer_addr = object::object_address(&token_offer);\n        assert!(\n            exists<TokenOffer>(token_offer_addr),\n            error::not_found(ENO_TOKEN_OFFER),\n        );\n        assert!(\n            object::is_owner(token_offer, signer::address_of(purchaser)),\n            error::permission_denied(ENOT_OWNER),\n        );\n        let token_offer_obj = borrow_global_mut<TokenOffer>(token_offer_addr);\n        let token_metadata = if (exists<TokenOfferTokenV2>(token_offer_addr)) {\n            events::token_metadata_for_tokenv2(\n                borrow_global<TokenOfferTokenV2>(token_offer_addr).token,\n            )\n        } else {\n            let offer_info = borrow_global<TokenOfferTokenV1>(token_offer_addr);\n            events::token_metadata_for_tokenv1(\n                token_v1_token_id(offer_info)\n            )\n        };\n\n        events::emit_token_offer_canceled(\n            token_offer_obj.fee_schedule,\n            token_offer_addr,\n            signer::address_of(purchaser),\n            token_offer_obj.item_price,\n            token_metadata,\n        );\n\n        cleanup<CoinType>(token_offer);\n    }\n\n    /// Sell a tokenv1 to a token offer.\n    public entry fun sell_tokenv1_entry<CoinType>(\n        seller: &signer,\n        token_offer: Object<TokenOffer>,\n        token_name: String,\n        property_version: u64,\n    ) acquires CoinOffer, TokenOffer, TokenOfferTokenV1, TokenOfferTokenV2\n    {\n        sell_tokenv1<CoinType>(seller, token_offer, token_name, property_version);\n    }\n\n    /// Sell a tokenv1 to a token offer.\n    public fun sell_tokenv1<CoinType>(\n        seller: &signer,\n        token_offer: Object<TokenOffer>,\n        token_name: String,\n        property_version: u64,\n    ): Option<Object<TokenV1Container>>\n    acquires\n    CoinOffer,\n    TokenOffer,\n    TokenOfferTokenV1,\n    TokenOfferTokenV2\n    {\n        let token_offer_addr = object::object_address(&token_offer);\n        assert!(\n            exists<TokenOfferTokenV1>(token_offer_addr),\n            error::not_found(ENO_TOKEN_OFFER),\n        );\n        let token_offer_tokenv1_offer =\n            borrow_global_mut<TokenOfferTokenV1>(token_offer_addr);\n\n        // Move the token to its destination\n\n        let token_id = tokenv1::create_token_id_raw(\n            token_offer_tokenv1_offer.creator_address,\n            token_offer_tokenv1_offer.collection_name,\n            token_name,\n            property_version,\n        );\n\n        let token = tokenv1::withdraw_token(seller, token_id, 1);\n\n        let recipient = object::owner(token_offer);\n        let container = if (tokenv1::get_direct_transfer(recipient)) {\n            tokenv1::direct_deposit_with_opt_in(recipient, token);\n            option::none()\n        } else {\n            let container = listing::create_tokenv1_container_with_token(seller, token);\n            object::transfer(seller, container, recipient);\n            option::some(container)\n        };\n\n        // Pay fees\n\n        let royalty = tokenv1::get_royalty(token_id);\n        settle_payments<CoinType>(\n            object::owner(token_offer),\n            signer::address_of(seller),\n            token_offer_addr,\n            tokenv1::get_royalty_payee(&royalty),\n            tokenv1::get_royalty_denominator(&royalty),\n            tokenv1::get_royalty_numerator(&royalty),\n            events::token_metadata_for_tokenv1(token_id),\n        );\n\n        container\n    }\n\n    /// Sell a tokenv2 to a token offer.\n    public entry fun sell_tokenv2<CoinType>(\n        seller: &signer,\n        token_offer: Object<TokenOffer>,\n    ) acquires CoinOffer, TokenOffer, TokenOfferTokenV1, TokenOfferTokenV2 {\n        let token_offer_addr = object::object_address(&token_offer);\n        assert!(\n            exists<TokenOfferTokenV2>(token_offer_addr),\n            error::not_found(ENO_TOKEN_OFFER),\n        );\n\n        // Check it's the correct token\n        let seller_address = signer::address_of(seller);\n        let token = borrow_global<TokenOfferTokenV2>(token_offer_addr).token;\n        assert!(seller_address == object::owner(token), error::permission_denied(ENOT_TOKEN_OWNER));\n\n        // Move the token to its destination\n        let recipient = object::owner(token_offer);\n        object::transfer(seller, token, recipient);\n\n        // Pay fees\n\n        let royalty = tokenv2::royalty(token);\n        let (royalty_payee, royalty_denominator, royalty_numerator) = if (option::is_some(&royalty)) {\n            let royalty = option::destroy_some(royalty);\n            let payee_address = royalty::payee_address(&royalty);\n            let denominator = royalty::denominator(&royalty);\n            let numerator = royalty::numerator(&royalty);\n            (payee_address, denominator, numerator)\n        } else {\n            (signer::address_of(seller), 1, 0)\n        };\n\n        settle_payments<CoinType>(\n            object::owner(token_offer),\n            seller_address,\n            token_offer_addr,\n            royalty_payee,\n            royalty_denominator,\n            royalty_numerator,\n            events::token_metadata_for_tokenv2(token),\n        );\n    }\n\n    /// From the coin offer remove appropriate payment for the token and distribute to the seller,\n    /// the creator for royalties, and the marketplace for commission. If there are no more slots,\n    /// cleanup the offer.\n    inline fun settle_payments<CoinType>(\n        buyer: address,\n        seller: address,\n        token_offer_addr: address,\n        royalty_payee: address,\n        royalty_denominator: u64,\n        royalty_numerator: u64,\n        token_metadata: events::TokenMetadata,\n    ) acquires CoinOffer, TokenOffer, TokenOfferTokenV1, TokenOfferTokenV2 {\n        assert!(exists<TokenOffer>(token_offer_addr), error::not_found(ENO_TOKEN_OFFER));\n        let token_offer_obj = borrow_global_mut<TokenOffer>(token_offer_addr);\n        assert!(\n            timestamp::now_seconds() < token_offer_obj.expiration_time,\n            error::invalid_state(EEXPIRED),\n        );\n        let price = token_offer_obj.item_price;\n\n        assert!(\n            exists<CoinOffer<CoinType>>(token_offer_addr),\n            error::not_found(ENO_COIN_OFFER),\n        );\n        let coin_offer = borrow_global_mut<CoinOffer<CoinType>>(token_offer_addr);\n        let coins = coin::extract(&mut coin_offer.coins, price);\n\n        let royalty_charge = price * royalty_numerator / royalty_denominator;\n        let royalties = coin::extract(&mut coins, royalty_charge);\n        aptos_account::deposit_coins(royalty_payee, royalties);\n\n        let fee_schedule = token_offer_obj.fee_schedule;\n        let commission_charge = fee_schedule::commission(fee_schedule, price);\n        let commission = coin::extract(&mut coins, commission_charge);\n        aptos_account::deposit_coins(fee_schedule::fee_address(fee_schedule), commission);\n\n        aptos_account::deposit_coins(seller, coins);\n\n        events::emit_token_offer_filled(\n            fee_schedule,\n            token_offer_addr,\n            buyer,\n            seller,\n            price,\n            royalty_charge,\n            commission_charge,\n            token_metadata,\n        );\n\n        cleanup<CoinType>(object::address_to_object(token_offer_addr));\n    }\n\n    /// Cleanup the offer by deleting it and returning the remaining funds to the token offer\n    /// creator.\n    inline fun cleanup<CoinType>(\n        token_offer: Object<TokenOffer>,\n    ) acquires CoinOffer, TokenOffer, TokenOfferTokenV1, TokenOfferTokenV2 {\n        let token_offer_addr = object::object_address(&token_offer);\n        let CoinOffer<CoinType> { coins } = move_from(token_offer_addr);\n        aptos_account::deposit_coins(object::owner(token_offer), coins);\n\n        let TokenOffer {\n            fee_schedule: _,\n            item_price: _,\n            expiration_time: _,\n            delete_ref,\n        } = move_from(token_offer_addr);\n        object::delete(delete_ref);\n\n        if (exists<TokenOfferTokenV2>(token_offer_addr)) {\n            move_from<TokenOfferTokenV2>(token_offer_addr);\n        } else if (exists<TokenOfferTokenV1>(token_offer_addr)) {\n            move_from<TokenOfferTokenV1>(token_offer_addr);\n        };\n    }\n\n    // View\n\n    #[view]\n    public fun exists_at(token_offer: Object<TokenOffer>): bool {\n        exists<TokenOffer>(object::object_address(&token_offer))\n    }\n\n    #[view]\n    public fun expired(token_offer: Object<TokenOffer>): bool acquires TokenOffer {\n        borrow_token_offer(token_offer).expiration_time < timestamp::now_seconds()\n    }\n\n    #[view]\n    public fun expiration_time(\n        token_offer: Object<TokenOffer>,\n    ): u64 acquires TokenOffer {\n        borrow_token_offer(token_offer).expiration_time\n    }\n\n    #[view]\n    public fun fee_schedule(\n        token_offer: Object<TokenOffer>,\n    ): Object<FeeSchedule> acquires TokenOffer {\n        borrow_token_offer(token_offer).fee_schedule\n    }\n\n    #[view]\n    public fun price(token_offer: Object<TokenOffer>): u64 acquires TokenOffer {\n        borrow_token_offer(token_offer).item_price\n    }\n\n    #[view]\n    public fun collectionv1(\n        token_offer: Object<TokenOffer>,\n    ): TokenOfferTokenV1 acquires TokenOfferTokenV1 {\n        let token_offer_addr = object::object_address(&token_offer);\n        assert!(\n            exists<TokenOfferTokenV1>(token_offer_addr),\n            error::not_found(ENO_TOKEN_OFFER),\n        );\n        *borrow_global(token_offer_addr)\n    }\n\n    #[view]\n    public fun collectionv2(\n        token_offer: Object<TokenOffer>,\n    ): TokenOfferTokenV2 acquires TokenOfferTokenV2 {\n        let token_offer_addr = object::object_address(&token_offer);\n        assert!(\n            exists<TokenOffer>(token_offer_addr),\n            error::not_found(ENO_TOKEN_OFFER),\n        );\n        *borrow_global(token_offer_addr)\n    }\n\n    inline fun borrow_token_offer(\n        token_offer: Object<TokenOffer>,\n    ): &TokenOffer acquires TokenOffer {\n        let token_offer_addr = object::object_address(&token_offer);\n        assert!(\n            exists<TokenOffer>(token_offer_addr),\n            error::not_found(ENO_TOKEN_OFFER),\n        );\n        borrow_global(token_offer_addr)\n    }\n\n    inline fun token_v1_token_id(\n        token_offer_tokenv1_offer: &TokenOfferTokenV1,\n    ): TokenId {\n        tokenv1::create_token_id_raw(\n            token_offer_tokenv1_offer.creator_address,\n            token_offer_tokenv1_offer.collection_name,\n            token_offer_tokenv1_offer.token_name,\n            token_offer_tokenv1_offer.property_version,\n        )\n    }\n}\n\n#[test_only]\nmodule token_offer_tests {\n    use aptos_framework::aptos_coin::AptosCoin;\n    use aptos_framework::coin;\n    use aptos_framework::object;\n    use aptos_framework::timestamp;\n\n    use aptos_token::token as tokenv1;\n\n    use marketplace::token_offer;\n    use marketplace::listing;\n    use marketplace::test_utils;\n    use std::option;\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_token_v2(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (marketplace_addr, seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        let token = test_utils::mint_tokenv2(seller);\n        assert!(object::is_owner(token, seller_addr), 0);\n        let token_offer = token_offer::init_for_tokenv2<AptosCoin>(\n            purchaser,\n            token,\n            test_utils::fee_schedule(marketplace),\n            500,\n            timestamp::now_seconds() + 200,\n        );\n        assert!(!token_offer::expired(token_offer), 0);\n        assert!(token_offer::expiration_time(token_offer) == timestamp::now_seconds() + 200, 0);\n        assert!(token_offer::price(token_offer) == 500, 0);\n\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 1, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 9499, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 10000, 0);\n\n        token_offer::sell_tokenv2<AptosCoin>(seller, token_offer);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 6, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 9499, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 10495, 0);\n        assert!(object::is_owner(token, purchaser_addr), 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_token_v1_direct_deposit(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (marketplace_addr, seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        tokenv1::opt_in_direct_transfer(purchaser, true);\n        tokenv1::opt_in_direct_transfer(seller, true);\n\n        let token_id = test_utils::mint_tokenv1(seller);\n        assert!(tokenv1::balance_of(seller_addr, token_id) == 1, 0);\n\n        let (creator_addr, collection_name, token_name, property_version) =\n            tokenv1::get_token_id_fields(&token_id);\n\n        let token_offer = token_offer::init_for_tokenv1<AptosCoin>(\n            purchaser,\n            creator_addr,\n            collection_name,\n            token_name,\n            property_version,\n            test_utils::fee_schedule(marketplace),\n            500,\n            timestamp::now_seconds() + 200,\n        );\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 1, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 9499, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 10000, 0);\n\n        token_offer::sell_tokenv1<AptosCoin>(seller, token_offer, token_name, property_version);\n        assert!(coin::balance<AptosCoin>(marketplace_addr) == 6, 0);\n        assert!(coin::balance<AptosCoin>(purchaser_addr) == 9499, 0);\n        assert!(coin::balance<AptosCoin>(seller_addr) == 10495, 0);\n        assert!(tokenv1::balance_of(purchaser_addr, token_id) == 1, 0);\n\n        assert!(!token_offer::exists_at(token_offer), 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    fun test_token_v1_indirect(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (_marketplace_addr, seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let token_id = test_utils::mint_tokenv1(seller);\n        assert!(tokenv1::balance_of(seller_addr, token_id) == 1, 0);\n\n        let (creator_addr, collection_name, token_name, property_version) =\n            tokenv1::get_token_id_fields(&token_id);\n\n        let token_offer = token_offer::init_for_tokenv1<AptosCoin>(\n            purchaser,\n            creator_addr,\n            collection_name,\n            token_name,\n            property_version,\n            test_utils::fee_schedule(marketplace),\n            500,\n            timestamp::now_seconds() + 200,\n        );\n\n        let token_container = token_offer::sell_tokenv1<AptosCoin>(\n            seller,\n            token_offer,\n            token_name,\n            property_version,\n        );\n        listing::extract_tokenv1(purchaser, option::destroy_some(token_container));\n        assert!(tokenv1::balance_of(purchaser_addr, token_id) == 1, 0);\n        assert!(!token_offer::exists_at(token_offer), 0);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x50003, location = marketplace::token_offer)]\n    fun test_token_v2_has_none(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        let token = test_utils::mint_tokenv2(seller);\n        let token_offer = token_offer::init_for_tokenv2<AptosCoin>(\n            purchaser,\n            token,\n            test_utils::fee_schedule(marketplace),\n            500,\n            timestamp::now_seconds() + 200,\n        );\n        token_offer::sell_tokenv2<AptosCoin>(marketplace, token_offer);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x10005, location = aptos_token::token)]\n    fun test_token_v1_has_none(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        let token_id = test_utils::mint_tokenv1(seller);\n        let (creator_addr, collection_name, token_name, property_version) =\n            tokenv1::get_token_id_fields(&token_id);\n\n        let token_offer = token_offer::init_for_tokenv1<AptosCoin>(\n            purchaser,\n            creator_addr,\n            collection_name,\n            token_name,\n            property_version,\n            test_utils::fee_schedule(marketplace),\n            500,\n            timestamp::now_seconds() + 200,\n        );\n\n        token_offer::sell_tokenv1<AptosCoin>(\n            marketplace,\n            token_offer,\n            token_name,\n            property_version,\n        );\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x30006, location = marketplace::token_offer)]\n    fun test_token_v2_expired(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        let token = test_utils::mint_tokenv2(seller);\n        let token_offer = token_offer::init_for_tokenv2<AptosCoin>(\n            purchaser,\n            token,\n            test_utils::fee_schedule(marketplace),\n            500,\n            timestamp::now_seconds() + 200,\n        );\n        test_utils::increment_timestamp(200);\n        token_offer::sell_tokenv2<AptosCoin>(seller, token_offer);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x60001, location = marketplace::token_offer)]\n    fun test_token_v2_exhausted(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        let token = test_utils::mint_tokenv2(seller);\n        let token_offer = token_offer::init_for_tokenv2<AptosCoin>(\n            purchaser,\n            token,\n            test_utils::fee_schedule(marketplace),\n            500,\n            timestamp::now_seconds() + 200,\n        );\n        token_offer::sell_tokenv2<AptosCoin>(seller, token_offer);\n        token_offer::sell_tokenv2<AptosCoin>(purchaser, token_offer);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x50003, location = marketplace::token_offer)]\n    fun test_token_v2_other_token(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n        let _token = test_utils::mint_tokenv2(seller);\n        let token_2 = test_utils::mint_tokenv2_additional(seller);\n\n        let token_offer = token_offer::init_for_tokenv2<AptosCoin>(\n            purchaser,\n            token_2,\n            test_utils::fee_schedule(marketplace),\n            500,\n            timestamp::now_seconds() + 200,\n        );\n        token_offer::sell_tokenv2<AptosCoin>(marketplace, token_offer);\n    }\n\n    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]\n    #[expected_failure(abort_code = 0x10005, location = aptos_token::token)]\n    fun test_token_v1_other_token(\n        aptos_framework: &signer,\n        marketplace: &signer,\n        seller: &signer,\n        purchaser: &signer,\n    ) {\n        let (_marketplace_addr, _seller_addr, purchaser_addr) =\n            test_utils::setup(aptos_framework, marketplace, seller, purchaser);\n\n        let token_id_1 = test_utils::mint_tokenv1(seller);\n        let (_creator_addr, _collection_name, token_name_1, property_version_1) =\n            tokenv1::get_token_id_fields(&token_id_1);\n\n        let token_id_2 = test_utils::mint_tokenv1_additional(seller);\n        let (_creator_addr, collection_name, token_name_2, property_version_2) =\n            tokenv1::get_token_id_fields(&token_id_2);\n        let token_offer = token_offer::init_for_tokenv1<AptosCoin>(\n            purchaser,\n            purchaser_addr,\n            collection_name,\n            token_name_1,\n            property_version_1,\n            test_utils::fee_schedule(marketplace),\n            500,\n            timestamp::now_seconds() + 200,\n        );\n        token_offer::sell_tokenv1<AptosCoin>(\n            marketplace,\n            token_offer,\n            token_name_2,\n            property_version_2,\n        );\n    }\n}\n}\n"
  },
  {
    "folderName": "message_board",
    "fileName": "acl_message_board.move",
    "path": "aptos-core/aptos-move/move-examples/message_board/sources/acl_message_board.move",
    "content": "/// This module demonstrates a basic messageboard using ACL to control the access.\n/// Admins can\n///     (1) create their messageboard\n///     (2) add a partipant to its access control list (ACL)\n///     (3) remove a participant from its ACL\n/// participant can\n///     (1) register for the board\n///     (2) send a new message\n///\n/// The module also emits events for subscribers\n///     (1) message change event, this event contains the board, message and message author\nmodule message_board::acl_based_mb {\n    use std::acl::Self;\n    use std::signer;\n    use std::vector;\n    use aptos_framework::event;\n\n    // Error map\n    const EACCOUNT_NOT_IN_ACL: u64 = 1;\n    const ECANNOT_REMOVE_ADMIN_FROM_ACL: u64 = 2;\n\n    struct ACLBasedMB has key {\n        participants: acl::ACL,\n        pinned_post: vector<u8>\n    }\n\n    #[event]\n    /// emit an event from participant account showing the board and the new message\n    struct MessageChange has store, drop {\n        board: address,\n        message: vector<u8>,\n        participant: address\n    }\n\n    /// init message board\n    public entry fun message_board_init(account: &signer) {\n        let board = ACLBasedMB {\n            participants: acl::empty(),\n            pinned_post: vector::empty<u8>()\n        };\n        acl::add(&mut board.participants, signer::address_of(account));\n        move_to(account, board);\n    }\n\n    public fun view_message(board_addr: address): vector<u8> acquires ACLBasedMB {\n        let post = borrow_global<ACLBasedMB>(board_addr).pinned_post;\n        copy post\n    }\n\n    /// board owner control adding new participants\n    public entry fun add_participant(account: &signer, participant: address) acquires ACLBasedMB {\n        let board = borrow_global_mut<ACLBasedMB>(signer::address_of(account));\n        acl::add(&mut board.participants, participant);\n    }\n\n    /// remove a participant from the ACL\n    public entry fun remove_participant(account: signer, participant: address) acquires ACLBasedMB {\n        let board = borrow_global_mut<ACLBasedMB>(signer::address_of(&account));\n        assert!(signer::address_of(&account) != participant, ECANNOT_REMOVE_ADMIN_FROM_ACL);\n        acl::remove(&mut board.participants, participant);\n    }\n\n    /// an account publish the message to update the notice\n    public entry fun send_pinned_message(\n        account: &signer, board_addr: address, message: vector<u8>\n    ) acquires ACLBasedMB {\n        let board = borrow_global<ACLBasedMB>(board_addr);\n        assert!(acl::contains(&board.participants, signer::address_of(account)), EACCOUNT_NOT_IN_ACL);\n\n        let board = borrow_global_mut<ACLBasedMB>(board_addr);\n        board.pinned_post = message;\n\n        let send_acct = signer::address_of(account);\n        event::emit(\n            MessageChange {\n                board: board_addr,\n                message,\n                participant: send_acct\n            }\n        );\n    }\n\n    /// an account can send events containing message\n    public entry fun send_message_to(account: signer, board_addr: address, message: vector<u8>) {\n        event::emit(\n            MessageChange {\n                board: board_addr,\n                message,\n                participant: signer::address_of(&account)\n            }\n        );\n    }\n}\n\n#[test_only]\nmodule message_board::MessageBoardTests {\n    use std::unit_test;\n    use std::vector;\n    use std::signer;\n\n    use message_board::acl_based_mb;\n\n    const HELLO_WORLD: vector<u8> = vector<u8>[150, 145, 154, 154, 157, 040, 167, 157, 162, 154, 144];\n    const BOB_IS_HERE: vector<u8> = vector<u8>[142, 157, 142, 040, 151, 163, 040, 150, 145, 162, 145];\n\n    #[test]\n    public entry fun test_init_messageboard() {\n        let (alice, _) = create_two_signers();\n        acl_based_mb::message_board_init(&alice);\n        acl_based_mb::send_pinned_message(&alice, signer::address_of(&alice), HELLO_WORLD);\n    }\n\n    #[test]\n    public entry fun test_send_pinned_message() {\n        let (alice, bob) = create_two_signers();\n        acl_based_mb::message_board_init(&alice);\n        acl_based_mb::add_participant(&alice, signer::address_of(&bob));\n        acl_based_mb::send_pinned_message(&bob, signer::address_of(&alice), BOB_IS_HERE);\n        let message = acl_based_mb::view_message(signer::address_of(&alice));\n        assert!(message == BOB_IS_HERE, 1);\n        let message = acl_based_mb::view_message(signer::address_of(&alice));\n        assert!(message == BOB_IS_HERE, 1);\n    }\n\n    #[test]\n    public entry fun test_send_message_v_cap() {\n        let (alice, bob) = create_two_signers();\n        acl_based_mb::message_board_init(&alice);\n        acl_based_mb::send_message_to(bob, signer::address_of(&alice), BOB_IS_HERE);\n    }\n\n    #[test]\n    public entry fun read_message_multiple_times() {\n        let (alice, bob) = create_two_signers();\n        acl_based_mb::message_board_init(&alice);\n        acl_based_mb::add_participant(&alice, signer::address_of(&bob));\n        acl_based_mb::send_pinned_message(&bob, signer::address_of(&alice), BOB_IS_HERE);\n        let message = acl_based_mb::view_message(signer::address_of(&alice));\n        assert!(message == BOB_IS_HERE, 1);\n        let message = acl_based_mb::view_message(signer::address_of(&alice));\n        assert!(message == BOB_IS_HERE, 1);\n    }\n\n    #[test]\n    #[expected_failure(abort_code = 1, location = message_board::acl_based_mb)]\n    public entry fun test_add_new_participant() {\n        let (alice, bob) = create_two_signers();\n        acl_based_mb::message_board_init(&alice);\n        acl_based_mb::send_pinned_message(&bob, signer::address_of(&alice), BOB_IS_HERE);\n    }\n\n    #[test_only]\n    fun create_two_signers(): (signer, signer) {\n        let signers = &mut unit_test::create_signers_for_testing(2);\n        let (alice, bob) = (vector::pop_back(signers), vector::pop_back(signers));\n        aptos_framework::account::create_account_for_test(signer::address_of(&alice));\n        aptos_framework::account::create_account_for_test(signer::address_of(&bob));\n        (alice, bob)\n    }\n}\n"
  },
  {
    "folderName": "message_board",
    "fileName": "cap_message_board.move",
    "path": "aptos-core/aptos-move/move-examples/message_board/sources/cap_message_board.move",
    "content": "/// This module demonstrates a basic messageboard using capability to control the access.\n/// Admin can\n///     (1) create their messageboard\n///     (2) offer participants capability to update the pinned message\n///     (3) remove the capability from a participant\n/// participant can\n///     (1) register for the board\n///     (2) redeem the offered capability to update pinned message\n///     (3) send a new message\n///\n/// The module also emits two types of events for subscribes\n///     (1) message cap update event, this event contains the board address and participant offered capability\n///     (2) message change event, this event contains the board, message and message author\nmodule message_board::cap_based_mb {\n    use message_board::offer;\n    use std::signer;\n    use std::vector;\n    use aptos_framework::event;\n\n    // Error map\n    const EACCOUNT_NO_NOTICE_CAP: u64 = 1;\n    const EONLY_ADMIN_CAN_REMOVE_NOTICE_CAP: u64 = 2;\n\n    struct CapBasedMB has key {\n        pinned_post: vector<u8>\n    }\n\n    /// provide the capability to alert the board message\n    struct MessageChangeCapability has key, store {\n        board: address\n    }\n\n    #[event]\n    /// emit an event from board acct showing the new participant with posting capability\n    struct MessageCapUpdate has store, drop {\n        board: address,\n        participant: address,\n    }\n\n    #[event]\n    /// emit an event from participant account showing the board and the new message\n    struct MessageChange has store, drop {\n        board: address,\n        message: vector<u8>,\n        participant: address\n    }\n\n    /// create the message board and move the resource to signer\n    public entry fun message_board_init(account: &signer) {\n        let board = CapBasedMB {\n            pinned_post: vector::empty<u8>()\n        };\n        let board_addr = signer::address_of(account);\n        move_to(account, board);\n        let notice_cap = MessageChangeCapability { board: board_addr };\n        move_to(account, notice_cap);\n    }\n\n    /// directly view message\n    public fun view_message(board_addr: address): vector<u8> acquires CapBasedMB {\n        let post = borrow_global<CapBasedMB>(board_addr).pinned_post;\n        copy post\n    }\n\n    /// board owner controls adding new participants\n    public entry fun add_participant(account: &signer, participant: address) {\n        let board = signer::address_of(account);\n        offer::create(account, MessageChangeCapability { board }, participant);\n\n        event::emit(MessageCapUpdate { board, participant });\n    }\n\n    /// claim offered capability\n    public entry fun claim_notice_cap(account: &signer, board: address) {\n        let notice_cap = offer::redeem<MessageChangeCapability>(\n            account, board);\n        move_to(account, notice_cap);\n    }\n\n    /// remove a participant capability to publish notice\n    public entry fun remove_participant(account: signer, participant: address) acquires MessageChangeCapability {\n        let cap = borrow_global_mut<MessageChangeCapability>(participant);\n        assert!(signer::address_of(&account) == cap.board, EONLY_ADMIN_CAN_REMOVE_NOTICE_CAP);\n        let cap = move_from<MessageChangeCapability>(participant);\n        let MessageChangeCapability { board: _ } = cap;\n    }\n\n    /// only the participant with right capability can publish the message\n    public entry fun send_pinned_message(\n        account: &signer, board_addr: address, message: vector<u8>\n    ) acquires MessageChangeCapability, CapBasedMB {\n        let cap = borrow_global<MessageChangeCapability>(signer::address_of(account));\n        assert!(cap.board == board_addr, EACCOUNT_NO_NOTICE_CAP);\n        let board = borrow_global_mut<CapBasedMB>(board_addr);\n        board.pinned_post = message;\n        event::emit(\n            MessageChange {\n                board: board_addr,\n                message,\n                participant: signer::address_of(account)\n            }\n        );\n    }\n\n    /// an account can send events containing message\n    public entry fun send_message_to(account: signer, board_addr: address, message: vector<u8>) {\n        event::emit(\n            MessageChange {\n                board: board_addr,\n                message,\n                participant: signer::address_of(&account)\n            }\n        );\n    }\n}\n\n#[test_only]\nmodule message_board::MessageBoardCapTests {\n    use std::unit_test;\n    use std::vector;\n    use std::signer;\n    use message_board::cap_based_mb;\n\n\n    const HELLO_WORLD: vector<u8> = vector<u8>[150, 145, 154, 154, 157, 040, 167, 157, 162, 154, 144];\n    const BOB_IS_HERE: vector<u8> = vector<u8>[142, 157, 142, 040, 151, 163, 040, 150, 145, 162, 145];\n\n    #[test]\n    public entry fun test_init_messageboard_v_cap() {\n        let (alice, _) = create_two_signers();\n        cap_based_mb::message_board_init(&alice);\n        let board_addr = signer::address_of(&alice);\n        cap_based_mb::send_pinned_message(&alice, board_addr, HELLO_WORLD);\n    }\n\n    #[test]\n    public entry fun test_send_pinned_message_v_cap() {\n        let (alice, bob) = create_two_signers();\n        cap_based_mb::message_board_init(&alice);\n        cap_based_mb::add_participant(&alice, signer::address_of(&bob));\n        cap_based_mb::claim_notice_cap(&bob, signer::address_of(&alice));\n        cap_based_mb::send_pinned_message(&bob, signer::address_of(&alice), BOB_IS_HERE);\n        let message = cap_based_mb::view_message(signer::address_of(&alice));\n        assert!(message == BOB_IS_HERE, 1)\n    }\n\n    #[test]\n    public entry fun test_send_message_v_cap() {\n        let (alice, bob) = create_two_signers();\n        cap_based_mb::message_board_init(&alice);\n        cap_based_mb::send_message_to(bob, signer::address_of(&alice), BOB_IS_HERE);\n    }\n\n    #[test]\n    #[expected_failure]\n    public entry fun test_add_new_participant_v_cap() {\n        let (alice, bob) = create_two_signers();\n        cap_based_mb::message_board_init(&alice);\n        cap_based_mb::add_participant(&alice, signer::address_of(&bob));\n        cap_based_mb::send_pinned_message(&bob, signer::address_of(&alice), BOB_IS_HERE);\n    }\n\n    #[test_only]\n    fun create_two_signers(): (signer, signer) {\n        let signers = &mut unit_test::create_signers_for_testing(2);\n        let (alice, bob) = (vector::pop_back(signers), vector::pop_back(signers));\n        aptos_framework::account::create_account_for_test(signer::address_of(&alice));\n        aptos_framework::account::create_account_for_test(signer::address_of(&bob));\n        (alice, bob)\n    }\n}\n"
  },
  {
    "folderName": "message_board",
    "fileName": "offer.move",
    "path": "aptos-core/aptos-move/move-examples/message_board/sources/offer.move",
    "content": "/// Provides a way to transfer structs from one account to another in two transactions.\n/// Unlike many languages, Move cannot move data from one account to another with\n/// single-signer transactions. As of this writing, ordinary transactions can only have\n/// a single signer, and Move code can only store to an address (via `move_to`) if it\n/// can supply a reference to a signer for the destination address (there are special case\n/// exceptions in Genesis and DiemAccount where there can temporarily be multiple signers).\n///\n/// Offer solves this problem by providing an `Offer` resource.  To move a struct `T` from\n/// account A to B, account A first publishes an `Offer<T>` resource at `address_of(A)`,\n/// using the `offer::create` function.\n/// Then account B, in a separate transaction, can move the struct `T` from the `Offer` at\n/// A's address to the desired destination. B accesses the resource using the `redeem` function,\n/// which aborts unless the `for` field is B's address (preventing other addresses from\n/// accessing the `T` that is intended only for B). A can also redeem the `T` value if B hasn't\n/// redeemed it.\nmodule message_board::offer {\n  use std::signer;\n  use std::error;\n\n  /// A wrapper around value `offered` that can be claimed by the address stored in `for`.\n  struct Offer<Offered> has key { offered: Offered, for: address }\n\n  /// An offer of the specified type for the account does not exist\n  const EOFFER_DNE_FOR_ACCOUNT: u64 = 0;\n\n  /// Address already has an offer of this type.\n  const EOFFER_ALREADY_CREATED: u64 = 1;\n\n  /// Address does not have an offer of this type to redeem.\n  const EOFFER_DOES_NOT_EXIST: u64 = 2;\n\n  /// Publish a value of type `Offered` under the sender's account. The value can be claimed by\n  /// either the `for` address or the transaction sender.\n  public fun create<Offered: store>(account: &signer, offered: Offered, for: address) {\n    assert!(!exists<Offer<Offered>>(signer::address_of(account)), error::already_exists(EOFFER_ALREADY_CREATED));\n    move_to(account, Offer<Offered> { offered, for });\n  }\n  spec create {\n    /// Offer a struct to the account under address `for` by\n    /// placing the offer under the signer's address\n    aborts_if exists<Offer<Offered>>(signer::address_of(account));\n    ensures exists<Offer<Offered>>(signer::address_of(account));\n    ensures global<Offer<Offered>>(signer::address_of(account)) == Offer<Offered> { offered: offered, for: for };\n  }\n\n  /// Claim the value of type `Offered` published at `offer_address`.\n  /// Only succeeds if the sender is the intended recipient stored in `for` or the original\n  /// publisher `offer_address`.\n  /// Also fails if there is no `Offer<Offered>` published.\n  public fun redeem<Offered: store>(account: &signer, offer_address: address): Offered acquires Offer {\n    assert!(exists<Offer<Offered>>(offer_address), error::not_found(EOFFER_DOES_NOT_EXIST));\n    let Offer<Offered> { offered, for } = move_from<Offer<Offered>>(offer_address);\n    let sender = signer::address_of(account);\n    assert!(sender == for || sender == offer_address, error::invalid_argument(EOFFER_DNE_FOR_ACCOUNT));\n    offered\n  }\n  spec redeem {\n    /// Aborts if there is no offer under `offer_address` or if the account\n    /// cannot redeem the offer.\n    /// Ensures that the offered struct under `offer_address` is removed.\n    aborts_if !exists<Offer<Offered>>(offer_address);\n    aborts_if !is_allowed_recipient<Offered>(offer_address, signer::address_of(account));\n    ensures !exists<Offer<Offered>>(offer_address);\n    ensures result == old(global<Offer<Offered>>(offer_address).offered);\n  }\n\n  // Returns true if an offer of type `Offered` exists at `offer_address`.\n  public fun exists_at<Offered: store>(offer_address: address): bool {\n    exists<Offer<Offered>>(offer_address)\n  }\n  spec exists_at {\n    aborts_if false;\n    /// Returns whether or not an `Offer` resource is under the given address `offer_address`.\n    ensures result == exists<Offer<Offered>>(offer_address);\n  }\n\n\n  // Returns the address of the `Offered` type stored at `offer_address.\n  // Fails if no such `Offer` exists.\n  public fun address_of<Offered: store>(offer_address: address): address acquires Offer {\n    assert!(exists<Offer<Offered>>(offer_address), error::not_found(EOFFER_DOES_NOT_EXIST));\n    borrow_global<Offer<Offered>>(offer_address).for\n  }\n  spec address_of {\n    /// Aborts is there is no offer resource `Offer` at the `offer_address`.\n    /// Returns the address of the intended recipient of the Offer\n    /// under the `offer_address`.\n    aborts_if !exists<Offer<Offered>>(offer_address);\n    ensures result == global<Offer<Offered>>(offer_address).for;\n  }\n\n// =================================================================\n// Module Specification\n\n  spec module {} // switch documentation context back to module level\n\n  /// # Access Control\n\n  /// ## Creation of Offers\n\n  spec schema NoOfferCreated<Offered> {\n    /// Says no offer is created for any address. Later, it is applied to all functions\n    /// except `create`\n    ensures forall addr: address where !old(exists<Offer<Offered>>(addr)) : !exists<Offer<Offered>>(addr);\n  }\n  spec module {\n    /// Apply OnlyCreateCanCreateOffer to every function except `create`\n    apply NoOfferCreated<Offered> to *<Offered>, * except create;\n  }\n\n  /// ## Removal of Offers\n\n  spec schema NoOfferRemoved<Offered> {\n    /// Says no offer is removed for any address. Applied below to everything except `redeem`\n    ensures forall addr: address where old(exists<Offer<Offered>>(addr)) :\n              (exists<Offer<Offered>>(addr) && global<Offer<Offered>>(addr) == old(global<Offer<Offered>>(addr)));\n  }\n  spec module {\n    /// Only `redeem` can remove an offer from the global store.\n    apply NoOfferRemoved<Offered> to *<Offered>, * except redeem;\n  }\n\n  /// # Helper Functions\n\n  spec module {\n    /// Returns true if the recipient is allowed to redeem `Offer<Offered>` at `offer_address`\n    /// and false otherwise.\n    fun is_allowed_recipient<Offered>(offer_addr: address, recipient: address): bool {\n      recipient == global<Offer<Offered>>(offer_addr).for || recipient == offer_addr\n    }\n  }\n}\n"
  }
]
